<!DOCTYPE html>
<html lang="en">

<head>
   <meta charset="UTF-8">
   <meta http-equiv="X-UA-Compatible" content="IE=edge">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>Queue</title>
   <link rel="stylesheet" href="../../../../public/style.css">
   <link rel="stylesheet" id="highlightStylesheet"
      href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/tomorrow-night-blue.min.css">
      <link rel="icon" href="../../../../public/logo/favicon_io/favicon.ico">
</head>

<body class="bg-c">
   <div id="mySidepanel" class="sidepanel">
      <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">Ã—</a>
      <a href="../index.html" class="home">back</a>
      <a href="#t1" class="link">Queue definition</a>
      <a href="#t2" class="link">Operations associated with queue</a>
      <a href="#t3" class="link">Working of queue</a>
      <a href="#t6" class="link">Applications of queue</a>
      <a href="#t4" class="link">Linear queue</a>
      <a href="#t5" class="link">Circular queue</a>
      <a href="#t7" class="link">Double Ended queue</a>
      <a href="#t8" class="link">Priority queue</a>
      <a href="#t9" class="link">Queue Implementation using linked list</a>
      <a href="#t10" class="link">Circular Queue Implementation using linked list</a>
      <div class="botbut">
         <a href="../unit3/index.html" class="link">Next Topic &rarr;</a>
         <a href="./index.html" class="link">&larr; Previous Topic</a>
      </div>
   </div>
   <div id="navbar" class="grad">
      <div>
         <div class="openbtn" onclick="openNav()">
            <div id="nav-icon1" for="nav-menu1">
               <span></span>
               <span></span>
               <span></span>
            </div>
         </div>
      </div>
      <div>
         <h2>Queue</h2>
      </div>
   </div>
   <div class="content-box">
      <h1 id="t1">Queue</h1>
      <ul>
         <li>A queue is a <b>linear data structure</b> to store and manipulate the data elements.</li>
         <li>It follows the order of <b>First In First Out (FIFO).</b></li>
         <li>In queues, the first element entered into the array is the first element to be removed from the array.</li>
         <li>Real life example will be: Queue of people at ticket counter, where the first person entering queue gets
            ticket first.</li>
         <li><b>A queue is open at both ends.</b> One end is provided for the insertion of data and the other end for
            the deletion of data.</li>
      </ul>
      <div id="t2" class="wh">
         <h2>Operations associated with a Queue in C</h2>
         <ul>
            <li>A queue being an <b>Abstract Data Structure</b> provides the following operations for manipulation on
               the data elements:
               <ol>
                  <li><b>dequeue():</b> Removes the element from the frontal side of the queue.</li>
                  <li><b>enqueue():</b> It inserts elements to the end of the queue.</li>
                  <li><b>display():</b> Displays all the element present in a queue.</li>
                  <li><b>Front:</b> Pointer element responsible for fetching the first element from the queue.</li>
                  <li><b>Rear:</b> Pointer element responsible for fetching the last element from the queue.</li>
               </ol>
            </li>
         </ul>
      </div>
      <div id="t3" class="wh">
         <h2>Working of Queue Data Structure</h2>
         <ul>
            <li>Queue follows the First-In-First-Out pattern. The first element is the first to be pulled out from the
               list of elements.
               <ul>
                  <li><b>Front</b> and <b>Rear</b> pointers keep the record of the first and last element in the queue.
                  </li>
                  <li>At first, we need to initialize the queue by setting <b>Front = -1</b> and <b>Rear = -1.</b></li>
                  <li>In order to insert the element (<b>enqueue</b>), we need to check whether the queue is already
                     full i.e. <b>check the condition for Overflow.</b> If the queue is not full, we'll have to
                     increment the value of the Rear index by 1 and place the element at the position of the Rear
                     pointer variable. When we get to insert the first element in the queue, we need to set the value of
                     Front to 0.</li>
                  <li>In order to remove the element (<b>dequeue</b>) from the queue, we need to check whether the queue
                     is already empty i.e. <b>check the condition for Underflow.</b> If the queue is not empty, we'll
                     have to remove and return the element at the position of the Front pointer, and then increment the
                     Front index value by 1. When we get <b>to remove the last element from the queue</b>, we will have
                     <b>set the values of Front and Rear index to -1.</b>
                  </li>
               </ul>
            </li>
         </ul>
      </div>
      <div id="t6" class="wh">
         <h2>Applications of Queue Data Structure</h2>
         <ul>
            <li>CPU Scheduling: In computer operating systems, queues are used to manage processes and threads. The
               scheduler maintains a queue of processes waiting for the CPU. When a process completes its execution, it
               is removed from the queue, and the next process in the queue is executed.</li>
            <li>Networking: In computer networking, queues are used to manage network traffic. Packets arriving at a
               router or a switch are placed in a queue and are processed in a first-in, first-out (FIFO) order. This
               helps to prevent congestion and ensures that all packets are processed in a fair manner.</li>
            <li>Printers: Printers often use queues to manage print jobs. When multiple users are sending print jobs to
               a printer, the printer places them in a queue and processes them in the order they were received.</li>
            <li>Gaming: Queues can be used to implement game mechanics like turn-based games, player-vs-player
               matchmaking, and other game mechanics that require sequencing of actions.</li>
            <li>Disk Scheduling</li>
            <li>Breadth-First Search Algorithm (BFS)</li>
         </ul>
      </div>
      <div id="t4" class="wh">
         <h2>Implementation of Linear Queue using array in C</h2>
         <ul>
            <li><a class="ba" href="https://www.youtube.com/watch?v=YqrFeU90Coo" target="_blank">Linear queue video
                  &neArr;</a>
            </li>
         </ul>
         <div class='code'>
            <div class='dotc'></div>
            <button class="ac">code</button>
            <div class="panel">
               <pre>
                  <code>
#include &lt;stdio.h>
#include &lt;stdlib.h>
#define MAX 5
int queue[MAX];
int rear = -1;
int front = -1;
void enqueue()
{
    if (rear == MAX - 1)
    {
        printf("\nQueue is full");
        return;
    }
    if (front == -1 && rear == -1)
        front = rear = 0;
    else
        rear++;
    printf("\nEnter the element : ");
    scanf("%d", &queue[rear]);
}
void dequeue()
{
    if (front == -1 && rear == -1)
    {
        printf("\nQueue is empty");
        return;
    }
    int val = queue[front];
    if (front == rear)
        front = rear = -1;
    else
        front++;
    printf("\n%d is deleted", val);
}
void display()
{
    int i;
    if (front == -1 && rear == -1)
    {
        printf("\nQueue is empty\n");
        return;
    }
    for (i = front; i <= rear; i++)
    {
        printf("\n%d", queue[i]);
    }
}
int main()
{
    int ch;
    while (1)
    {
        printf("\n------- MENU -------");
        printf("\n1.Enqueue Operation\n");
        printf("2.Dequeue Operation\n");
        printf("3.Display the Queue\n");
        printf("4.Exit\n");
        printf("Enter your choice of operations : ");
        scanf("%d", &ch);
        switch (ch)
        {
        case 1:
            enqueue();
            break;
        case 2:
            dequeue();
            break;
        case 3:
            display();
            break;
        case 4:
            exit(0);
        default:
            printf("\nIncorrect choice \n");
        }
    }
    return 0;
}
                  </code>
               </pre>
            </div>
         </div>
      </div>
      <div id="t5" class="wh">
         <h2>Circular queue</h2>
         <ul>
            <li>A circular queue is a data structure that allows efficient insertion and deletion of elements at both
               ends. It is similar to a regular queue in that it follows the "first-in, first-out" (FIFO) principle, but
               the main difference is that the last element is connected to the first element, forming a loop.</li>
            <li>When circular queue is implemented using array and when the rear pointer reaches the end of the array,
               it wraps around to the beginning of the array. Similarly, when the front pointer reaches the end of the
               array, it also wraps around to the beginning of the array. This allows the circular queue to efficiently
               use the available space in the array</li>
            <li>And when circular queue is implemented using linked linked then the last node points to the front.</li>
            <li>Cicular queue is used in music player.</li>
         </ul>
         <ul>
            <li><a href="https://www.youtube.com/watch?v=dn01XST9-bI" target="_blank">Circular queue video lecture
                  &neArr;</a></li>
         </ul>
         <p>Problems with linear queue:
         <ul>
            <li>When the queue is full and we perform dequeue twice that means there are 2 place are empty (not
               literally) but then when if we do enqueue then it will show queue is full because rear = MAX - 1.</li>
         </ul>
         To Save us from this problem we use <b>circular queue.</b>
         </p>
         <div class='code'>
            <div class='dotc'></div>
            <button class="ac">Circular queue using array code</button>
            <div class="panel">
               <pre>
                  <code>
#include &lt;stdio.h>
#include &lt;stdlib.h>
#define MAX 5
int queue[MAX];
int rear = -1;
int front = -1;
void enqueue()
{
    if ((rear + 1) % MAX == front)
    {
        printf("\nQueue is full");
        return;
    }
    if (front == -1 && rear == -1)
        front = rear = 0;
    else
        rear = (rear + 1) % MAX;
    printf("\nEnter the element : ");
    scanf("%d", &queue[rear]);
}
void dequeue()
{
    if (front == -1 && rear == -1)
    {
        printf("\nQueue is empty");
        return
    }
    int val = queue[front];
    if (front == rear)
        front = rear = -1;
    else
        front = (front + 1) % MAX;
    printf("\n%d is deleted", val);
}
void display()
{
    int i;
    if (front == -1 && rear == -1)
    {
        printf("\nQueue is empty\n");
        return;
    }
    if (front <= rear)
    {
        for (i = front; i <= rear; i++)
            printf("%d\n", queue[i]);
    }
    else
    {
        for (i = front; i < MAX; i++)
            printf("%d\n", queue[i]);
        for (i = 0; i <= rear; i++)
            printf("%d\n", queue[i]);
    }
}
int main()
{
    int ch;
    while (1)
    {
        printf("\n------- MENU FOR CIRCULAR QUEUE -------");
        printf("\n1.Enqueue Operation\n");
        printf("2.Dequeue Operation\n");
        printf("3.Display the Queue\n");
        printf("4.Exit\n");
        printf("Enter your choice of operations : ");
        scanf("%d", &ch);
        switch (ch)
        {
        case 1:
            enqueue();
            break;
        case 2:
            dequeue();
            break;
        case 3:
            display();
            break;
        case 4:
            exit(0);
        default:
            printf("\nIncorrect choice \n");
        }
    }
    return 0;
}
                  </code>
               </pre>
            </div>
         </div>
      </div>
      <div id="t7" class="wh">
         <h2>Deque (Double Ended Queue)</h2>
         <ul>
            <li>It is a type of queue in which insertion and deletion are allowed from both the ends.</li>
            <li>Deque supports properties of both stack and queue.
               <ul>
                  <li>stack - LIFO</li>
                  <li>queue - FIFO</li>
               </ul>
            </li>
         </ul>
         <div class="in">
            <h3>Types of Deque</h3>
            <ul>
               <li>Input restricted: Here insertion is allowed only from one end but deletion is allowed from both the
                  ends.</li>
               <li>Output restricted: Here deletion is allowed only from one end but insertion is allowed from both the
                  ends.</li>
            </ul>
         </div>
         <div class="in">
            <h3>Types of operation performed on deque</h3>
            <ol>
               <li>Insert at front</li>
               <li>Delete from front</li>
               <li>Insert at rear</li>
               <li>Delete from rear</li>
            </ol>
         </div>
         <div class="in">
            <h3>Application of deque</h3>
            <ul>
               <li>It is used to perform <b>redo</b> and <b>undo</b> operation.</li>
               <li>It can also be used as a palindrome checker.</li>
               <li>It is used in <b>multi-processor scheduling.</b></li>
            </ul>
         </div>
         <div class='code'>
            <div class='dotc'></div>
            <button class="ac">DEQUE implementation</button>
            <div class="panel">
               <pre>
                  <code>
#include &lt;stdio.h>
#include &lt;stdlib.h>
#define N 5
int deque[N];
int F = -1, R = -1;
void display();
void enqueueFront();
void enqueueRear();
void dequeueFront();
void dequeueRear();
int main()
{
   int ch;
   while (1)
   {
      printf("\n------- MENU FOR DEQUE -------");
      printf("\n1.Enqueue Front Operation\n");
      printf("2.Enqueue Rear Operation\n");
      printf("3.Dequeue  Front Operation\n");
      printf("4.Dequeue  Rear Operation\n");
      printf("5.Display the Queue\n");
      printf("6.Exit\n");
      printf("Enter your choice of operations : ");
      scanf("%d", &ch);
      switch (ch)
      {
      case 1:
         enqueueFront();
         break;
      case 2:
         enqueueRear();
         break;
      case 3:
         dequeueFront();
         break;
      case 4:
         dequeueRear();
         break;
      case 5:
         display();
         break;
      case 6:
         exit(0);
      default:
         printf("\nIncorrect choice \n");
      }
   }
   return 0;
}

void display()
{
   int i;
   if (F == -1 && R == -1)
      printf("\nQueue is empty\n");
   else
   {
      if (F <= R)
      {
         for (i = F; i <= R; i++)
            printf("%d\n", deque[i]);
      }
      else
      {
         for (i = F; i < N; i++)
            printf("%d\n", deque[i]);
         for (i = 0; i <= R; i++)
            printf("%d\n", deque[i]);
      }
   }
}

void enqueueFront()
{
   if ((F == 0 && R == N - 1) || (F == R + 1))
   {
      printf("\nDeque is Full\n");
      return;
   }
   else if (F == -1 && R == -1)
      F = R = 0;
   else if (F == 0)
      F = N - 1;
   else
      F--;
   printf("\nEnter the value you want to enter : ");
   scanf("%d", &deque[F]);
}

void enqueueRear()
{
   if ((F == 0 && R == N - 1) || (F == R + 1))
   {
      printf("\nDeque is Full\n");
      return;
   }
   else if (F == -1 && R == -1)
      F = R = 0;
   else if (R == N - 1)
      R = 0;
   else
      R++;
   printf("\nEnter the value you want to enter : ");
   scanf("%d", &deque[R]);
}

void dequeueFront()
{
   int val;
   if (F == -1 && R == -1)
   {
      printf("\nDeque is Empty\n");
      return;
   }
   else if (F == R)
   {
      val = deque[F];
      F = R = -1;
   }
   else if (F == N - 1)
   {
      val = deque[F];
      F = 0;
   }
   else
   {
      val = deque[F];
      F++;
   }
   printf("\n%d is deleted", val);
}
void dequeueRear()
{
   int val;
   if (F == -1 && R == -1)
   {
      printf("\nDeque is Empty\n");
      return;
   }
   else if (F == R)
   {
      val = deque[R];
      F = R = -1;
   }
   else if (R == 0)
   {
      val = deque[R];
      R = N - 1;
   }
   else
   {
      val = deque[R];
      R--;
   }
   printf("\n%d is deleted", val);
}
                  </code>
              </pre>
            </div>
         </div>
      </div>
      <div id="t8" class="wh">
         <h2>Priority queue</h2>
         <ul>
            <li>A <b>priority queue</b> is a type of queue that arranges elements based on their priority values.</li>
            <li>It is a type of data structure in computer science where each element has a priority assigned to it.
            </li>
            <li>The priority of an element determines the order in which it will be processed or removed from the queue.
            </li>
            <li>The element with the highest priority is processed first, followed by the next highest priority element,
               and so on.</li>
            <li>However, if elements with the same priority occur, they are served according to their order in the
               queue.</li>
         </ul>
         <div class="in">
            <h3>Types of Priority Queue:</h3>
            <ol>
               <li>Ascending Order Priority Queue:
                  <ul>
                     <li>Here the element with a lower priority value is given a higher priority in the priority list.
                     </li>
                     <li>For example, if we have the following elements in a priority queue arranged in ascending order
                        like 4,6,8,9,10. Here, 4 is the smallest number, therefore, it will get the highest priority in
                        a priority queue and so when we dequeue from this type of priority queue, 4 will remove from the
                        queue and dequeue returns 4.</li>
                  </ul>
               </li>
               <li>Descending Oder Priority Queue:
                  <ul>
                     <li>Here the element with higher priority value is given a higher priority in the priority list.
                     </li>
                  </ul>
               </li>
            </ol>
         </div>
         <div class="in">
            <h3>Difference between Priority queue and normal queue?</h3>
            <ul>
               <li>There is no priority attached to elements in a queue, the rule of first-in-first-out(FIFO) is
                  implemented whereas, in a priority queue, the elements have a priority. The elements with higher
                  priority are served first.</li>
            </ul>
         </div>
      </div>
      <div id="t9" class="wh">
         <h2>Queue implementation using linked list</h2>
         <div class='code'>
            <div class='dotc'></div>
            <button class="ac">code</button>
            <div class="panel">
               <pre>
                  <code>                  
#include &lt;stdio.h>
#include &lt;stdlib.h>
typedef struct node
{
   int data;
   struct node *next;
} node;
node *front = NULL;
node *rear = NULL;
void enqueue();
void dequeue();
void display();

int main()
{
   int choice;
   while (1)
   {
         printf("\n\n-!-!-!-!-!- MENU -!-!-!-!-!-");
         printf("\n1. Enqueue");
         printf("\n2. Dequeue");
         printf("\n3. DISPLAY");
         printf("\n4. EXIT");
         printf("\n Enter your choice : ");
         scanf("%d", &choice);
         switch (choice)
         {
         case 1:
            enqueue();
            break;
         case 2:
            dequeue();
            break;
         case 3:
            display();
            break;
         case 4:
            exit(0);
         }
   }
   return 0;
}

void enqueue()
{
   node *temp = (node *)malloc(sizeof(node));
   if (temp == NULL)
   {
         printf("\nOverflow");
         return;
   }
   printf("\nEnter a digit : ");
   scanf("%d", &temp->data);
   temp->next = NULL;
   if (front == NULL)
   {
         front = rear = temp;
   }
   else
   {
         rear->next = temp;
         rear = temp;
   }
}

void dequeue()
{
   if (front == NULL)
   {
         printf("\nUnderflow");
         return;
   }
   node *temp = front;
   if (front == rear)
   {
         front = rear = NULL;
   }
   else
   {
         front = front->next;
   }
   printf("\n%d is deleted", temp->data);
   free(temp);
}

void display()
{
   if (front == NULL)
   {
         printf("\nUnderflow");
         return;
   }
   node *temp = front;
   while (temp != NULL)
   {
         printf("%d ---> ", temp->data);
         temp = temp->next;
   }
}
                  </code>
              </pre>
            </div>
         </div>
      </div>
      <div id="t10" class="wh">
         <h2>Circular Queue implementation using linked list</h2>
         <div class='code'>
            <div class='dotc'></div>
            <button class="ac">code</button>
            <div class="panel">
               <pre>
                  <code>
#include &lt;stdio.h>
#include &lt;stdlib.h>
typedef struct node
{
      int data;
      struct node *next;
} node;
node *front = NULL;
node *rear = NULL;
void enqueue();
void dequeue();
void display();

int main()
{
      int choice;
      while (1)
      {
         printf("\n\n-!-!-!-!-!- MENU -!-!-!-!-!-");
         printf("\n1. Enqueue");
         printf("\n2. Dequeue");
         printf("\n3. DISPLAY");
         printf("\n4. EXIT");
         printf("\n Enter your choice : ");
         scanf("%d", &choice);
         switch (choice)
         {
         case 1:
            enqueue();
            break;
         case 2:
            dequeue();
            break;
         case 3:
            display();
            break;
         case 4:
            exit(0);
         }
      }
      return 0;
}

void enqueue()
{
      node *temp = (node *)malloc(sizeof(node));
      if (temp == NULL)
      {
         printf("\nOverflow");
         return;
      }
      printf("\nEnter a digit : ");
      scanf("%d", &temp->data);
      temp->next = front;
      if (front == NULL)
      {
         front = rear = temp;
      }
      else
      {
         rear->next = temp;
         rear = temp;
      }
}

void dequeue()
{
      if (front == NULL)
      {
         printf("\nUnderflow");
         return;
      }
      node *temp = front;
      if (front == rear)
      {
         free(front);
         front = rear = NULL;
      }
      else
      {
         front = front->next;
         rear->next = front;
      }
      printf("\n%d is deleted", temp->data);
      free(temp);
}

void display()
{
      if (front == NULL)
      {
         printf("\nUnderflow");
         return;
      }
      node *temp = front;
      while (temp->next != front)
      {
         printf("%d ---> ", temp->data);
         temp = temp->next;
      }
      printf("%d", temp->data);
}
                  </code>
              </pre>
            </div>
         </div>
      </div>

   </div>
   <div class="content-box">
      <p>References &darr;</p>
      <ul>
         <li><a href="https://www.digitalocean.com/community/tutorials/queue-in-c">www.digitalocean.com (Queue)</a></li>
         <li><a href="https://codeforwin.org/data-structures/queue-implementation-using-array-in-c">www.codeforwin.org
               (Queue)</a></li>
         <li><a href="https://www.youtube.com/watch?v=pqg0SOPRlJ4" target="_blank">Jenney's Lectures CS IT (Deque
               explaination)</a></li>
         <li><a href="https://www.youtube.com/watch?v=WJres9mgiAk" target="_blank">Jenney's Lectures CS IT (Deque
               implementation)</a></li>
         <li><a href="https://www.programiz.com/dsa/priority-queue">www.programiz.com (Priority queue)</a></li>
         <li><a href="https://www.geeksforgeeks.org/priority-queue-set-1-introduction/">www.geeksforgeeks.org (Priority
               Queue)</a></li>
      </ul>
   </div>
   <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
   <script src="../../../../public/main.js"></script>
</body>

</html>