<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Linked list</title>
    <link rel="stylesheet" href="../../../../public/style.css">
    <link rel="stylesheet" id="highlightStylesheet"
        href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/tomorrow-night-blue.min.css">
        <link rel="icon" href="../../../../public/logo/favicon_io/favicon.ico">
</head>

<body class="bg-c">
    <div id="mySidepanel" class="sidepanel">
        <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">Ã—</a>
        <a href="../index.html" class="home">back</a>
        <a href="#t1" class="link">Advantages of linked lists over array.</a>
        <a href="#t2" class="link">Drawbacks of linked lists</a>
        <a href="#t3" class="link">Applications of linked list</a>
        <a href="#t4" class="link">Types of linked list</a>
        <a href="#t5" class="link">Singly linked list</a>
        <a href="#t6" class="link">Doubly linked list </a>
        <a href="#t7" class="link">Garbage collection and compaction</a>
        <div class="botbut">
            <a href="../unit4_1_searching/index.html" class="link">Next Topic &rarr;</a>
            <a href="../unit2/queue.html" class="link">&larr; Previous Topic</a>
        </div>
    </div>
    <div id="navbar" class="grad">
        <div>
            <div class="openbtn" onclick="openNav()">
                <div id="nav-icon1" for="nav-menu1">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </div>
        </div>
        <div>
            <h2>Linked list</h2>
        </div>
    </div>
    <div class="content-box">
        <h1>Linked list</h1>
        <ul>
            <li>We already know about linked list in previous unit.</li>
        </ul>
        <div id="t1" class="wh">
            <h2>Advantages of Linked Lists over array:</h2>
            <ul>
                <li>Ease of insertion/deletion.</li>
                <li>Insertion at the beginning is a constant time operation and takes O(1) time, as compared to arrays
                    where inserting an element at the beginning takes O(n) time, where <i>n</i> is the number of
                    elements in the array.</li>
                <li>Linked lists are dynamic data structures. i.e., they can grow or shrink during the execution of a
                    program.</li>
                <li>Linked lists have efficient memory utilization. Here, memory is not pre-allocated. Memory is
                    allocated whenever it is required and it is de-allocated (removed) when it is no longer needed.</li>
                <li>insertion and deletion are easier and efficient. Linked lists provide flexibility in inserting a
                    data item at a specified position and deletion of the data item from the given position.</li>
                <li>Many complex applications can be easily carried out with linked lists.</li>
            </ul>
        </div>
        <div id="t2" class="wh">
            <h2>Drawbacks of linked lists:</h2>
            <ul>
                <li>Random access is not allowed. We have to access elements sequentially starting from the first node
                    (head node). So we cannot do a binary search with linked lists efficiently with its default
                    implementation.</li>
                <li>Extra memory space for a pointer is required with each element of the list.</li>
                <li>It takes a lot of time in traversing and changing the pointers.</li>
                <li>Reverse traversing is not possible in single linked lists.</li>
                <li>Searching for an element is costly and requires O(n) time complexity.</li>
                <li>Sorting of linked lists is very complex and costly.</li>
                <li>Appending an element to a linked list is a costly operation, and takes O(n) time, where <i>n</i> is
                    the number of elements in the linked list, as compared to arrays that take O(1) time.</li>
            </ul>
        </div>
        <div id="t3" class="wh">
            <h2>Applications of linked list:</h2>
            <ul>
                <li>Represent very large numbers and operations of the large number such as adiition, multiplication and
                    division.</li>
                <li>Linked lists are to implement stack, queue, trees and graphs.</li>
                <li>Implement the symbol table in compiler construction.</li>
            </ul>
        </div>
        <div id="t4" class="wh">
            <h2>Types of Linked Lists:</h2>
            <ul>
                <li><b>Singly Linked List:</b> In this type of linked list, one can move or traverse the linked list in
                    only one direction, where the next pointer of each node points to other nodes but the next pointer
                    of the last node points to NULL.</li>
                <li><b>Doubly Linked List:</b> In this type of linked list, one can traverse the linked list in both the
                    directions (forward and backward).</li>
                <li><b>Circular Linked List:</b> In this type of linked list, the last node of the linked list contains
                    the link of the first/head node of the linked list in its next pointer.</li>
                <li><b>Doubly Circular Linked List:</b> A doubly circular linked list or a circular two-way linked list
                    is a more complex type of linked list that contains a pointer to the next as well as the previous
                    node in the sequence. The difference between the doubly linked and circular doubly list is the same
                    as that between a singly linked list and a circular linked list. The circular doubly linked list
                    does not contain null in the previous field of the first node.</li>
                <li><b>Header Linked List:</b> A header linked list is a special type of linked list that contains a
                    header node at the beginning of the list.</li>
            </ul>
        </div>
        <div id="t5" class="wh">
            <h2>Singly linked list</h2>
            <p>Syntax of a node &darr;</p>
            <pre>
                <code>
struct node 
{
    int data;
    struct node *next;
};
                </code>
            </pre>
            <pre>
                <code>
struct node *start = NULL; // points to the first element. Initially NULL
                </code>
            </pre>
            <ul>
                <li>In singly linked list a <i>head</i> pointer is pointing to the first node.</li>
            </ul>
            <p>Operations on singly linked list &darr;</p>
            <ul>
                <li>insertion</li>
                <li>deletion</li>
                <li>traversing</li>
                <li>searching</li>
            </ul>
            <p>Insertion are of three types &darr;</p>
            <ul>
                <li>insertion at front</li>
                <li>insertion at last</li>
                <li>insertion in between</li>
            </ul>
            <div class='code'>
                <div class='dotc'></div>
                <button class="ac">Menu driven singly linked list program code</button>
                <div class="panel">
                    <pre>
                   <code>
#include &lt;stdio.h>
#include &lt;stdlib.h>

typedef struct node
{
    int data;
    struct node *next;
} node;
node *start = NULL;

void insertAtFront();
void insertAtBack();
void insertAfterNode();
void deleteAtFront();
void deleteAtBack();
void deleteANode();
void display();

int main()
{
    int choice;
    while (1)
    {
        printf("\n------- MENU ---------");
        printf("\n1. Insert at front");
        printf("\n2. Insert at back");
        printf("\n3. Insert after a node");
        printf("\n4. Delete at front");
        printf("\n5. Delete at back");
        printf("\n6. Delete a node");
        printf("\n7. Display");
        printf("\n8. Exit");
        printf("\nEnter you choice : ");
        scanf("%d", &choice);
        switch (choice)
        {
        case 1:
            insertAtFront();
            break;
        case 2:
            insertAtBack();
            break;
        case 3:
            insertAfterNode();
            break;
        case 4:
            deleteAtFront();
            break;
        case 5:
            deleteAtBack();
            break;
        case 6:
            deleteANode();
            break;
        case 7:
            display();
            break;
        case 8:
            exit(0);
        default:
            printf("\nEnter a correct choice");
        }
    }
    return 0;
}
void insertAtFront()
{
    node *newnode = (node *)malloc(sizeof(node));
    printf("Enter a value : ");
    scanf("%d", &newnode->data);
    newnode->next = start;
    start = newnode;
}

void insertAtBack()
{
    node *newnode = (node *)malloc(sizeof(node));
    node *last = start;
    printf("Enter a value : ");
    scanf("%d", &newnode->data);
    newnode->next = NULL;
    if (start == NULL)
        start = newnode;
    else
    {
        while (last->next != NULL)
            last = last->next;
        last->next = newnode;
    }
}

void insertAfterNode()
{
    if (start == NULL)
    {
        printf("\nList is empty cannot insert after a node\n");
        return;
    }
    int node_val;
    printf("\nEnter a node value after which you want to insert : ");
    scanf("%d", &node_val);
    node *ptr = start;
    while (ptr->data != node_val)
    {
        if (ptr->next == NULL)
        {
            printf("\n Node not found cannot insert element");
            return;
        }
        ptr = ptr->next;
    }
    node *newNode = (node *)malloc(sizeof(node));
    newNode->next = NULL;
    printf("\nEnter the value : ");
    scanf("%d", &newNode->data);
    newNode->next = ptr->next;
    ptr->next = newNode;
}

void deleteAtFront()
{
    if (start == NULL)
    {
        printf("\nList is empty");
        return;
    }
    node *temp = start;
    start = start->next;
    free(temp);
}

void deleteAtBack()
{
    if (start == NULL)
    {
        printf("\nList is empty");
        return;
    }
    if (start->next == NULL)
    {
        free(start);
        start = NULL;
        return;
    }
    node *temp = start;
    while (temp->next->next != NULL)
        temp = temp->next;
    free(temp->next);
    temp->next = NULL;
}

void deleteANode()
{
    if (start == NULL)
    {
        printf("\nList is empty");
        return;
    }
    int search;
    printf("Enter a value you want to delete : ");
    scanf("%d", &search);
    node *temp = start;
    while (temp->data != search)
    {
        if (temp->next == NULL)
        {
            printf("\nValue not found");
            return;
        }
        temp = temp->next;
    }
    if (temp == start)
        deleteAtFront();
    else if (temp->next == NULL)
        deleteAtBack();
    else
    {
        node *prev = start;
        while (prev->next != temp)
            prev = prev->next;
        prev->next = temp->next;
        free(temp);
    }
}

void display()
{
    if (start == NULL)
    {
        printf("\nList is empty");
        return;
    }
    node *newnode = start;
    while (newnode != NULL)
    {
        printf("%d --> ", newnode->data);
        newnode = newnode->next;
    }
}
                   </code>
               </pre>
                </div>
            </div>
            <div class="in">
                <h3>Circular Single Linked List</h3>
                <ul>
                    <li>It is just a single linked list in which the link field of the last node points back to the
                        address of the first node.</li>
                    <li>A circular linked list has no beginning and no end. It is necessary to establish a special
                        pointer called <i>start</i> &nbsp;pointer always pointing to the first node of the list.</li>
                    <li>Circular linked lists are frequently used instead of ordinary linked list because many
                        operations are much easier to implement.</li>
                    <li>In circular linked list no null pointer are used, hence all pointers contain valid address.</li>
                </ul>
                <div class="code">
                    <div class="dotc"></div>
                    <button class="ac">Circular single linked list MENU driven program code</button>
                    <div class="panel">
                        <pre>
                            <code>
#include &lt;stdio.h>
#include &lt;stdlib.h>
typedef struct node
{
    int data;
    struct node *next;
} node;
node *start = NULL;

void insertAtFront();
void insertAtBack();
void insertAfterNode();
void deleteAtFront();
void deleteAtBack();
void deleteNode();
void display();

int main()
{
    int choice;
    while (1)
    {
        printf("\n------- MENU Circular single linked list ---------");
        printf("\n1. Insert at front");
        printf("\n2. Insert at back");
        printf("\n3. Insert after a node");
        printf("\n4. Delete at front");
        printf("\n5. Delete at back");
        printf("\n6. Delete a node");
        printf("\n7. Display");
        printf("\n8. Exit");
        printf("\nEnter you choice : ");
        scanf("%d", &choice);
        switch (choice)
        {
        case 1:
            insertAtFront();
            break;
        case 2:
            insertAtBack();
            break;
        case 3:
            insertAfterNode();
            break;
        case 4:
            deleteAtFront();
            break;
        case 5:
            deleteAtBack();
            break;
        case 6:
            deleteNode();
            break;
        case 7:
            display();
            break;
        case 8:
            exit(0);
        default:
            printf("\nEnter a correct choice");
        }
    }
    return 0;
}
void insertAtFront()
{
    node *newNode = (node *)malloc(sizeof(node));
    printf("Enter a value : ");
    scanf("%d", &newNode->data);
    if (start == NULL)
    {
        start = newNode;
        newNode->next = start;
    }
    else
    {
        newNode->next = start;
        start = newNode;
    }
}

void insertAtBack()
{
    node *newNode = (node *)malloc(sizeof(node));
    node *last = start;
    printf("Enter a value : ");
    scanf("%d", &newNode->data);
    newNode->next = NULL;
    if (start == NULL)
    {
        start = newNode;
        newNode->next = start;
    }
    else
    {
        while (last->next != start)
            last = last->next;
        last->next = newNode;
        newNode->next = start;
    }
}

void insertAfterNode()
{
    if (start == NULL)
    {
        printf("\nlist is empty, cannot insert after a node\n");
        return;
    }
    int node_val;
    printf("\nEnter a node value after which you want to insert : ");
    scanf("%d", &node_val);
    node *temp = start;
    while (temp->data != node_val)
    {
        if (temp->next == NULL)
        {
            printf("\nValue not found");
            return;
        }
        temp = temp->next;
    }
    node *newNode = (node *)malloc(sizeof(node));
    newNode->next = NULL;
    printf("\nEnter the value : ");
    scanf("%d", &newNode->data);
    newNode->next = temp->next;
    temp->next = newNode;
}

void deleteAtFront()
{
    if (start == NULL)
    {
        printf("\nNo node exist");
        return;
    }
    if (start->next == start) // there is only one element
    {
        free(start);
        start = NULL;
        return;
    }
    node *last = start, *temp = start;
    while (last->next != start)
        last = last->next;
    start = start->next;
    last->next = start;
    free(temp);
}

void deleteAtBack()
{
    if (start == NULL)
    {
        printf("\nNo node exist");
        return;
    }
    if (start->next == start) // only one element left
    {
        free(start);
        start = NULL;
        return;
    }
    node *temp = start;
    while (temp->next->next != start)
    {
        temp = temp->next;
    }
    free(temp->next);
    temp->next = start;
}

void deleteNode()
{
    if (start == NULL)
    {
        printf("\nNo node exist");
        return;
    }
    int search;
    printf("Enter a value you want to delete : ");
    scanf("%d", &search);
    node *temp = start;
    while (temp->data != search)
    {
        temp = temp->next;
        if (temp->next == NULL)
        {
            printf("\nValue not found");
            return;
        }
    }
    if (temp == start)
        deleteAtFront();
    else if (temp->next == start)
        deleteAtBack();
    else
    {
        node *prev = start;
        while (prev->next != temp)
        {
            prev = prev->next;
        }
        prev->next = temp->next;
    }
}

void display()
{
    if (start == NULL)
    {
        printf("\nEmpty list");
        return;
    }
    node *newNode = start;
    while (newNode->next != start)
    {
        printf("%d --> ", newNode->data);
        newNode = newNode->next;
    }
    printf("%d --> ", newNode->data);
}
                            </code>
                        </pre>
                    </div>
                </div>
            </div>
        </div>
        <div id="t6" class="wh">
            <h2>Doubly Linked List:</h2>
            <ul>
                <li>A doubly linked list is a two-way list in which all have two links. This helps in accessing both
                    successor node and predecessor node from the given node position.</li>
                <li>It provides bi-directional traversing. Each node contains three fields:
                    <ol>
                        <li>Left link (prev)</li>
                        <li>Data</li>
                        <li>Right link (next)</li>
                    </ol>
                </li>
                <li>The left link points to the predecessor node and the righ link points to the successor node. The
                    data field stores the required data.</li>
                <li>Many application requires searching forward and backward thru nodes of a list. For example searching
                    for a name in telephone directory would need forward and backward scanning thru a region of the
                    whole list.</li>
                <li>The basic operations in a double linked list are:
                    <ul>
                        <li>Creation</li>
                        <li>Insertion</li>
                        <li>Deletion</li>
                        <li>Traversing</li>
                    </ul>
                </li>
                <li>The beginning of the double linked list is stored in a "<b>start</b>" pointer which points to the
                    first node. The first node's left link and last node's right link is set to NULL.</li>
                <li>The following code gives the structure definition:
                    <pre>
                        <code>
struct node
{
    struct node *prev;
    int data;
    struct node *next;
};
struct node *start = NULL;
                        </code>
                    </pre>
                </li>
            </ul>
            <img src="../../images/doublell1.svg" alt="" class="wb">
            <div class='code'>
                <div class='dotc'></div>
                <button class="ac">Doubly linked list MENU driven program code</button>
                <div class="panel">
                    <pre>
                    <code>
#include &lt;stdio.h>
#include &lt;stdlib.h>
typedef struct node
{
    struct node *prev;
    int data;
    struct node *next;
} node;
node *start = NULL;
void insert_front(int val)
{
    node *newNode = (node *)malloc(sizeof(node));
    newNode->data = val;
    newNode->prev = NULL;
    newNode->next = NULL;
    if (start == NULL)
    {
        start = newNode;
    }
    else
    {
        newNode->next = start;
        start->prev = newNode;
        start = newNode;
    }
}
void insert_last(int val)
{
    node *newNode = (node *)malloc(sizeof(node));
    newNode->next = NULL;
    newNode->prev = NULL;
    newNode->data = val;

    if (start == NULL)
    {
        start = newNode;
    }
    else
    {
        node *ptr = start;
        while (ptr->next != NULL)
        {
            ptr = ptr->next;
        }
        newNode->prev = ptr;
        ptr->next = newNode;
    }
}
void insertAfterANode()
{
    if (start == NULL)
    {
        printf("\nList is empty, cannot insert a node");
        return;
    }
    int ele;
    printf("Enter the element after which you insert new element : ");
    scanf("%d", &ele);
    node *ptr = start;
    while (ptr->data != ele)
    {
        if (ptr->next == NULL)
        {
            printf("\n Element not found, cannot insert element");
            return;
        }
        ptr = ptr->next;
    }
    node *newNode = (node *)malloc(sizeof(node));
    newNode->next = NULL;
    newNode->prev = NULL;
    printf("Enter the node value : ");
    scanf("%d", &newNode->data);
    if (ptr == start)
    {
        newNode->prev = start;
        start->next = newNode;
    }
    else if (ptr->next == NULL)
    {
        ptr->next = newNode;
        newNode->prev = ptr;
    }
    else
    {
        newNode->next = ptr->next;
        newNode->prev = ptr;
        ptr->next->prev = newNode;
        ptr->next = newNode;
    }
}
void delete_front()
{
    if (start == NULL)
    {
        printf("\t\tUnderflow");
        return;
    }
    if (start->next == NULL)
        start = NULL;
    else
    {
        node *ptr = start;
        start = start->next;
        ptr->next = NULL;
        start->prev = NULL;
        free(ptr);
    }
}
void delete_last()
{

    if (start == NULL)
    {
        printf("\t\tUnderflow");
        return;
    }
    node *ptr = start;
    while (ptr->next != NULL)
    {
        ptr = ptr->next;
    }
    if (ptr->prev == NULL)
        start = NULL;
    else
    {
        ptr->prev->next = NULL;
        ptr->prev = NULL;
        free(ptr);
    }
}
void deleteNode()
{
    if (start == NULL)
    {
        printf("\t\tList is empty");
        return;
    }
    int ele;
    printf("Enter the element you want to delete : ");
    scanf("%d", &ele);
    node *ptr = start;
    while (ptr->data != ele)
    {
        if (ptr->next == NULL)
        {
            printf("\nElement not found");
            return;
        }
        ptr = ptr->next;
    }
    if (ptr == start)
    {
        delete_front();
    }
    else if (ptr->next == NULL)
    {
        delete_last();
    }
    else
    {
        ptr->next->prev = ptr->prev;
        ptr->prev->next = ptr->next;
        free(ptr);
    }
}
void display()
{

    if (start == NULL)
    {

        printf("\t\tUnderflow");
    }
    else
    {
        node *ptr = start;
        while (ptr != NULL)
        {
            printf("\t%d<=>", ptr->data);
            ptr = ptr->next;
        }
    }
}
int main()
{
    int ch, val, ele;
    while (1)
    {
        printf("\n1.insert in began\n2.insert in end\n3.insert after node");
        printf("\n4.Delete in front\n5.Delete in last\n6.Delete a node");
        printf("\n7.Display\n8.Exit\n");
        printf("Enter your choice : ");
        scanf("%d", &ch);

        switch (ch)
        {
        case 1:
        {
            printf("Enter the  data value : ");
            scanf("%d", &val);
            insert_front(val);
            break;
        }
        case 2:
        {
            printf("Enter the data value : ");
            scanf("%d", &val);
            insert_last(val);
            break;
        }

        case 3:
        {
            insertAfterANode();
            break;
        }

        case 4:
            delete_front();
            break;

        case 5:
            delete_last();
            break;

        case 6:
            deleteNode();
            break;

        case 7:
            display();
            break;

        case 8:
            exit(0);

        default:
            printf("Wrong input mate !!");
            break;
        }
    }
    return 0;
}
                    </code>
                </pre>
                </div>
            </div>

            <div class="in">
                <h3>Circular Double Linked List</h3>
                <ul>
                    <li>A circular double linked list has both sucessor and predecessor pointer in circular manner. The
                        object behind considering circular double linked list is to simplify the insertion and deletion
                        operations performed on double linked list.</li>
                    <li>In circular double linked list the right link of the right most node points back to the start
                        node and left link of the first node points to the last node.</li>
                </ul>
            </div>
        </div>
        <div id="t7" class="wh">
            <h2>Garbage collection and Compaction</h2>
            <div class="in">
                <h3>Garbage collection</h3>
                <ul>
                    <li>Garbage collection is the process of automatically reclaiming memory that is no longer in use by
                        the program.</li>
                    <li>In the context of linked lists, garbage collection involves identifying and deallocating unused
                        nodes.</li>
                    <li>Node becomes unused when they are no longer reachable from the list's head node.</li>
                    <li>Garbage collection ensures efficient memory utilization and prevents memory leaks.</li>
                    <li><b>Mark and Sweep algorithm:</b> It is a common technique used for garbage collection in linked
                        lists.
                        <ul>
                            <li>This algorithm consists of two phases: marking and sweeping.</li>
                            <li>In the marking phase, the algorithm traverses the linked list from the head node and
                                marks all reachable nodes.</li>
                            <li>Marking can be done by setting a flag or modifying a field in each node.</li>
                            <li>In the sweeping phase, the algorithm traverses the linked list again and deallocates all
                                unmarked nodes.</li>
                            <li>The memory occupied by unmarked nodes is returned to the system for reuse.</li>
                        </ul>
                    </li>
                </ul>
                <div class="wh">
                    <p>Using free to deallocate the unnecessary nodes</p>
                    <ul>
                        <li>After marking the reachable nodes during the mark phase of the mark and sweep algorithm, you
                            need to deallocate the memory for the unmarked nodes.Traverse the linked list and for each
                            unmarked node, use free() to release the memory occupied by that node.</li>
                        <li>For example &darr;</li>
                    </ul>
                    <div class="npanel">
                    <pre>
                           <code>
// Assuming a linked list node structure like:
struct Node {
    int data;
    struct Node* next;
};

// During garbage collection, deallocate unmarked nodes
struct Node* current = head;
while (current != NULL) {
    struct Node* nextNode = current->next;
    if (!current->marked) {
        free(current);  // Deallocate memory for unmarked node
    }
    current = nextNode;
}

                           </code>
                       </pre>
                    </div>
                </div>
            </div>
            <div class="in">
                <h3>Compaction</h3>
                <ul>
                    <li>Compaction is an optimization technique that aims to reduce memory fragmentation in a linked
                        list.</li>
                    <li>Memory fragmentation occurs when free memory blocks are scattered throughout the memory space.
                    </li>
                    <li>Compaction rearranges the nodes in memory to eliminate fragmentation and create a contiguous
                        block of free memory.</li>
                    <li>The compaction process involves iterating over the linked list, moving the nodes closer
                        together, and updating the pointers accordingly.</li>
                    <li>After compaction, the linked list occupies a compact memory space, which improves memory
                        utilization and reduces memory allocation overhead.</li>
                </ul>
                <div class="wh">
                    <p>Using free() in Compaction</p>
                    <ul>
                        <li>During the compaction process, you rearrange the nodes to eliminate memory fragmentation and
                            create a contiguous block of free memory.</li>
                        <li>As you move nodes, you will have "gaps" or unused memory spaces left behind.</li>
                        <li>To reclaim this unused memory, you can use free() to deallocate those gaps.</li>
                        <li>For example &darr;</li>
                    </ul>
                    <div class="npanel">
                    <pre>
                        <code>
// Assuming a linked list node structure like:
struct Node {
    int data;
    struct Node* next;
};

// Perform compaction and deallocate gaps
struct Node* current = head;
struct Node* prev = NULL;
while (current != NULL) {
    // Move the node to its new position
    // ...

    // Deallocate the gap between prev and current
    if (prev != NULL && prev->next != current) {
        struct Node* gap = prev->next;
        prev->next = current;
        free(gap);  // Deallocate memory for the gap
    }

    prev = current;
    current = current->next;
}

                        </code>
                    </pre>
                </div>
                </div>
            </div>
        </div>
    </div>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script src="../../../../public/main.js"></script>
</body>

</html>