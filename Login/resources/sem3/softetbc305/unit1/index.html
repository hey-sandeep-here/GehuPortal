<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Introduction</title>
    <link rel="stylesheet" href="../../../../public/style.css">
    <link rel="icon" href="../../../../public/logo/favicon_io/favicon.ico">
</head>

<body class="bg-c">
    <div id="mySidepanel" class="sidepanel">
        <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">×</a>
        <a href="../index.html" class="home">back</a>
        <a href="#t1" class="link">Need of S/w Engineering</a>
        <a href="#t2" class="link">Importance of software engineering</a>
        <a href="#t3" class="link">Evolving role of software</a>
        <a href="#t4" class="link">Software components</a>
        <a href="#t5" class="link">Characteristics of software</a>
        <a href="#t6" class="link">Software Application Domain</a>
        <a href="#t7" class="link">Software Crisis</a>
        <a href="#t8" class="link">Software Engineering Problems</a>
        <a href="#t9" class="link">SDLC</a>
        <a href="#tpyq" class="link">Previous Year Questions</a>
        <div class="botbut">
            <a href="../unit2/index.html" class="link">Next Topic &rarr;</a>
        </div>
    </div>
    <div id="navbar" class="grad">
        <div>
            <div class="openbtn" onclick="openNav()">
                <div id="nav-icon1" for="nav-menu1">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </div>
        </div>
        <div>
            <h2>Introduction</h2>
        </div>
    </div>
    <div class="content-box">
        <h1>Introduction</h1>
        <p><b>Software + Engineering</b></p>
        <ul>
            <li>S/w is considered to be a collection of executable programming code, associated libraries &
                documentation.</li>
            <li>Engineering is all about developing products, using well defined, scientific principles and methods.
            </li>
            <li><b>Definition &rarr; </b> "S/w engineering can be defined as an engineering branch associated with the
                development of s/w production of s/w products using well-defined scientific principles, methods and
                procedures."
                <ul>
                    <li>Note &rarr; The outcome of s/w engg is s/w product (when s/w is made for specific purposes it is
                        known as s/w product). </li>
                </ul>
            </li>
            <li><b>IEEE definition of S/w Engineering : </b> The application of systematic development, quantifiable
                approach to the development operation and maintenance of s/w. i.e. applications of engineering to the
                s/w development.
                <ul>
                    <li>IEEE provides different standards.</li>
                </ul>
            </li>
        </ul>
        <div id="t1" class="wh">
            <h2>Need of S/w Engineering</h2>
            <ul>
                <li><b>Dynamic nature &rarr; </b> Rapid change in user requirement.
                    <ul>
                        <li>If the user needs some additional features so that should be added time to time. These
                            changes can be accomplished using s/w engineering.</li>
                    </ul>
                </li>
                <li><b>Cost &rarr; </b> Cost management is performed by different means.</li>
                <li><b>Quality management &rarr; </b> By providing better processes.</li>
                <li><b>Scalability &rarr; </b>Able to incorporate new changes.</li>
            </ul>
        </div>
        <div id="t2" class="wh">
            <h2>Importance of software engineering</h2>
            <p>Software engineering is important for the following reasons:</p>
            <ol>
                <li>More and more, individuals and society rely on advanced software systems. We need to produce
                    reliable and trustworthy systems economically and quickly. </li>
                <li>It is usually cheaper, in the long run. The systematic approach that is used in software engineering
                    is sometimes called a software process. A software process is a sequence of activities that leads to
                    the production of a software product. </li>
                <li>The economies of ALL developed nations are dependent on software. </li>
                <li>More and more systems are software controlled (transportation, medical, telecommunications,
                    military, industrial, entertainment, etc…) </li>
                <li>Business and society are changing incredibly quickly as emerging economies develop and new
                    technologies become available. Traditional business techniques are time consuming and delivery of
                    product often takes longer than planned. </li>
            </ol>
        </div>
        <div id="t3" class="wh">
            <h2>Evolving role of software</h2>
            <p>Software has undergone a transformative evolution, taking on a dual role as both a product and a delivery
                mechanism. It plays a pivotal role in shaping our technological landscape, offering diverse capabilities
                and serving various purposes.</p>
            <ul>
                <li><b>Software as a product:</b>
                    <ul>
                        <li>Software now functions as a product in its own right, delivering computational capabilities
                            either through individual computer hardware or interconnected networks of computers.</li>
                        <li>Whether embedded within smartphones or operating within powerful mainframe computers,
                            software acts as an information transformer.</li>
                        <li>It facilitates the production, management, modification, acquisition, display, and
                            transmission of information, ranging from single bits to complex multimedia presentations.
                        </li>
                    </ul>
                </li>
                <li><b>software as a delivery vehicle:</b>
                    <ul>
                        <li>Beyond its identity as a product, software serves as the foundation for delivering and
                            controlling other products.</li>
                        <li>It assumes roles such as computer control (operating systems), information communication
                            (networks), and program creation and management (software tools and environments).</li>
                        <li>Software empowers the transformation of personal data, making it more useful, while also
                            managing business information to enhance competitiveness.</li>
                        <li>It acts as a gateway to global information networks like the Internet and provides the means
                            for acquiring information.</li>
                    </ul>
                </li>
                <li><b>Role Evolution Over Two Decades:</b>
                    <ul>
                        <li>Over the past two decades, the role of computer software has undergone significant
                            transformation, propelled by technological advancements.</li>
                        <li>Hardware performance has experienced remarkable improvements, allowing for more
                            sophisticated and intricate computer-based systems.</li>
                        <li>Computing architectures have undergone profound changes, adapting to evolving demands and
                            challenges.</li>
                        <li>Memory and storage capacities have grown substantially, enabling the handling of
                            increasingly complex data.</li>
                        <li>Diverse input and output options have expanded, enhancing user interactions with
                            software-driven systems.</li>
                    </ul>
                </li>
            </ul>
            <p>This evolving role of software reflects its critical influence on various aspects of our lives. From
                enabling communication and data management to providing access to global information networks, software
                has become an indispensable part of modern society. The synergy between hardware advancements and
                software innovation has paved the way for intricate, efficient, and multifaceted computer-based systems
                that define our current technological landscape.</p>
        </div>
        <div id="t4" class="wh">
            <h2>Software components</h2>
            <ul>
                <li>There are majorly three software components:
                    <ol>
                        <li>Program</li>
                        <li>Software document</li>
                        <li>Operating procedure</li>
                    </ol>
                </li>
            </ul>
            <div class="in">
                <h3>Program</h3>
                <ul>
                    <li>Program is collection of instruction code in which there will be source code and object code.
                    </li>
                </ul>
            </div>
            <div class="in">
                <h3>S/w document</h3>
                <ul>
                    <li>As software development is multi-phase process, so after completing all the phases a document is
                        created.</li>
                    <li>For each phases we have to create a separate software document. Some of the phases document are
                        mentioned below.</li>
                    <li>SRS (Software Requirement Specification) document: A comprehensive document that outlines the
                        detailed requirements and specifications for the software project. It provides a clear
                        description of the software's functionalities, constraints, user interactions, and system
                        behavior.".</li>
                    <li>Design document: Based on the software requirements, a document outlining the design of the
                        software will be created. This document will include the architecture of the software, providing
                        guidance for its development.</li>
                    <li>Coding document: A coding document, also known as a source code document, is a record that
                        documents the code implementation of a software project. It includes the code logic, algorithms,
                        functions, classes, and any other code-related components. This document serves as a reference
                        for developers, making it easier to understand and maintain the codebase. It might also include
                        comments explaining the code's purpose, usage, and potential complexities. </li>
                    <li>Test document: A test document, also called a testing plan or test specification, outlines the
                        strategies and procedures for testing a software application. It includes details about the
                        various types of tests to be conducted, such as unit testing, integration testing, and system
                        testing. The document specifies test cases, expected outcomes, testing environments, and
                        criteria for passing or failing tests. A comprehensive test document helps ensure the quality
                        and reliability of the software by providing a structured approach to testing its
                        functionalities and identifying potential issues.</li>
                </ul>
                <p>If in future the developer team changes then they can easily refer to these documents and understand
                    the software that they want to build.</p>
            </div>
            <div class="in">
                <h3>Operating procedure</h3>
                <ul>
                    <li>After the software has been developed, it is essential for the developer to provide instructions
                        to the user on its usage. This is where the operating procedure comes into play.</li>
                    <li>Operating procedure is divided into two parts:
                        <ol>
                            <li>User Manual: This manual guides users on how to effectively utilize the software,
                                providing step-by-step instructions for various features and functions.</li>
                            <li>Operational Manual: This manual specifies the technical characteristics of the software,
                                including details such as supported devices, operating systems, versions, and other
                                relevant technical information.</li>
                        </ol>
                    </li>
                </ul>
            </div>
        </div>
        <div id="t5" class="wh">
            <h2>Characteristics of Software</h2>
            <div class="in">
                <h3>Operational Characteristics: How well the software works in operation</h3>
                <ul>
                    <li><strong>Usability:</strong> This refers to how easily and effectively users can interact with
                        the software. It includes intuitive user interfaces, clear instructions, and a pleasant user
                        experience.</li>
                    <li><strong>Correctness:</strong> Software correctness implies that the software produces accurate
                        and expected results under various conditions. It involves thorough testing and validation to
                        ensure the absence of errors and bugs.</li>
                    <li><strong>Functionality:</strong> The software's functionality encompasses its intended features
                        and capabilities. It should satisfy user requirements and perform tasks according to
                        specifications.</li>
                    <li><strong>Efficiency:</strong> Efficient software executes tasks in a timely manner while making
                        optimal use of system resources such as memory and processing power.</li>
                    <li><strong>Dependability:</strong> Dependable software is reliable and consistent in its behavior.
                        It can be trusted to perform as expected without unexpected failures or crashes.</li>
                    <li><strong>Safety and Security:</strong> Software safety ensures that it doesn't cause harm or
                        endanger users. Security involves protecting data from unauthorized access, ensuring the
                        software's resistance to breaches.</li>
                </ul>
            </div>
            <div class="in">
                <h3>Transitional Characteristics: Accommodating Platform Changes</h3>
                <ul>
                    <li><strong>Portability:</strong> Portable software can be smoothly transferred or adapted to
                        different environments or platforms without significant modifications.</li>
                    <li><strong>Reusability:</strong> Reusable components within the software allow for efficient
                        development by using existing solutions, reducing redundancy, and saving time and effort.</li>
                    <li><strong>Adaptability:</strong> Adaptable software can be adjusted to accommodate changes in
                        requirements, technological advancements, or new features without disrupting its overall
                        functionality.</li>
                </ul>
            </div>
            <div class="in">
                <h3>Maintenance Characteristics: How software adapts to changing environments</h3>
                <ul>
                    <li><strong>Scalability:</strong> Scalable software can handle an increasing amount of work, users,
                        or data. It can be expanded to support growth without significant degradation of performance.
                    </li>
                    <li><strong>Flexibility:</strong> Flexible software can be modified or extended to meet changing
                        needs. It can incorporate new features or adapt to evolving business requirements.</li>
                    <li><strong>Maintainability:</strong> Maintainable software is designed and structured in a way that
                        facilitates easy updates, bug fixes, and enhancements over its lifecycle. This reduces
                        maintenance costs and effort.</li>
                </ul>
            </div>
        </div>
        <div id="t6" class="wh">
            <h2>Software Application Domain</h2>
            <div class="in">
                <h3>System Software</h3>
                <ul>
                    <li>System software directly interacts with hardware and the underlying system infrastructure.</li>
                    <li>It provides fundamental functionalities essential for the operation of a computer system.</li>
                    <li>Examples include text editors, web browsers, operating systems (OS), compilers, and hardware
                        drivers.</li>
                </ul>
            </div>
            <div class="in">
                <h3>Application Software</h3>
                <ul>
                    <li>Application software is designed to provide specific functionalities to users, addressing their
                        needs and requirements.</li>
                    <li>Examples encompass familiar applications like messaging apps (WhatsApp), social media platforms
                        (Facebook), and antivirus software.</li>
                </ul>
            </div>
            <div class="in">
                <h3>Engineering or Scientific Software</h3>
                <ul>
                    <li>This type of software caters to specialized fields such as engineering and scientific research.
                    </li>
                    <li>It includes software tools used for aeronautical engineering, simulations, modeling, and data
                        analysis.</li>
                </ul>
            </div>
            <div class="in">
                <h3>Embedded Software</h3>
                <ul>
                    <li>Embedded software is directly integrated into hardware devices, enhancing their functionality
                        and capabilities.</li>
                    <li>Examples range from air conditioners (AC) and speedometers in vehicles to consumer electronics.
                    </li>
                </ul>
            </div>
            <div class="in">
                <h3>Web Applications</h3>
                <ul>
                    <li>Web applications are accessible via web browsers and offer a wide range of functionalities and
                        services.</li>
                    <li>They include browser-based apps, email services like Gmail, social media platforms, and online
                        banking applications.</li>
                </ul>
            </div>
            <div class="in">
                <h3>AI Software</h3>
                <ul>
                    <li>AI (Artificial Intelligence) software is used in applications that involve pattern recognition,
                        machine learning, and robotics.</li>
                    <li>These software tools play a crucial role in fields like data analysis, automation, and
                        decision-making.</li>
                </ul>
            </div>
        </div>
        <div id="t7" class="wh">
            <h3>Software Crisis</h3>
            <ul>
                <li>The term "Software Crisis" in computer science describes the difficulties faced when making useful
                    and efficient computer programs within a set time.</li>
                <li>The software crisis happened because we kept using the same workforce, methods, and tools even as
                    the need for software grew quickly. This made software more complex and challenging.</li>
                <li>As software became more complicated, many problems came up because the ways we used before weren't
                    good enough.</li>
                <li>However, if we keep using the same workforce, methods, and tools when the demand for software grows
                    fast and software becomes more complex, there can be problems. These include issues like not having
                    enough money for software, not making software efficiently, software not being very good in quality,
                    trouble managing and delivering software, and more. This situation is called a "software crisis."
                </li>
            </ul>
            <div class="in">
                <h3>Causes of Software Crisis:</h3>
                <ul>
                    <li>The cost of owning and maintaining software became as expensive as developing it initially.</li>
                    <li>Many projects were running beyond their scheduled time.</li>
                    <li>Software from that time was inefficient and not very effective.</li>
                    <li>The quality of the software was poor, leading to unsatisfactory performance.</li>
                    <li>Software often failed to meet the requirements of users.</li>
                    <li>The average software project took longer than expected, usually exceeding its planned schedule
                        by around half.</li>
                    <li>Delivery of software was often delayed or never happened.</li>
                    <li>Resource utilization wasn't optimized, leading to wastage.</li>
                    <li>It was hard to make changes, fix issues, and improve software efficiently.</li>
                    <li>The complexity of software made it difficult to modify.</li>
                </ul>
            </div>
            <div class="in">
                <h3>Factors Contributing to the Software Crisis:</h3>
                <ul>
                    <li>Poor project management practices.</li>
                    <li>Inadequate training in software engineering, leading to a lack of necessary skills.</li>
                    <li>Project teams had members with limited skills and expertise.</li>
                    <li>There were only minor improvements in productivity, which impacted software development
                        efficiency.</li>
                </ul>
            </div>
            <div class="in">
                <h3>Solution of Software Crisis:</h3>
                <p>There is no single solution to the crisis. One possible solution to a software crisis is Software
                    Engineering because software engineering is a systematic, disciplined, and quantifiable approach.
                </p>

                <h3>Guidelines for Preventing Software Crisis:</h3>
                <ul>
                    <li>Reduction in software over budget.</li>
                    <li>The quality of software must be high.</li>
                    <li>Less time is needed for a software project.</li>
                    <li>Experienced and skilled people working over the software project.</li>
                    <li>Software must be delivered.</li>
                    <li>Software must meet user requirements.</li>
                </ul>
            </div>
        </div>
        <div id="t8" class="wh">
            <h2>Software Engineering Problems</h2>
            <div class="in">
                <h3>Rapid Technology Advancement</h3>
                <ul>
                    <li>Technology advancement is a blessing for the IT industry. However, it creates pressure on
                        software
                        developers to incorporate new technology features into software.</li>
                </ul>
                <h3>Increasing Customer Demands</h3>
                <ul>
                    <li>Customer demands may change over time, leading software developers to modify the software's
                        current
                        status. This can affect deadlines and the cost of software development.</li>
                </ul>
                <h3>Time Limitations</h3>
                <ul>
                    <li>Software developers often work under pressured environments and need to meet project
                        requirements
                        within strict timelines, especially when working with international clients across different
                        time-zones.</li>
                </ul>
                <h3>Limited Infrastructure/Resources</h3>
                <ul>
                    <li>The lack of resources or IT infrastructure affects software quality. For instance, the absence
                        of
                        high-performance development tools, powerful computing machines, and efficient data storage
                        architectures can impact productivity and performance.</li>
                </ul>
                <h3>Conflicts with Software Testing Teams</h3>
                <ul>
                    <li>Interpersonal conflicts can arise between teams in a software development project due to factors
                        like performance pressure, different mindsets, and varied job roles. Unmanaged conflicts can
                        adversely affect the project.</li>
                </ul>
                <h3>Understanding Large and Complex System Requirements is Difficult</h3>
                <ul>
                    <li>Large system requirements may involve security constraints due to numerous users and a
                        substantial
                        number of functions to be implemented.</li>
                    <li>Undefined system boundaries can lead to unnecessary functions, affecting implementation costs
                        and
                        budget.</li>
                </ul>
                <h3>Customers/Stakeholders are Not Clear About Their Needs</h3>
                <ul>
                    <li>Customers might be uncertain about the functionalities they want in the software.</li>
                    <li>Changing requirements, based on successive interviews or reviews, can complicate the development
                        process.</li>
                    <li>Note: Software stakeholders are individuals, groups, or entities that have an interest, role, or
                        involvement in the development and deployment of software. These stakeholders play a crucial
                        role in influencing the software's design, functionality, and success. They contribute to
                        various aspects of the software development lifecycle and have a vested interest in the
                        software's outcomes.
                        <ul>
                            <li>Types of Software Stakeholders:
                                <ul>
                                    <li>Users: The end-users or customers who will interact with and use the software.
                                        Their needs, preferences, and feedback are vital to ensure the software aligns
                                        with their requirements.</li>
                                    <li>Clients/Customer Representatives: These individuals represent the interests and
                                        requirements of the organization or entity that's commissioning the software.
                                        They provide insights into the organization's needs and expectations.</li>
                                    <li>Developers/Development Team: The individuals responsible for designing, coding,
                                        and testing the software. They work to translate stakeholder requirements into a
                                        functional product.</li>
                                    <li>Product Managers: Responsible for overseeing the software's development and
                                        ensuring that it aligns with the organization's goals and market needs. And so
                                        on.</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                </ul>
            </div>
            <div class="in">
                <h3>Solutions to Overcome Challenges in Eliciting Requirements</h3>

                <ul>
                    <li>Maintaining proper documentation.</li>
                    <li>Trying to understand from a stakeholder’s perspective.</li>
                    <li>Establishing proper communication with stakeholders.</li>
                    <li>Identifying conflicting requirements from the stakeholder side.</li>
                    <li>Establishing structured and insightful discussions with end-users.</li>
                    <li>Performing proper market research and competitor analysis.</li>
                </ul>
            </div>
        </div>
        <div id="t9" class="wh">
            <h2>SDLC</h2>
            <ul>
                <li>SDLC stands for Software Development Life Cycle. It is a structured and systematic approach to
                    planning, creating, testing, deploying, and maintaining software systems. The primary purpose of
                    SDLC is to produce high-quality software that meets or exceeds customer expectations, is delivered
                    on time and within budget, and is maintainable and scalable.</li>
                <li>The SDLC process typically consists of several phases, which can vary depending on the specific
                    methodology or model being used. However, the core phases of SDLC often include:</li>
            </ul>
            <img src="../../images/sdlc.svg" alt="" class="wb">
            <ul>
                <li><b>Planning and Feasibility:</b>
                    <ul>
                        <li>In this phase, the project's initial planning takes place. This involves defining the scope,
                            objectives, and goals of the software development project.</li>
                        <li>Feasibility studies are conducted to assess whether the project is viable from technical,
                            economic, operational, and scheduling perspectives. This helps in determining whether it's
                            worth investing resources into the project.</li>
                        <li>Key decisions, such as project budget, timeline, and resource allocation, are made during
                            this phase. It lays the foundation for the entire project.</li>
                    </ul>
                </li>
                <li><b>Requirement Gathering and Analysis:</b>
                    <ul>
                        <li>During this phase, detailed requirements for the software are collected from stakeholders.
                            This includes end-users, clients, and other relevant parties.</li>
                        <li>The gathered requirements are documented in a comprehensive document known as the Software
                            Requirements Specification (SRS). The SRS outlines what the software should do, its
                            features, functionality, constraints, and any special considerations.</li>
                        <li>The SRS serves as a contract between the development team and stakeholders, ensuring
                            everyone has a clear understanding of what the software will deliver.</li>
                    </ul>
                </li>
                <li><b>Designing:</b>
                    <ul>
                        <li>The design phase focuses on translating the requirements outlined in the SRS into a detailed
                            technical blueprint for the software.</li>
                        <li>The Data Flow Diagram (DFD) is a graphical representation used in this phase to illustrate
                            how data flows through the system. It shows how data is input, processed, and output within
                            the software.</li>
                        <li>System architecture, database schemas, user interfaces, and other technical aspects are
                            designed during this phase. The goal is to create a comprehensive plan for how the software
                            will be structured and function.</li>
                    </ul>
                </li>
                <li><b>Coding and Implementation:</b>
                    <ul>
                        <li>In this phase, developers start writing the actual code based on the design specifications.
                            They use programming languages and development tools to create the software.</li>
                        <li>The code is typically divided into smaller modules or components, each of which is developed
                            and tested independently.</li>
                        <li>Quality control and coding standards are crucial during this phase to ensure that the code
                            is maintainable, efficient, and meets the design specifications.</li>
                    </ul>
                </li>
                <li><b>Testing:</b>
                    <ul>
                        <li>The testing phase involves systematically evaluating the software to identify and fix
                            defects and ensure it meets the requirements outlined in the SRS.</li>
                        <li>Various types of testing, such as unit testing (testing individual components), integration
                            testing (testing interactions between components), system testing (testing the complete
                            system), and user acceptance testing (testing by end-users) are performed.</li>
                        <li>The goal is to ensure the software is reliable, secure, and performs as expected.</li>
                    </ul>
                </li>
                <li><b>Deployement and Maintenance:</b>
                    <ul>
                        <li>After successful testing, the software is deployed to a production environment for use by
                            end-users.</li>
                        <li>The maintenance phase involves ongoing support, bug fixes, updates, and enhancements to keep
                            the software functional and up-to-date.</li>
                        <li>User training and documentation may also be part of this phase to assist users in
                            effectively using the software.</li>
                    </ul>
                </li>
            </ul>
            <p>These phases provide a structured approach to software development, ensuring that the project progresses
                in an organized manner and that the final software product meets the specified requirements and quality
                standards.</p>
            <ul>
                <li>Now, let's explore various software development models that provide different approaches and
                    methodologies for managing the software development process. These models serve as blueprints to
                    guide the entire lifecycle of a software project, from conception to deployment and maintenance.
                    Each model offers a distinct set of principles, practices, and advantages, making them suitable for
                    different types of projects and organizational needs. By understanding these models, you can make
                    informed decisions about which approach aligns best with your project's goals, constraints, and the
                    ever-evolving demands of software development.</li>
            </ul>
            <div class="in">
                <h3>Waterfall method</h3>
                <ul>
                    <li>The Waterfall Model was first process model.</li>
                    <li>It is also referred to as a <b>Liner-Sequential Life Cycle</b> model.</li>
                    <li>In this each phase must be completed fully before the next phase can begin.</li>
                    <li>This type of model is basically used for small projects and there are no uncertain requirements.
                    </li>
                    <li>At the end of each phase, a review takes place to determine if the project is on the right path
                        or not.</li>
                    <li>In this model the testing starts only after the development is complete.</li>
                </ul>
                <img src="../../images/waterfall.svg" alt="" class="wb">
                <p>classical waterfall model divides the cycle into the following phases as shown in above figure.</p>
                <div class="wh">
                    <p><b>Feasibility Study</b></p>
                    <p>In this step we determine whether it would be financially and technically possible to develop the
                        product or not. For this following steps are taken &darr;</p>
                    <ol>
                        <li>Characteristics of different input and output data are analyzed.</li>
                        <li>Type of processing identified. Along with this various constraints of the system are
                            identified.</li>
                        <li>After understanding the problem, engineers investigate the different possible solutions.
                        </li>
                        <li>Then required resources, cost of development and development time for each solution has been
                            calculated.</li>
                        <li>Based on this analysis they pick the best solution and determine whether the solution is
                            feasible financially and technically.</li>
                    </ol>

                    <p><b>Requirements Analysis and Specification</b></p>
                    <ul>
                        <li>This phase consists of two distinct activities, namely
                            <ol>
                                <li>Requirements gathering and analysis, and</li>
                                <li>Requirements specification</li>
                            </ol>
                        </li>
                        <li>In requirements gathering activity the project team collects all relevant information
                            regarding the product. For this many interviews and discussions may be required. The
                            requirements specification activity creates Requirements Specification (SRS) document. </li>
                    </ul>

                    <p><b>Design</b></p>
                    <ul>
                        <li>In this step the requirements which are specified in the SRS document are converted into a
                            programming design (ER diagram, DFD, Flow Charts). Two different methods can be used: the
                            procedural design approach and the object-oriented design approach. So Output of this phase
                            is a logical structure of software. </li>
                    </ul>

                    <p><b>Coding and unit testing</b></p>
                    <ul>
                        <li>In this step the programmers convert logical structure of s/w in to source code. Each
                            component of the design is implemented as a program module. After this each module is tested
                            to check whether all modules are working properly or not. The end-product of this phase is a
                            set of program modules that have been individually tested.</li>
                    </ul>

                    <p><b>Integration and System testing</b></p>
                    <ul>
                        <li>During the integration and system testing phase, the modules are combined in a planned
                            manner. The different modules are never integrated in one shot. Integration is normally
                            carried out incrementally. During each integration step, the partially integrated system is
                            tested. Finally, when all the modules have been successfully integrated and tested, system
                            testing is carried out. </li>
                    </ul>

                    <p><b>Maintenance</b></p>
                    <ul>
                        <li>Maintenance requires more efforts than the effort necessary to develop the product itself.
                            Maintenance involves performing any one or more of the following three kinds of activities:
                            <ul>
                                <li>Correcting errors that were not discovered during the product development phase.
                                    This is called corrective maintenance.</li>
                                <li>Improving the implementation of the system, and enhancing the functionalities of the
                                    system according to the customer’s requirements. This is called perfective
                                    maintenance.</li>
                                <li>Porting the software to work in a new environment. For example, porting may be
                                    required to get the software to work on a new computer platform or with a new
                                    operating system. This is called adaptive maintenance.</li>
                            </ul>
                        </li>
                    </ul>
                </div>
                <div class="wh">
                    <p><b>Advantages of the Waterfall Model:</b></p>
                    <ul>
                        <li>This model is simple and easy to understand and use.</li>
                        <li>It is easy to manage due to the model's rigidity—each phase has specific deliverables and a
                            review process.</li>
                        <li>In this model, phases are processed and completed one at a time without overlapping.</li>
                        <li>The Waterfall model works well for smaller projects where requirements are very well
                            understood.</li>
                    </ul>
                </div>
                <div class="wh">
                    <p><b>Disadvantages of the Waterfall Model:</b></p>
                    <ul>
                        <li>Once an application reaches the testing stage, it becomes very difficult to go back and
                            change something that was not well-thought-out in the concept stage.</li>
                        <li>No working software is produced until late in the project life cycle.</li>
                        <li>There are high levels of risk and uncertainty associated with this model.</li>
                        <li>It is not a suitable model for complex and object-oriented projects.</li>
                        <li>It is a poor choice for long and ongoing projects.</li>
                        <li>It is not suitable for projects where requirements are at moderate to high risk of changing.
                        </li>
                    </ul>
                </div>
                <div class="wh">
                    <p><b>When to Use the Waterfall Model:</b></p>
                    <ul>
                        <li>This model is used only when the requirements are very well known, clear, and fixed.</li>
                        <li>The product definition remains stable.</li>
                        <li>The technology to be used is well understood.</li>
                        <li>There are no ambiguous requirements.</li>
                        <li>Ample resources with the required expertise are freely available.</li>
                        <li>The project has a short duration.</li>
                    </ul>
                </div>
            </div>
            <div class="in">
                <h3>Prototyping</h3>
                <p>Prototyping is defined as the process of developing a working replication of a product or system that
                    has to be engineered. It offers a small-scale facsimile of the end product and is used for obtaining
                    customer feedback as described below:</p>
                <img src="../../images/prototyping.svg" alt="" class="wb">
                <h3>The Prototyping Model</h3>
                <p>The Prototyping Model is one of the most popularly used Software Development Life Cycle Models (SDLC
                    models). This model is used when the customers do not know the exact project requirements
                    beforehand. In this model, a prototype of the end product is first developed, tested, and refined as
                    per customer feedback repeatedly until a final acceptable prototype is achieved, which forms the
                    basis for developing the final product.</p>

                <p>In this process model, the system is partially implemented before or during the analysis phase,
                    thereby giving the customers an opportunity to see the product early in the life cycle. The process
                    starts by interviewing the customers and developing the incomplete high-level paper model. This
                    document is used to build the initial prototype supporting only the basic functionality as desired
                    by the customer. Once the customer figures out the problems, the prototype is further refined to
                    eliminate them. The process continues until the user approves the prototype and finds the working
                    model to be satisfactory. There are four types of models available:</p>

                <div class="wh">
                    <p><b>A) Rapid Throwaway Prototyping</b></p>
                    <p>This technique offers a useful method of exploring ideas and getting customer feedback for each
                        of
                        them. In this method, a developed prototype need not necessarily be a part of the ultimately
                        accepted prototype. Customer feedback helps in preventing unnecessary design faults and hence,
                        the
                        final prototype developed is of better quality.</p>
                </div>

                <div class="wh">
                    <p><b>B) Evolutionary Prototyping</b></p>
                    <p>In this method, the prototype developed initially is incrementally refined on the basis of
                        customer
                        feedback till it finally gets accepted.</p>
                </div>

                <div class="wh">
                    <p><b>C) Incremental Prototyping</b></p>
                    <p>In this type of incremental Prototyping, the final expected product is broken into different
                        small
                        pieces of prototypes and being developed individually. In the end, when all individual pieces
                        are
                        properly developed, then the different prototypes are collectively merged into a single final
                        product in their predefined order.</p>
                </div>

                <div class="wh">
                    <p><b>D) Extreme Prototyping</b></p>
                    <p>This method is mainly used for web development. It consists of three sequential independent
                        phases:
                    </p>
                    <ol>
                        <li>In this phase, a basic prototype with all the existing static pages is presented in the
                            HTML format.</li>
                        <li>In the 2nd phase, Functional screens are made with a simulated data process using a
                            prototype services layer.</li>
                        <li>This is the final step where all the services are implemented and associated with the final
                            prototype.</li>
                    </ol>
                </div>

                <p><b>Advantages</b></p>
                <ul>
                    <li>The customers get to see the partial product early in the life cycle. This ensures a greater
                        level of customer satisfaction and comfort.</li>
                    <li>New requirements can be easily accommodated as there is scope for refinement.</li>
                    <li>Missing functionalities can be easily figured out.</li>
                    <li>Errors can be detected much earlier thereby saving a lot of effort and cost, besides enhancing
                        the quality of the software.</li>
                    <li>Flexibility in design.</li>
                </ul>

                <p><b>Disadvantages</b></p>
                <ul>
                    <li>Costly w.r.t time as well as money.</li>
                    <li>There may be too much variation in requirements each time the prototype is evaluated by the
                        customer.</li>
                    <li>Poor Documentation due to continuously changing customer requirements.</li>
                    <li>It is very difficult for developers to accommodate all the changes demanded by the customer.
                    </li>
                    <li>There is uncertainty in determining the number of iterations that would be required before the
                        prototype is finally accepted by the customer.</li>
                    <li>After seeing an early prototype, the customers sometimes demand the actual product to be
                        delivered soon.</li>
                    <li>Developers in a hurry to build prototypes may end up with sub-optimal solutions.</li>
                    <li>The customer might lose interest in the product if he/she is not satisfied with the initial
                        prototype.</li>
                </ul>

                <p><b>Use</b></p>
                <p>The Prototyping Model should be used when the requirements of the product are not clearly understood
                    or are unstable. It can also be used if requirements are changing quickly. This model can be
                    successfully used for developing user interfaces, high technology software-intensive systems, and
                    systems with complex algorithms and interfaces. It is also a very good choice to demonstrate the
                    technical feasibility of the product.</p>

            </div>
            <div class="in">
                <h3>Incremental Model</h3>
                <p>The incremental process model is also known as the Successive version model. First, a simple working
                    system developed with a few basic features and delivered to the customer. Then thereafter many
                    successive iterations/ versions are implemented and delivered to the customer until the desired
                    system is released.</p>
                <img src="../../images/incrementalmodel.svg" alt="" class="wb">
                <p>A, B, and C are modules of Software Products that are incrementally developed and delivered.</p>

                <div class="wh">
                    <p><b>Activities:</b></p>
                    <ul>
                        <li>Requirements are broken down into several modules that can be incrementally constructed and
                            delivered.</li>
                        <li>At any time, the plan is made just for the next increment. Therefore, it is easier to modify
                            the
                            version as per the need of the customer.</li>
                        <li>The Development Team first develops core features of the system.</li>
                        <li>Once the core features are fully developed, then these are refined to add new functions in
                            Successive versions.</li>
                        <li>As each successive version of the feedback of the Customer is taken and feedback is
                            incorporated
                            into the next version.</li>
                        <li>Each version of the software has more additional features than the previous ones.</li>
                    </ul>
                </div>

                <div class="wh">
                    <p><b>Types of Incremental Model:</b></p>
                    <ol>
                        <li>Staged Delivery Model: Construction of only one part of the project at a time.</li>
                        <li>Parallel Development Model: Different subsystems are developed at the same time. It can
                            decrease
                            the calendar time needed for the development, i.e. TTM (Time to Market).</li>
                    </ol>
                </div>

                <p><b>When to Use This Model:</b></p>
                <ul>
                    <li>Funding Schedule, Risk, Program Complexity, or need for early realization of benefits.</li>
                    <li>When Requirements are known up-front.</li>
                    <li>When Projects have lengthy development schedules.</li>
                    <li>Projects with new Technology.</li>
                    <li>Requires good planning and design.</li>
                    <li>The total cost is not lower.</li>
                    <li>Well-defined module interfaces are required.</li>
                </ul>

                <p><b>Advantages:</b></p>
                <ol>
                    <li>Prepares the software fast.</li>
                    <li>Clients have a clear idea of the project.</li>
                    <li>Changes are easy to implement.</li>
                    <li>Provides risk handling support because of its iterations.</li>
                </ol>

                <p><b>Disadvantages:</b></p>
                <ul>
                    <li>A good team and proper planned execution are required.</li>
                    <li>Because of its continuous iterations, the cost increases.</li>
                </ul>

            </div>
            <div class="in">
                <h3>RAD Model (Rapid Application Development)</h3>
                <p>RAD Model or Rapid Application Development Model is similar to the incremental model and waterfall
                    model. In RAD Model, development should be done in a specified time frame.</p>

                <p>RAD Model is suitable for small projects where all the requirements are gathered before starting
                    development of the project. Once the client gives feedback, based on the client’s feedback, other
                    changes are done. This process goes parallel with cooperation with the client and developers. Each
                    software version is delivered to the client with working functionality, and changes are made based
                    on the client’s feedback. Development moves faster in RAD Model with minimum errors. RAD Model
                    follows the incremental delivery of the modules. The main goal of RAD Model is to make the
                    reusability of the developed components.</p>

                <p><b>Phases in RAD Model:</b></p>
                <ul>
                    <li>Business Modeling</li>
                    <li>Data Modeling</li>
                    <li>Process Modeling</li>
                    <li>Application Modeling</li>
                    <li>Testing and Turnover</li>
                </ul>

                <div class="wh">
                    <p><b>Business Modeling:</b></p>
                    <p>In this phase of development, a business model should be designed based on the information
                        available
                        from different business activities. Before starting the development, there should be a complete
                        picture of the business process functionality.</p>
                </div>

                <div class="wh">
                    <p><b>Data Modeling:</b></p>
                    <p>Once the business modeling phase is over and all the business analysis is completed, all the
                        required
                        and necessary data based on business analysis are identified in the data modeling phase.</p>
                </div>

                <div class="wh">
                    <p><b>Process Modeling:</b></p>
                    <p>All the data identified in the data modeling phase are planned to process or implement the
                        identified
                        data to achieve the business functionality flow. In this phase, all the data modification
                        processes
                        are defined.</p>
                </div>

                <div class="wh">
                    <p><b>Application Modeling:</b></p>
                    <p>In this phase, the application is developed, and coding is completed. With the help of automation
                        tools, all data is implemented and processed to work in real-time.</p>
                </div>

                <div class="wh">
                    <p><b>Testing and Turnover:</b></p>
                    <p>All the testing activities are performed to test the developed application.</p>
                </div>

                <p><b>Advantages of RAD Model:</b></p>
                <ul>
                    <li>Fast application development and delivery.</li>
                    <li>Less testing activity required.</li>
                    <li>Visualization of progress.</li>
                    <li>Less resources required.</li>
                    <li>Review by the client from the very beginning of development, so very less chance to miss the
                        requirements.</li>
                    <li>Very flexible if any changes are required.</li>
                    <li>Cost-effective.</li>
                    <li>Good for small projects.</li>
                </ul>

                <p><b>Disadvantages of RAD Model:</b></p>
                <ul>
                    <li>Highly skilled resources required.</li>
                    <li>Client’s feedback required on each development phase.</li>
                    <li>Automated code generation is very costly.</li>
                    <li>Difficult to manage.</li>
                    <li>Not a good process for long-term and big projects.</li>
                    <li>Proper modularization of project required.</li>
                </ul>

                <p><b>When RAD Model Should Be Followed:</b></p>
                <ul>
                    <li>For low budget projects for which automated code generation cost is low.</li>
                    <li>When highly skilled resources are available.</li>
                    <li>When it’s easy to modularize the project.</li>
                    <li>If technical risks are low.</li>
                    <li>If development needs to be completed in a specified time.</li>
                    <li>RAD Model is suitable if the functionality has fewer dependencies on other functionality.</li>
                </ul>
            </div>
            <div class="in">
                <h3>Spiral Model</h3>
                <p>The Spiral model is one of the most important Software Development Life Cycle models, which provides
                    support for Risk Handling. In its diagrammatic representation, it looks like a spiral with many
                    loops. The exact number of loops of the spiral is unknown and can vary from project to project. Each
                    loop of the spiral is called a Phase of the software development process. The exact number of phases
                    needed to develop the product can be varied by the project manager depending upon the project risks.
                    As the project manager dynamically determines the number of phases, so the project manager has an
                    important role to develop a product using the spiral model.</p>
<img src="../../images/spiralmodel.svg" alt="" class="wb">
                <p>The Radius of the spiral at any point represents the expenses (cost) of the project so far, and the
                    angular dimension represents the progress made so far in the current phase.</p>

                <p>The above diagram shows the different phases of the Spiral Model:</p>

                <div class="wh">
                    <p><b>Phases in Spiral Model:</b></p>
                    <ul>
                        <li>Objectives determination and identify alternative solutions: Requirements are gathered from
                            the
                            customers and the objectives are identified, elaborated, and analyzed at the start of every
                            phase. Then alternative solutions possible for the phase are proposed in this quadrant.</li>
                        <li>Identify and resolve Risks: During the second quadrant, all the possible solutions are
                            evaluated
                            to select the best possible solution. Then the risks associated with that solution are
                            identified and the risks are resolved using the best possible strategy. At the end of this
                            quadrant, the Prototype is built for the best possible solution.</li>
                        <li>Develop the next version of the Product: During the third quadrant, the identified features
                            are
                            developed and verified through testing. At the end of the third quadrant, the next version
                            of
                            the software is available.</li>
                        <li>Review and plan for the next Phase: In the fourth quadrant, the Customers evaluate the so
                            far
                            developed version of the software. In the end, planning for the next phase is started.</li>
                    </ul>
                </div>

                <p><b>Risk Handling in Spiral Model</b></p>
                <p>A risk is any adverse situation that might affect the successful completion of a software project.
                    The most important feature of the spiral model is handling these unknown risks after the project has
                    started. Such risk resolutions are easier done by developing a prototype. The spiral model supports
                    coping up with risks by providing the scope to build a prototype at every phase of the software
                    development.</p>

                <p>The Prototyping Model also supports risk handling, but the risks must be identified completely before
                    the start of the development work of the project. But in real-life project risk may occur after the
                    development work starts; in that case, we cannot use the Prototyping Model. In each phase of the
                    Spiral Model, the features of the product dated and analyzed, and the risks at that point in time
                    are identified and are resolved through prototyping. Thus, this model is much more flexible compared
                    to other SDLC models.</p>

                <p><strong>Why Spiral Model is called Meta Model?</strong><br>The Spiral model is called a Meta-Model
                    because it subsumes all the other SDLC models. For example, a single loop spiral actually represents
                    the Iterative Waterfall Model. The spiral model incorporates the stepwise approach of the Classical
                    Waterfall Model. The spiral model uses the approach of the Prototyping Model by building a prototype
                    at the start of each phase as a risk-handling technique. Also, the spiral model can be considered as
                    supporting the Evolutionary model – the iterations along the spiral can be considered as
                    evolutionary levels through which the complete system is built.</p>

                <p><b>Advantages of Spiral Model:</b></p>
                <ul>
                    <li>Risk Handling: The projects with many unknown risks that occur as the development proceeds, in
                        that case, Spiral Model is the best development model to follow due to the risk analysis and
                        risk handling at every phase.</li>
                    <li>Good for large projects: It is recommended to use the Spiral Model in large and complex
                        projects.</li>
                    <li>Flexibility in Requirements: Change requests in the Requirements at a later phase can be
                        incorporated accurately by using this model.</li>
                    <li>Customer Satisfaction: Customer can see the development of the product at the early phase of the
                        software development and thus, they habituated with the system by using it before completion of
                        the total product.</li>
                </ul>

                <p><b>Disadvantages of Spiral Model:</b></p>
                <ul>
                    <li>Complex: The Spiral Model is much more complex than other SDLC models.</li>
                    <li>Expensive: Spiral Model is not suitable for small projects as it is expensive.</li>
                    <li>Too much dependability on Risk Analysis: The successful completion of the project is very much
                        dependent on Risk Analysis. Without very highly experienced experts, it is going to be a failure
                        to develop a project using this model.</li>
                    <li>Difficulty in time management: As the number of phases is unknown at the start of the project,
                        so time estimation is very difficult.</li>
                </ul>
            </div>
            <div class="in">
                <h3>V-Model (Verification and Validation Model)</h3>
                <p>The V-Model, which stands for Verification and Validation Model, is a sequential path of execution of
                    processes, similar to the waterfall model. Each phase must be completed before the next phase
                    begins. Testing of the product is planned in parallel with a corresponding phase of development in
                    the V-model.</p>
                    <img src="../../images/vmodel.svg" alt="" class="wb">
                <p><b>Phases of the V-Model:</b></p>
                <ul>
                    <li><strong>Requirements:</strong> Like BRS and SRS, this phase begins the life cycle model, similar
                        to the waterfall model. However, in this model, before development starts, a system test plan is
                        created. The test plan focuses on meeting the functionality specified in the requirements
                        gathering.</li>
                    <li><strong>High-level design (HLD):</strong> This phase focuses on system architecture and design,
                        providing an overview of the solution, platform, system, product, and service/process. An
                        integration test plan is created in this phase to test the pieces of the software system's
                        ability to work together.</li>
                    <li><strong>Low-level design (LLD):</strong> In this phase, the actual software components are
                        designed, defining the actual logic for each and every component of the system. A class diagram
                        with all the methods and relations between classes comes under LLD. Component tests are created
                        in this phase as well.</li>
                    <li><strong>Implementation:</strong> This is where all coding takes place. Once coding is complete,
                        the path of execution continues up the right side of the V, where the test plans developed
                        earlier are now put to use.</li>
                    <li><strong>Testing:</strong> At the bottom of the V-Shape model, testing activities like planning
                        and test designing happen well before coding. This saves a lot of time, leading to a higher
                        chance of success over the waterfall model. Proactive defect tracking is enabled, and it avoids
                        the downward flow of defects. It works well for small projects where requirements are easily
                        understood.</li>
                </ul>

                <p><b>Advantages of V-Model:</b></p>
                <ul>
                    <li>Simple and easy to use.</li>
                    <li>Testing activities like planning and test designing happen well before coding, saving time and
                        increasing the chance of success.</li>
                    <li>Proactive defect tracking - defects are found at an early stage.</li>
                    <li>Avoids the downward flow of defects.</li>
                    <li>Works well for small projects where requirements are easily understood.</li>
                </ul>

                <p><b>Disadvantages of V-Model:</b></p>
                <ul>
                    <li>Very rigid and least flexible.</li>
                    <li>Software is developed during the implementation phase, so no early prototypes of the software
                        are produced.</li>
                    <li>If any changes happen midway, then the test documents along with requirement documents have to
                        be updated.</li>
                </ul>

                <p><b>When to use the V-Model:</b></p>
                <ul>
                    <li>The V-shaped model should be used for small to medium-sized projects where requirements are
                        clearly defined and fixed.</li>
                    <li>The V-Shaped model should be chosen when ample technical resources are available with needed
                        technical expertise.</li>
                    <li>High confidence of the customer is required for choosing the V-Shaped model approach. Since no
                        prototypes are produced, there is a very high risk involved in meeting customer expectations.
                    </li>
                </ul>

            </div>
        </div>
    </div>
    <div id="tpyq" class="content-box">
        <h2>Previous Years Questions</h2>
        <div class="in">
            <h4>Fill in the blanks:
                <ol>
                    <li>Full form of SRS is _______________.</li>
                    <li>Use case is used for _____________.</li>
                    <li>Waterfall model is most appropriate when requirements are __________.</li>
                    <li>We use ___________ diagram to analyze a requirement from data perspective.</li>
                    <li>FAST stands for ___________________.</li>
                </ol>
            </h4>
        </div>
        <div class="in">
            <h4>Attempt any five parts:
                <ul>
                    <li>Discuss the evolving role of software.</li>
                    <li>Give IEEE definition of software engineering.</li>
                    <li>Briefly explain the importance of software.</li>
                    <li>Explain any three problems of software engineering.</li>
                    <li>Give characteristics of good SRS.</li>
                    <li>Different application areas of software.</li>
                </ul>
            </h4>
        </div>
        <div class="in">
            <h4>Attempt any two parts of choice from (a), (b) and (c).
                <ol type="a">
                    <li>Discuss different phases of software development life cycle.</li>
                    <li>Describe the waterfall model. Also explain its advantages and disadvantages.</li>
                    <li>Discuss the prototype model. What is the effect of designing a prototype on the overall cost of the software project?</li>
                </ol>
            </h4>
        </div>
        <div class="in">
            <h4>Attempt any two parts of choice from (a), (b) and (c).
                <ol type="a">
                    <li>Differentiate between the terms program and software by giving suitable examples. What are the most desirable attributes of a good software?</li>
                    <li>Define the term software engineering. What are the most desirable characteristics of software?</li>
                    <li>Define SRS. What are the different components of SRS?</li>
                </ol>
            </h4>
        </div>
        <div class="in">
            <h3>Recognise the definition of software engineering. Describe various characteristics of a good software. Recall and explaoin evolving role of software in business.</h3>
        </div>
        <div class="in">
            <h4>Illustrate the various problem faced by software engineers in developing a software for a business. Review the software crises, its reasons and possible solutions.</h4>
        </div>
        <div class="in">
            <h4>Describe prototype model for software development. In which situation, one should use it? Discuss the following in relation to prototype development:
                <ol type="i">
                    <li>Rapied Throwaway Prototyping</li>
                    <li>Evolutionary Prototyping</li>
                    <li>Incremental Prototyping</li>
                    <li>Extreme Prototyping</li>
                </ol>
            </h4>
        </div>
        <div class="in">
            <h4>Interpret the following:
                <ol type="i">
                    <li>Phases in RAD model</li>
                    <li>Disadvantages of Waterfall model</li>
                    <li>Risk Handling in Spiral model</li>
                    <li>Advantages of Spiral model</li>
                    <li>V-model</li>
                </ol>
            </h4>
        </div>
        <div class="in">
            <h4>Define the term Software Engineering. How will you define efficiency of a software? Explain the importance of software engineering?</h4>
        </div>
        <div class="in">
            <h4>In your opinion, what are the problems will a software developer face during the software development? How these problems can be solved?</h4>
        </div>
        <div class="in">
            <h4>What is Software Quality Assurance? What are the Main Components and Activities of Software Quality Assurance?</h4>
        </div>
        <div class="in">
            <h4>Demonstrate the term SDLC by taking a real world example, explain Waterfall model.</h4>
        </div>
        <div class="in">
            <h4>What are the various advantages and disadvantages of Prototype and RAD models?</h4>
        </div>
    </div>
    <div class="content-box">
        <p>Reference &darr;</p>
        <ul>
            <li><a target="_blank"
                    href="https://www.youtube.com/playlist?list=PL-JvKqQx2AtdZ7m5Nui3RwqEnNcZZ9N1L">Playlist (University
                    Academy) &neArr;</a></li>
        </ul>
    </div>
    <script src="../../../../public/main.js"></script>
</body>

</html>