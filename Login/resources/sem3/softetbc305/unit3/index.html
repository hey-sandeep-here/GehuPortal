<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Coding</title>
    <link rel="stylesheet" href="../../../../public/style.css">
    <link rel="icon" href="../../../../public/logo/favicon_io/favicon.ico">
    <link rel="stylesheet" id="highlightStylesheet"
        href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/tomorrow-night-blue.min.css">
</head>

<body class="bg-c">
    <div id="mySidepanel" class="sidepanel">
        <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">×</a>
        <a href="../index.html" class="home">back</a>
        <a href="#" class="link"></a>
        <div class="botbut">
            <a href="../unit4/index.html" class="link">Next Topic &rarr;</a>
            <a href="../unit2/index.html" class="link">&larr; Previous Topic</a>
        </div>
    </div>
    <div id="navbar" class="grad">
        <div>
            <div class="openbtn" onclick="openNav()">
                <div id="nav-icon1" for="nav-menu1">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </div>
        </div>
        <div>
            <h2>Coding</h2>
        </div>
    </div>
    <div class="content-box">
        <h1>Coding</h1>
        <p><b>In the coding unit of the Software Engineering course, we're diving into the world of programming! The
                main goal is to help you become a pro at writing code. We'll start by learning how to organize our code
                from the big picture (Top-Down) and the small details (Bottom-Up). This helps us write code that's easy
                to understand. We'll also talk about Structured Programming, which is like a set of rules for making
                your code neat and tidy. Another cool thing we'll learn is Information Hiding, which is like keeping
                secrets in your code to make it work better. Then, we'll move on to Testing, which is like making sure
                our code works properly. We'll cover different types of testing and how to fix any mistakes (bugs) we
                find. Lastly, we'll talk about Software Maintenance, which is like taking care of our code and making it
                better over time. So, the motivation behind learning all this is to help you become a great coder and be
                ready for the real-world challenges of building software!</b></p>
        <div class="wh">
            <h2>Top-Down and Bottom-Up Programming</h2>
            <ul>
                <li><strong>Top-Down Programming:</strong> This approach involves starting with the big picture and
                    breaking it down into smaller, manageable parts. Think of it like planning a trip: you decide on the
                    overall destination first and then plan the details like transportation and accommodation. In
                    coding, you first create a high-level design and then break it down into smaller functions or
                    modules.</li>
                <li><strong>Bottom-Up Programming:</strong> In contrast, Bottom-Up Programming begins with small,
                    individual components and gradually builds them up into a complete system. It's like building a
                    puzzle from the pieces. In coding, you start by creating small, functional units and then combine
                    them to form a more complex system.</li>
                <li>Both approaches have their advantages. Top-Down helps in understanding the overall structure first,
                    while Bottom-Up allows for focusing on individual parts and ensuring they work correctly before
                    integrating them into the larger system.</li>
            </ul>
        </div>
        <div class="wh">
            <h2>Structured Programming</h2>
            <ul>
                <li>Structured programming emphasizes writing programs in a way that is easy to understand.</li>
                <li>A program's structure consists of both static and dynamic elements. The static structure
                    refers
                    to the linear organization of statements in the code, while the dynamic structure is the
                    sequence of statements executed during runtime.</li>
                <li>Program correctness is about ensuring that the program, when executed, behaves as intended.
                    To
                    verify correctness, we analyze the static structure (code) to understand the dynamic
                    behavior of
                    the program.</li>
                <li>The main objective of structured programming is to align the static and dynamic structures,
                    ensuring that the executed sequence matches the code sequence. This promotes a linear flow
                    of
                    control in programs.</li>
                <li>Structured constructs, like selection and iteration, are employed to maintain linear flow
                    even
                    in the presence of branching or repetition. Structured statements have a single entry and a
                    single exit, contributing to a clear program logic. Commonly used constructs include:</li>
            </ul>

            <pre>
                    <code>
Selection:
    if B then S1 else S2 
    if B then S1

Iteration:
    While B
    do S 
    repeat S 
    until B
                    </code>
                </pre>

            <ul>
                <li>The primary goal is to simplify the program logic for better understanding. While no
                    universal
                    rule fits all scenarios, structured programming provides valuable guidelines.</li>
                <li>Structured programming generally results in programs that are easier to comprehend compared
                    to
                    unstructured ones.</li>
                <li>However, it's essential to note that structured programming is not an end in itself. The
                    ultimate objective is to create programs that are easy to understand. Some programming
                    practices
                    may still use unstructured constructions (e.g., break statements, continue statements) when
                    appropriate.</li>
            </ul>
        </div>
        <div class="wh">
            <h2>Information Hiding</h2>
            <ul>
                <li>Information hiding plays a crucial role in reducing the coupling between modules, leading to a more
                    maintainable system. Coupling refers to the degree of dependence between different modules or
                    components in a software system.</li>
                <li>By employing information hiding, developers can encapsulate the internal details of a module,
                    allowing it to interact with other modules through well-defined interfaces while keeping the
                    internal workings hidden. This abstraction of details enhances modularity and reduces the impact of
                    changes in one module on the rest of the system.</li>
                <li>Information hiding is a powerful technique for managing the complexity of software development. In
                    many older programming languages like Pascal, C, and Fortran, there may be a lack of built-in
                    mechanisms to support data abstraction. In such languages, information hiding relies heavily on the
                    disciplined use of the language by the programmer. Access restrictions must be imposed manually
                    since the language itself may not provide them.</li>
            </ul>

            <p>Benefits of Information Hiding:</p>
            <ul>
                <li><strong>Reduced Coupling:</strong> Information hiding minimizes the interdependence between modules,
                    making it easier to modify one module without affecting others. This enhances system flexibility and
                    maintainability.</li>
                <li><strong>Enhanced Abstraction:</strong> By concealing internal details, information hiding promotes a
                    clear distinction between a module's interface and its implementation. This abstraction simplifies
                    the understanding and usage of the module.</li>
                <li><strong>Improved Security:</strong> Hiding implementation details adds a layer of security by
                    restricting direct access to internal workings, preventing unintended interference or misuse.</li>
                <li><strong>Facilitates Change:</strong> Modules with well-defined interfaces are easier to modify or
                    replace, as long as the external contract remains unchanged. This facilitates system evolution and
                    adaptation to new requirements.</li>
            </ul>
        </div>
        <div class="wh">
            <h3>Programming Style</h3>
            <p>When it comes to programming style, adhering to certain rules not only enhances the readability of your
                code but also helps in avoiding common errors. Let's delve into some essential principles:</p>

            <ul>
                <li><strong>Control Constructs:</strong> It is advisable to use single-entry, single-exit constructs as
                    much as possible. Opt for a limited set of standard control constructs to maintain a consistent and
                    easily understandable code structure.</li>
                <li><strong>Gotos:</strong> The use of gotos should be approached with caution, employing them only when
                    the alternative becomes more complex. Ideally, it's best to minimize their usage in favor of more
                    structured control flow.</li>
                <li><strong>Information Hiding:</strong> Encouraging information hiding where applicable allows for
                    better organization of code, ensuring that the internal details are shielded for a clearer
                    understanding of the overall structure.</li>
                <li><strong>User-Defined Types:</strong> Providing users the ability to define types, such as enumerated
                    types, proves beneficial, especially in scenarios with deeply nested if-then-else constructs,
                    contributing to improved code comprehension.</li>
                <li><strong>Module Size:</strong> While there's no strict rule regarding module sizes, the focus should
                    be on achieving cohesion and managing coupling effectively to promote modular and maintainable code.
                </li>
                <li><strong>Module Interface:</strong> Modules with interfaces having more than five parameters warrant
                    careful examination, and simplification should be considered where possible to maintain a concise
                    and comprehensible codebase.</li>
                <li><strong>Side Effects:</strong> Minimizing side effects when invoking modules is crucial. If a module
                    does have side effects, proper documentation is essential to communicate these effects clearly.</li>
                <li><strong>Robustness:</strong> A robust program not only anticipates but gracefully handles
                    exceptional conditions, ensuring that meaningful messages are produced instead of crashing abruptly
                    in the face of unexpected situations.</li>
                <li><strong>Switch Case with Default:</strong> It's good practice to include a default case in a
                    "switch" statement to avoid unpredictable behavior that might lead to bugs, such as NULL dereference
                    or memory leaks.</li>
                <li><strong>Empty Catch Block:</strong> When catching exceptions, taking some default action is
                    advisable to prevent scenarios where critical operations are inadvertently omitted.</li>
                <li><strong>Trusted Data Sources:</strong> Performing counter checks before accessing input data,
                    particularly if it's sourced from users or obtained over the network, adds an extra layer of
                    reliability to your code.</li>
                <li><strong>Give Importance to Exceptions:</strong> Exceptional cases, often overlooked, can be a
                    significant source of system failures. Prioritizing suitable exception handlers for all
                    possibilities contributes to building more reliable software systems.</li>
            </ul>
        </div>
        <div class="wh">
            <h2>Internal Documentation</h2>
            <p>In the realm of software engineering, documentation extends to all written materials pertaining to the
                development and usage of a software product. The primary objective of effective documentation is to
                foster alignment among developers and stakeholders, ensuring a shared path toward achieving project
                objectives. Software documentation neatly falls into two main categories:</p>
            <div class="in">
                <h3>Product Documentation</h3>
                <ul>
                    <li><strong>System Documentation:</strong> Serving as a window into the system, this documentation
                        provides an overview, aiding engineers and stakeholders in comprehending the underlying
                        technology.
                        It comprises essentials like the requirements document, architecture design, source code,
                        validation
                        docs, verification and testing info, along with a maintenance/help guide.</li>
                    <ul>
                        <li><strong>(i) Requirements Document:</strong> This cornerstone document unfolds the
                            intricacies of
                            system functionality, encapsulating business rules, user stories, and use cases, providing a
                            blueprint for development.</li>
                        <li><strong>(ii) Design & Architecture Document:</strong> Delving into the architectural
                            decisions,
                            it encompasses a design document template, architecture & design principles, user story
                            description, solution details, and diagrammatic representation of the solution, facilitating
                            a
                            comprehensive understanding.</li>
                        <li><strong>(iii) Source Code Document:</strong> Housing the actual source code, this component
                            caters primarily to software engineers, providing the raw material that shapes the software
                            product.</li>
                        <li><strong>(iv) Quality Assurance Documentation:</strong> This segment incorporates various
                            testing
                            documents, including the strategic approach (test strategy), a snapshot of what's to be
                            tested
                            at a given time (test plan), detailed actions for verifying features (test case
                            specifications),
                            and a checklist to keep track of completed tests.</li>
                        <li><strong>(v) Maintenance and Help Guide:</strong> This crucial document goes beyond
                            problem-solving, offering insights into known issues and their solutions. It also outlines
                            dependencies within different parts of the system, providing a guide for maintenance.</li>
                    </ul>
                    <li><strong>User Documentation:</strong> Tailored for end-users and system administrators, this
                        branch
                        elucidates how the software addresses their specific needs. It encompasses user-oriented
                        resources
                        like tutorials, FAQs, video tutorials, embedded assistance, and support portals. Additionally,
                        it
                        provides technical guides for system administrators, covering installation, updates, functional
                        descriptions, and system admin guides.</li>
                </ul>
            </div>
            <div class="in">
                <h3>Process Documentation</h3>
                <p>Process documentation takes us behind the scenes, covering all activities related to product
                    development.
                    It involves some upfront planning and ongoing paperwork. Common types include:</p>
                <ul>
                    <li><strong>Plans, Estimates, and Schedules:</strong> Crafted before the project's initiation, these
                        documents lay the groundwork for the entire development journey.</li>
                    <li><strong>Reports and Metrics:</strong> Generated on a regular basis, these reports provide
                        insights
                        into how time and human resources are utilized during development, offering a snapshot of
                        progress
                        and potential areas for improvement.</li>
                    <li><strong>Working Papers:</strong> Essential for recording engineers' ideas and thoughts during
                        project implementation, these documents serve as a dynamic record of the development process.
                    </li>
                    <li><strong>Standards:</strong> This section outlines all coding and user experience (UX) standards
                        adhered to throughout the project's progression, ensuring consistency and quality in the
                        development
                        process.</li>
                </ul>
            </div>
        </div>
        <div class="wh">
            <h2>Testing</h2>
            <p>Software testing is a crucial process with the following key aspects:</p>

            <ul>
                <li><strong>Identification of Correctness:</strong> The primary goal is to verify the correctness of
                    software by assessing various attributes such as reliability, scalability, portability,
                    re-usability, and usability.</li>
                <li><strong>Evaluation of Software Execution:</strong> Testing involves a comprehensive evaluation of
                    the software's execution to identify and address any errors or bugs that may impact its
                    functionality.</li>
                <li><strong>Attributes Considered in Testing:</strong> The testing process takes into account multiple
                    attributes, including reliability, scalability, portability, re-usability, and usability, ensuring a
                    holistic assessment of the software.</li>
                <li><strong>Identification of Errors:</strong> In a software development project, errors can be
                    introduced at various stages. Testing acts as a crucial checkpoint to detect and rectify any errors
                    that may persist from previous phases of development.</li>
            </ul>
            <div class="in">
                <h3>Testing Principles</h3>
                <p>Testing principles, as suggested by Davis, along with additional insights from Everett and Meyer,
                    guide effective testing practices:</p>

                <ul>
                    <li><strong>Principle 1:</strong> All tests should be traceable to customer requirements, ensuring
                        that testing uncovers errors from the customer's perspective.</li>
                    <li><strong>Principle 2:</strong> Tests should be meticulously planned well in advance, initiating
                        the planning process as soon as the requirements model is complete. Detailed test case
                        definitions can commence post-design completion, allowing for comprehensive planning and design
                        before any code generation begins.</li>
                    <li><strong>Principle 3:</strong> Applying the Pareto principle to software testing, roughly 80% of
                        consequences come from 20% of causes. Testers should identify and thoroughly test these critical
                        components.</li>
                    <li><strong>Principle 4:</strong> Testing should initiate "in the small" by assessing individual
                        components before progressing to "in the large," focusing on uncovering errors in integrated
                        components and, ultimately, the entire system.</li>
                    <li><strong>Principle 5:</strong> Acknowledging the impossibility of exhaustive testing, the
                        approach should prioritize critical paths, recognizing that testing every possible combination
                        is not feasible.</li>
                    <li><strong>Principle 6:</strong> Efforts for various module testing should align with the
                        expectation of finding errors, ensuring a targeted and effective testing approach.</li>
                    <li><strong>Principle 7:</strong> Recognizing the significance of static testing techniques, over
                        85% of software defects originate in software documentation. This includes requirements,
                        specifications, code walk-throughs, and user manuals.</li>
                    <li><strong>Principle 8:</strong> Tracking defects and identifying patterns in defects uncovered
                        during testing allows for proactive problem-solving and continuous improvement.</li>
                    <li><strong>Principle 9:</strong> Inclusion of test cases that demonstrate correct software behavior
                        is essential, ensuring that the software aligns with expected functionality.</li>
                </ul>
            </div>
            <div class="in">
                <h3>Levels of Testing</h3>
                <p>In the realm of software testing, four distinct levels of testing provide a structured approach to
                    assess software quality:</p>

                <ul>
                    <li><strong>Level 1: Unit Testing</strong></li>
                    <p>A unit represents an individual function within the application, serving as the smallest testable
                        part of the software. Unit testing involves analyzing each unit or component independently. As
                        the initial level of functional testing, its primary goal is to validate individual unit
                        components.</p>

                    <li><strong>Level 2: Integration Testing</strong></li>
                    <p>Integration testing focuses on testing the data flow between different modules. It comes into
                        play after each component or module has been independently validated (Level 1). This level aims
                        to check the data flow between dependent modules, ensuring a smooth integration. Integration
                        testing commences once functional testing has been successfully completed.</p>

                    <li><strong>Level 3: System Testing</strong></li>
                    <p>System testing evaluates the entire working of the software against specified requirements. It
                        encompasses testing both the functional and non-functional aspects of the software to ensure its
                        overall compliance with requirements.</p>

                    <li><strong>Level 4: Acceptance Testing</strong></li>
                    <p>Acceptance testing, also known as User Acceptance Testing (UAT), is the final level aimed at
                        assessing whether the software meets specified specifications and requirements. Conducted by the
                        customer before accepting the final product, UAT is typically performed by domain experts to
                        ensure the application aligns with business and real-time scenarios, providing customer
                        satisfaction.</p>
                </ul>
            </div>
        </div>
        <div class="wh">
            <h3>Test Plan</h3>
            <p>A test plan is a comprehensive document detailing the areas and activities of software testing. It
                provides an overview of the test strategy, objectives, schedule, required resources (human, software,
                and hardware), estimation, and deliverables. The testing manager fully monitors and controls the test
                plan, which is prepared collaboratively by the Test Lead (60%), Test Manager (20%), and the test
                engineer (20%).</p>
            <div class="in">
                <h3>Types of Test Plan</h3>
                <ul>
                    <li><strong>Master Test Plan</strong>: This plan encompasses multiple testing levels and includes a
                        complete test strategy.</li>
                    <li><strong>Phase Test Plan</strong>: Focused on a specific testing phase, addressing aspects like
                        tools
                        and test cases.</li>
                    <li><strong>Specific Test Plans</strong>: Tailored for major types of testing such as security,
                        load,
                        and performance testing, emphasizing non-functional testing.</li>
                </ul>
            </div>
            <div class="in">
                <h3>Test Plan Components or Attributes</h3>
                <ul>
                    <li><strong>Objectives</strong>: Describes the aim of the application, including modules, features,
                        and
                        test data.</li>
                    <li><strong>Scope</strong>: Outlines what needs rigorous testing (In scope) and what doesn't (Out
                        scope).</li>
                    <li><strong>Test Methodology</strong>: Defines different testing types, like functional and
                        integration
                        testing.</li>
                    <li><strong>Approach</strong>: Describes the flow of the application during testing for current and
                        future reference.</li>
                    <li><strong>Assumption</strong>: Contains information about potential issues during testing.</li>
                    <li><strong>Risk</strong>: Identifies challenges and potential risks during the testing process.
                    </li>
                    <li><strong>Mitigation Plan or Contingency Plan</strong>: Outlines backup plans to overcome risks or
                        issues.</li>
                    <li><strong>Role & Responsibility</strong>: Defines the roles and responsibilities of the testing
                        team
                        members.</li>
                    <li><strong>Schedule</strong>: Specifies timing and deadlines for each testing activity.</li>
                    <li><strong>Defect Tracking</strong>: Discusses how defects are tracked, communicated, and their
                        priorities.</li>
                    <li><strong>Test Environments</strong>: Details the software and hardware configurations used for
                        testing.</li>
                    <li><strong>Entry and Exit Criteria</strong>: Specifies conditions for starting and stopping the
                        testing
                        process.</li>
                    <li><strong>Test Automation</strong>: Decides which features to automate, the automation tool, and
                        framework to be used.</li>
                    <li><strong>Effort Estimation</strong>: Plans the effort required from each team member.</li>
                    <li><strong>Test Deliverable</strong>: Lists the documents handed over to the customer, including
                        test
                        plan, test cases, scripts, etc.</li>
                    <li><strong>Template</strong>: Provides templates for consistent document use during testing, such
                        as
                        test cases and bug reports.</li>
                </ul>
            </div>
            <div class="in">
                <h3>Importance of Test Plan</h3>
                <ul>
                    <li>The test plan serves as a rulebook, guiding thinking and ensuring adherence to a predefined
                        strategy.</li>
                    <li>It helps determine the necessary efforts for validating the quality of the software application
                        under test.</li>
                    <li>Key stakeholders outside the testing team, such as business managers and customers, can
                        understand
                        test details through the plan.</li>
                    <li>Important aspects like test schedule, strategy, and scope documented in the test plan are
                        valuable
                        for review and reuse in similar projects.</li>
                </ul>
            </div>

            <div class="in">
                <h3>Test Case Specification</h3>
                <p>A test case is a set of conditions used by a tester to determine whether software is functioning
                    according to customer requirements. The design of a test case includes preconditions, case name,
                    input
                    conditions, and expected results. Test cases are detailed documents containing all possible inputs
                    and
                    navigation steps, usually written while developers are busy writing code.</p>

                <p>The Test Case Specification document, the final publication by the testing team, follows a specific
                    format:</p>

                <h4>a) Objectives</h4>
                <p>The purpose of testing is detailed here, including relevant and crucial information.</p>

                <h4>b) Preconditions</h4>
                <p>This section lists the items and documents required before executing a particular test case. It
                    describes
                    features and conditions necessary for testing.</p>

                <h4>c) Input Specifications</h4>
                <p>Once preconditions are defined, the team collaborates to identify all inputs required for executing
                    the
                    test cases.</p>

                <h4>d) Output Specification</h4>
                <p>This includes all outputs necessary to verify the test case.</p>

                <h4>e) Post Conditions</h4>
                <p>Defines various environmental requirements, identifies any special requirements and constraints on
                    the
                    test cases, and consists of details like:</p>

                <ul>
                    <li><strong>Hardware:</strong> Configuration and limitations.</li>
                    <li><strong>Software:</strong> System, operating system, tools, etc.</li>
                    <li><strong>Procedural Requirements:</strong> Special setup, output location & identification,
                        operations interventions, etc.</li>
                </ul>
            </div>
        </div>
        <div class="wh">
            <h2>Reliability Assessment</h2>
            <p>One of the essential features of software development is reliability, ensuring that a software product
                performs consistently under various environmental conditions. Reliability testing aims to verify whether
                the software can achieve failure-free operation for a specific period in a given technological
                environment.</p>
            <div class="in">
                <h3>13.1 Types of Reliability Testing</h3>
                <p>In software testing, reliability testing is categorized into three types:</p>

                <h4>a. Feature Testing</h4>
                <p>The main goal of feature testing is to assess the attributes and functionality of the software
                    product,
                    ensuring system correctness. Characteristics checked in feature testing include:</p>
                <ul>
                    <li>All functions need to be executed at least once by the team.</li>
                    <li>Each function must be implemented completely.</li>
                    <li>The team should check the proper implementation of each operation.</li>
                    <li>Communication between two or more functions has to be validated.</li>
                </ul>

                <h4>b. Regression Testing</h4>
                <p>Regression testing involves re-testing parts of the application that remain unchanged. It ensures
                    that
                    the code still functions correctly even with changes implemented during bug fixing. This type of
                    testing
                    helps identify new errors that may occur due to changes.</p>

                <h4>c. Load Testing</h4>
                <p>Load testing assesses the functionality of the software under conditions of maximum workload. It is
                    performed by applying a load, either less than or equal to the desired load. In load testing, "load"
                    refers to the number of users using the application simultaneously or sending requests to the server
                    at
                    a given time.</p>
            </div>
        </div>
        <div class="wh">
            <h2>Software Testing Strategies</h2>
            <p>Software testing involves various strategies in software engineering to ensure the reliability and
                effectiveness of a software product. Here are some important testing strategies:</p>

            <div class="in">
                <h3>Unit Testing</h3>
                <p>This basic software testing approach is followed by the programmer to test individual units of the
                    program. It helps developers determine whether each unit of code is working properly or not.</p>
            </div>

            <div class="in">
                <h3>Integration Testing</h3>
                <p>Integration testing focuses on the construction and design of the software. The goal is to ensure
                    that
                    integrated units work seamlessly without errors. This testing strategy verifies the interaction and
                    collaboration between different units of the software.</p>
            </div>

            <div class="in">
                <h3>System Testing</h3>
                <p>In system testing, the software is compiled as a whole and then tested comprehensively. This testing
                    strategy checks the overall functionality, security, portability, and other aspects of the software.
                    It
                    evaluates how the entire system behaves and performs when all components are integrated.</p>
            </div>
        </div>
        <div class="wh">
            <h2>Verification & Validation</h2>
            <p>Software testing plays a pivotal role in the broader context of verification and validation (V&V).
                Verification ensures that the software correctly implements specific functions, while validation ensures
                alignment with customer requirements.</p>

            <p>Boehm [Boe81] succinctly describes V&V:</p>
            <ul>
                <li><strong>Verification:</strong> “Are we building the product right?”</li>
                <li><strong>Validation:</strong> “Are we building the right product?”</li>
            </ul>

            <p>V&V covers various Software Quality Assurance (SQA) activities, such as technical reviews, audits,
                performance monitoring, simulation, feasibility studies, documentation reviews, and testing (e.g.,
                development, usability, acceptance).</p>

            <div class="in">
                <h3>Verification Testing</h3>
                <p>Verification testing involves static activities like business and system requirement checks, design
                    reviews, and code walkthroughs. It ensures that the development process is creating the right
                    product and meets specified client requirements.</p>

            </div>
            <div class="in">
                <h3>Validation Testing</h3>
                <p>Validation testing assesses both functional (Unit Testing, Integration Testing, System Testing) and
                    non-functional (User Acceptance Testing) aspects of the software. It is a dynamic process ensuring
                    that the product has been developed correctly and meets the client's business needs.</p>
            </div>
            <div class="in">
                <h3>Difference between Verification and Validation Testing (Continued)</h3>
                <ul>
                    <li><strong>Execution:</strong>
                        <ul>
                            <li>Verification testing does not involve the execution of code; it focuses on ensuring the
                                development process aligns with requirements.</li>
                            <li>In validation testing, the code is executed to ensure the software meets specified
                                business requirements.</li>
                        </ul>
                    </li>
                    <li><strong>Bug Identification:</strong>
                        <ul>
                            <li>Verification testing is effective in identifying bugs early in the development phase.
                            </li>
                            <li>Validation testing is crucial for catching bugs that may not be discovered in the
                                verification process.</li>
                        </ul>
                    </li>
                    <li><strong>Responsible Team:</strong>
                        <ul>
                            <li>Verification testing is typically executed by the Quality Assurance team, ensuring
                                adherence to customer requirements during development.</li>
                            <li>Validation testing is conducted by the testing team, focusing on the end product's
                                functionality and user acceptance.</li>
                        </ul>
                    </li>
                    <li><strong>Sequence:</strong>
                        <ul>
                            <li>Verification is performed before validation testing in the software development life
                                cycle.</li>
                            <li>After verification testing, the validation testing phase takes place.</li>
                        </ul>
                    </li>
                    <li><strong>Verification Testing Focus:</strong>
                        <ul>
                            <li>Verification verifies that the inputs lead to the expected outputs.</li>
                            <li>Validation ensures that the user accepts and approves the final product.</li>
                        </ul>
                    </li>
                    <!-- Additional points... -->
                </ul>
                <!-- Additional explanation... -->
                </p>
            </div>
        </div>
        <div class="wh">
            <h2>Unit Testing</h2>
            <p>
                A software product undergoes testing in three stages:
            <ul>
                <li><strong>Unit Testing</strong></li>
                <li><strong>Integration Testing</strong></li>
                <li><strong>System Testing</strong></li>
            </ul>
            During unit testing, individual functions or units of a program are tested. Once all units are individually
            tested, they are incrementally integrated and tested at each integration step. Finally, the fully integrated
            system undergoes system testing.
            Unit testing occurs after coding a module is complete, and syntax errors are resolved. Typically, the module
            coder conducts this activity, preparing test cases and the testing environment.
            </p>
            <p><strong>Driver and Stub Modules:</strong></p>
            <p>
                To test a single module, a complete testing environment is required for module execution, including:
            <ul>
                <li>Procedures from other modules that the tested module calls.</li>
                <li>Non-local data structures.</li>
                <li>A procedure to call module functions with appropriate parameters.</li>
            </ul>
            Stubs and drivers are designed to provide the necessary environment for module testing. Their roles are
            illustrated in the Figure below.
            </p>
            <figure>
                <img src="../../images/unitesting1.svg" alt="Unit testing with the help of driver and stub modules"
                    class="wb">
                <figcaption>Unit testing with the help of driver and stub modules.</figcaption>
            </figure>
            <p>
                <strong>Stub:</strong> A stub module consists of several stub procedures called by the module under
                test.
            </p>
            <p>
                <strong>Driver:</strong> A driver module contains non-local (global) data structures accessed by the
                module under test. It also includes code to call different functions of the unit under test with
                appropriate parameter values for testing.
            </p>
            <div class="in">
                <h3>Integration Testing</h3>
                <p>
                    Integration testing is the second level of the software testing process that follows unit testing.
                    This testing phase involves testing units or individual components of the software in a group. The
                    primary focus is on exposing defects during the interaction between integrated components or units.
                </p>
                <p>
                    When all components or modules work independently, the data flow between dependent modules needs to
                    be verified, known as integration testing. The main objective is to test module interfaces, ensuring
                    error-free parameter passing when one module invokes another module's functionality.
                </p>
                <p>
                    During integration testing, different system modules are integrated systematically using an
                    integration plan that specifies steps and the order of module combinations. After each integration
                    step, the partially integrated system undergoes testing. Various approaches can be used for
                    integration testing:
                </p>
                <ul>
                    <li><strong>Big-bang approach to integration testing:</strong> Integrates all modules in a single
                        step, suitable for small systems, but challenging for error localization in large systems.</li>
                    <li><strong>Bottom-up approach to integration testing:</strong> Integrates and tests modules for
                        each subsystem first, then tests the subsystem, allowing testing of disjoint subsystems
                        simultaneously.</li>
                    <li><strong>Top-down approach to integration testing:</strong> Starts with testing the root module,
                        gradually integrating and testing modules at lower layers, requiring only stubs, but may face
                        challenges in exercising top-level routines without lower-level routines.</li>
                    <li><strong>Mixed approach to integration testing:</strong> A combination of top-down and bottom-up
                        approaches, addressing the shortcomings of each. Testing can start as modules become available
                        after unit testing, making it a commonly used integration testing approach. Both stubs and
                        drivers are required in this approach.</li>
                </ul>
            </div>
            <div class="in">
                <h3>System Testing and Debugging</h3>
                <p>
                    There are two widely used methods for software testing: <strong>White box testing</strong>, which
                    uses internal coding to design test cases, and <strong>black box testing</strong>, which uses GUI or
                    user perspective to develop test cases.
                </p>
                <ul>
                    <li><strong>White box testing</strong></li>
                    <li><strong>Black box testing</strong></li>
                </ul>
                <p>
                    System testing falls under <strong>Black box testing</strong> as it involves testing the external
                    workings of the software, following the user's perspective to identify minor defects.
                </p>
                <p>
                    After all the units of a program have been integrated and tested, system testing begins. The
                    procedures for system testing are the same for both object-oriented and procedural programs. System
                    test cases are designed based on the Software Requirements Specification (SRS) document.
                </p>
                <p>
                    There are three main types of system testing:
                </p>
                <ol>
                    <li><strong>Alpha Testing:</strong> Conducted by the test team within the developing organization.
                    </li>
                    <li><strong>Beta Testing:</strong> Performed by a select group of friendly customers.</li>
                    <li><strong>Acceptance Testing:</strong> Carried out by the customer to determine whether to accept
                        the delivery of the system.</li>
                </ol>
                <p>
                    In different types of system tests, the test cases may be the same, but the difference lies in who
                    designs and carries out the testing.
                </p>
                <p>
                    System test cases can be classified into functionality and performance test cases.
                </p>
                <h3>Smoke Testing</h3>
                <p>
                    Before system testing, <strong>smoke testing</strong> is performed to check whether the main
                    functionalities of the software are working properly. For example, in a library automation system,
                    smoke tests may verify if books can be created and deleted, if member records can be created and
                    deleted, and if books can be loaned and returned.
                </p>

                <h3>Performance Testing</h3>
                <p>
                    Performance testing checks the non-functional requirements of the system. Various types of
                    performance testing are considered as black-box tests.
                </p>

                <ol>
                    <li>
                        <strong>[1] Stress Testing:</strong>
                        Also known as endurance (strength) testing, it imposes abnormal and illegal input conditions,
                        testing factors like input data volume, input data rate, processing time, memory utilization
                        beyond designed capacity.
                    </li>
                    <li>
                        <strong>[2] Volume Testing:</strong>
                        Checks whether data structures (buffers, arrays, queues, stacks, etc.) can handle extraordinary
                        situations.
                    </li>
                    <li>
                        <strong>[3] Configuration Testing:</strong>
                        Tests system behavior in various hardware and software configurations specified in the
                        requirements.
                    </li>
                    <li>
                        <strong>[4] Compatibility Testing:</strong>
                        Required when the system interfaces with external systems, checking if interfaces perform as
                        required, testing speed and accuracy of data retrieval.
                    </li>
                    <li>
                        <strong>[5] Regression Testing:</strong>
                        Required when software is maintained to fix bugs or enhance functionality and performance.
                    </li>
                    <li>
                        <strong>[6] Recovery Testing:</strong>
                        Tests the system's response to faults, loss of power, devices, services, data, etc., checking if
                        the system recovers satisfactorily.
                    </li>
                    <li>
                        <strong>[7] Maintenance Testing:</strong>
                        Addresses testing diagnostic programs and other procedures required to help maintain the system.
                    </li>
                    <li>
                        <strong>[8] Documentation Testing:</strong>
                        Checks whether the required user manual, maintenance manuals, and technical manuals exist and
                        are consistent.
                    </li>
                    <li>
                        <strong>[9] Usability Testing:</strong>
                        Concerns checking the user interface to see if it meets all user requirements, testing display
                        screens, messages, report formats, and other aspects related to user interface requirements.
                    </li>
                    <li>
                        <strong>[10] Security Testing:</strong>
                        Tests whether the system is foolproof against security attacks such as intrusion by hackers.
                    </li>
                </ol>
            </div>
        </div>
        <div class="wh">
            <h2>Software Maintenance</h2>
            <ul>
                <li><strong>Definition:</strong> Software maintenance involves making changes to a software product
                    after it has been delivered to the customer.</li>
                <li><strong>Necessity:</strong> Maintenance is expected for various reasons such as correcting errors,
                    enhancing features, and adapting to new platforms.</li>
                <li><strong>Comparison to Physical Products:</strong> Unlike physical products that may need maintenance
                    due to wear and tear, software products require maintenance for different reasons.</li>
            </ul>
            <div class="in">
                <h3>Characteristics of Software Maintenance</h3>
                <ul>
                    <li><strong>Importance:</strong> Software maintenance is crucial for organizations due to reasons
                        like
                        hardware aging, software product immortality, and the need to adapt to newer platforms.</li>
                    <li><strong>Platform Changes:</strong> When there are changes in the hardware platform, maintenance
                        becomes necessary, requiring rework on code.</li>
                </ul>
            </div>
            <div class="in">
                <h3>Types of Software Maintenance</h3>
                <ul>
                    <li><strong>Corrective Maintenance:</strong> Addresses failures observed during system use.</li>
                    <li><strong>Adaptive Maintenance:</strong> Needed when the software product must run on new
                        platforms,
                        operating systems, or interface with new hardware or software.</li>
                    <li><strong>Perfective Maintenance:</strong> Required to support new features, meet customer
                        demands, or
                        enhance system performance.</li>
                </ul>
            </div>
            <div class="in">
                <h3>Characteristics of Software Evolution</h3>
                <ul>
                    <li><strong>Lehman’s First Law:</strong> "A software product must change continually or become
                        progressively less useful."</li>
                    <li><strong>Lehman’s Second Law:</strong> "The structure of a program tends to degrade as more and
                        more
                        maintenance is carried out on it."</li>
                    <li><strong>Lehman’s Third Law:</strong> "The rate at which code is written or modified is
                        approximately
                        the same during development and maintenance."</li>
                </ul>
            </div>
            <div class="in">

                <h3>19.4 Special Problems Associated with Software Maintenance</h3>
                <ul>
                    <li><strong>Ad Hoc Techniques:</strong> Maintenance work is often carried out using ad hoc
                        techniques
                        due to neglect in software engineering practices.</li>
                    <li><strong>Poor Image:</strong> Software maintenance has a poor image in the industry, and
                        organizations may not prioritize hiring bright engineers for maintenance work.</li>
                    <li><strong>Challenges:</strong> Despite its poor image, maintenance work can be more challenging
                        than
                        development, involving understanding and modifying someone else's work.</li>
                </ul>
            </div>
        </div>
    </div>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script src="../../../../public/main.js"></script>
</body>

</html>