<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Programming Model (8085)</title>
    <link rel="stylesheet" href="../../../../public/style.css">
    <link rel="icon" href="../../../../public/logo/favicon_io/favicon.ico">
    <link rel="stylesheet" id="highlightStylesheet"
        href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/tomorrow-night-blue.min.css">
</head>

<body class="bg-c">
    <div id="mySidepanel" class="sidepanel">
        <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">×</a>
        <a href="../index.html" class="home">back</a>
        <div class="fix-column-links">
            <a href="#t1" class="link">Intro to 8085 Programming model</a>
            <a href="#t2" class="link">Flag Register</a>
            <a href="#t3" class="link">Memory Mappen I/O and Peripheral Mapped I/O</a>
            <a href="#t4" class="link">Machine Cycle</a>
            <div class="botbut">
                <a href="../unit3/index.html" class="link">Next Topic &rarr;</a>
                <a href="../unit1/index.html" class="link">&larr; Previous Topic</a>
            </div>
        </div>
    </div>
    <div id="navbar" class="grad">
        <div>
            <div class="openbtn" onclick="openNav()">
                <div id="nav-icon1" for="nav-menu1">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </div>
        </div>
        <div>
            <h2>Programming Model (8085)</h2>
        </div>
    </div>
    <div class="content-box">
        <h1>Programming Model (8085)</h1>
        <div id="t1" class="wh">
            <h2>Introduction to 8085 Programming Model</h2>
            <p>The 8085 programming model serves as the foundation for developing assembly language programs for the
                8085 microprocessor. This model defines the architecture and organization of key elements that
                contribute to the execution of instructions and data manipulation.</p>
            <ul>
                <li>Utilizing the 8085 programming model is essential for crafting efficient programs as the programming
                    model provides a structured framework for organizing and manipulating data, allowing programmers to
                    implement logical and arithmetic operations effectively.</li>
                <li>The programming model of 8085 provides crucial information necessary for writing assembly language
                    programs.</li>
                <li>This model comprises six registers, including one accumulator, and one flag register.</li>
                <li>It features two 16-bit registers for addressing: the stack pointer and the program counter.</li>
            </ul>
            <img src="../../images/mp5.svg" alt="" class="wb">
            <ul>
                <li><strong>General-Purpose Registers:</strong> The 8085 microprocessor includes six 8-bit
                    general-purpose registers – B, C, D, E, H, and L. These registers can be paired up to form three
                    16-bit register pairs: (B, C), (D, E), and (H, L). This allows the storage of data larger than 8
                    bits by combining the values of two registers.</li>
                <li><strong>Special-Purpose Registers:</strong>
                    <ul>
                        <li><strong>A (Accumulator):</strong> The accumulator is a crucial register where all arithmetic
                            and logical operations take place. It serves as the default location for storing one of the
                            operands during these operations, and the result is also stored in the accumulator.</li>
                        <li><strong>SP (Stack Pointer):</strong> The stack pointer is a 16-bit register that holds the
                            address of the top of the stack. After each push or pop operation, the stack pointer's value
                            is automatically updated, facilitating efficient stack management.</li>
                        <li><strong>PC (Program Counter):</strong> The program counter is another 16-bit register that
                            holds the address of the next instruction to be fetched from memory. As each instruction is
                            fetched, the program counter's value is automatically incremented by 1, ensuring sequential
                            execution of instructions.</li>
                    </ul>
                </li>
            </ul>
        </div>
        <div id="t2" class="wh">
            <h2>Flag Register</h2>
            <p>The flag register is a vital component in the 8085 programming model, providing information about the
                status and conditions of the processor.</p>
            <ul>
                <li>The flag register consists of five flip-flops at positions D0, D2, D4, D6, and D7. Each flip-flop
                    can either be set (1) or reset (0), indicating specific conditions or states.</li>
            </ul>
            <img src="../../images/mp6.svg" alt="" class="wb">
            <ul>
                <li><strong>S (Sign Flag):</strong> Indicates the sign of the result in the accumulator.
                    <ul>
                        <li>If 1, the answer in the accumulator is negative.</li>
                        <li>If 0, the number in the accumulator is positive.</li>
                    </ul>
                </li>
                <li><strong>Z (Zero Flag):</strong> Identifies whether the answer in the accumulator is zero or
                    non-zero.
                    <ul>
                        <li>If 1, the answer in the accumulator is 0.</li>
                        <li>If 0, the answer in the accumulator is non-zero.</li>
                    </ul>
                </li>
                <li><strong>AC (Auxiliary Carry Flag):</strong> Reflects the presence of an auxiliary carry in
                    intermediate positions during arithmetic operations. It works in conjunction with the Carry Flag
                    (CY), which indicates the final carry.
                    <ul>
                        <li>If 1, there is an auxiliary carry.</li>
                        <li>If 0, there is no intermediate carry.</li>
                    </ul>
                </li>
                <li><strong>P (Parity Flag):</strong> Checks for parity, where odd parity has an odd number of 1s, and
                    even parity has an even number of 1s.
                    <ul>
                        <li>If 1, the binary representation has even parity (e.g., 1010).</li>
                        <li>If 0, the binary representation has odd parity (e.g., 11001).</li>
                    </ul>
                </li>
                <li><strong>CY (Carry Flag):</strong> Indicates the final carry resulting from arithmetic operations.
                    <ul>
                        <li>If 1, there is a final carry.</li>
                        <li>If 0, there is no final carry.</li>
                    </ul>
                </li>
            </ul>
            <div class="in">
                <p><strong>Numerical 1: <br> Assume A (Accumulator) = 88H & B = 99H <br>determine the status of all
                        flags and
                        accumulator content when following 8085 instruction is executed: Add B (A &larr; A +
                        B).</strong></p>
                <img src="../../images/mp12.svg" alt="" class="wb">
            </div>
            <div class="in">
                <p><strong>Numerical 2: <br> A = 13H and B = 24H <br>determine the status of all flags when following
                        8085 instruction is executed: SUB B (A &larr; A - B).</strong></p>
                <img src="../../images/mp13.svg" alt="" class="wb">
            </div>
        </div>
        <div id="t3" class="wh">
            <h2>Memory Mapped I/O and Peripheral Mapped I/O in 8085 Microprocessor</h2>
            <p>In the world of microprocessor architecture, efficient communication between the processor and external
                devices is essential for system functionality. Two key concepts that facilitate this communication in
                the 8085 microprocessor are memory mapped I/O and peripheral mapped I/O. These techniques play a crucial
                role in interfacing the microprocessor with memory devices, input/output (I/O) devices, and other
                peripherals. Memory mapped I/O involves treating I/O devices as if they were memory locations,
                simplifying access through standard memory read and write instructions. On the other hand, peripheral
                mapped I/O assigns specific addresses to I/O ports separate from the memory address space, requiring
                dedicated I/O instructions for communication. Understanding these concepts is fundamental for designing
                efficient systems and programming interfaces in 8085-based applications.</p>
            <div class="in">
                <h3>Memory Mapped I/O</h3>
                <ul>
                    <li>Definition: Memory mapped I/O is a technique where the microprocessor treats I/O devices as if
                        they were memory locations. This means that I/O devices are assigned specific memory addresses,
                        and accessing these addresses allows the microprocessor to communicate with the devices.</li>
                    <li>Usage: In the 8085 microprocessor, memory mapped I/O is used to access I/O devices by mapping
                        them to specific memory addresses. This simplifies programming as I/O operations are performed
                        using standard memory read and write instructions.</li>
                    <li>Addressing: Memory mapped I/O uses memory addresses to access I/O devices, making them appear as
                        part of the memory address space.</li>
                    <li>Example: Accessing an input device (e.g., keyboard) or an output device (e.g., display) through
                        memory addresses mapped to specific I/O ports.</li>
                </ul>
                <p><strong>Example:</strong></p>
                <p>Reading from an input device mapped to a memory address:</p>
                <pre>
                        <code>
MOV A, M  ; Move data from memory (input device address) to accumulator
                        </code>
                    </pre>
                <p>Writing to an output device mapped to a memory address:</p>
                <pre>
                        <code>
MOV M, A  ; Move data from accumulator to memory (output device address)
                        </code>
                    </pre>
            </div>
            <div class="in">
                <h3>Peripheral Mapped I/O:</h3>
                <ul>
                    <li>Definition: Peripheral mapped I/O involves assigning specific addresses to I/O ports separate
                        from the memory address space. Each I/O port is assigned a unique address, allowing the
                        microprocessor to communicate with external devices connected to these ports.</li>
                    <li>Usage: In the 8085 microprocessor, peripheral mapped I/O is used to access external devices
                        through dedicated I/O ports. Instructions and signals specific to peripheral devices are
                        utilized for data transfer, control, and communication, enabling seamless interaction between
                        the microprocessor and external hardware components. This method allows the microprocessor to
                        manage input and output operations efficiently, supporting various applications in embedded
                        systems, industrial automation, and computer peripherals interfacing.</li>
                    <li>Addressing: Peripheral mapped I/O uses separate port addresses for each I/O device, distinct
                        from memory addresses.</li>
                    <li>Example: Reading input from a keyboard connected to a specific I/O port address or sending
                        output to a printer connected to another I/O port address.</li>
                </ul>
                <p><strong>Example:</strong></p>
                <p>Reading from an input device connected to an I/O port:</p>
                <pre>
                    <code>
IN 30H  ; Input data from port address 30H into accumulator
                    </code>
                </pre>
                <p>Writing to an output device connected to an I/O port:</p>
                <pre>
                    <code>
OUT 40H  ; Output data from accumulator to port address 40H
                    </code>
                </pre>
            </div>
        </div>
        <div id="t4" class="wh">
            <h2>Machine Cycle</h2>
            <ul>
                <li>The machine cycle refers to the time required to complete one operation of accessing memory or an
                    I/O port,
                    acknowledging an external request, or performing a specific task within the microprocessor.</li>
                <li>Various operations are encompassed within the machine cycle, including:</li>
                <ul>
                    <li><strong>OP Code Fetch:</strong> Fetching the operation code (OP code) from memory to execute an
                        instruction.</li>
                    <li><strong>Memory Read (<u style="text-decoration: overline;">MEMR</u>):</strong> Reading data from
                        a memory
                        location.</li>
                    <li><strong>Memory Write (<u style="text-decoration: overline;">MEMW</u>):</strong> Writing data to
                        a memory
                        location.</li>
                    <li><strong>I/O Read:</strong> Reading data from an input/output (I/O) port.</li>
                    <li><strong>I/O Write:</strong> Writing data to an I/O port.</li>
                    <li><strong>Interrupt Acknowledge:</strong> Acknowledging an interrupt request from external
                        devices.</li>
                    <li><strong>Control Signals:</strong> Generating and managing control signals such as clock pulses,
                        enable signals,
                        and timing signals.</li>
                </ul>
                <li>The machine cycle is crucial in determining the overall performance and efficiency of a
                    microprocessor-based system.
                    It sets the pace for executing instructions, processing data, and handling input/output operations.
                </li>
                <li>A machine cycle is composed of multiple T-states, where a T-state represents a single clock cycle or
                    the time
                    duration of a clock signal.</li>
                <li>Understanding the machine cycle and its components is essential for designing efficient
                    microprocessor systems,
                    optimizing instruction execution, and ensuring accurate timing in data processing and communication.
                </li>
            </ul>
            <img src="../../images/mp14.svg" alt="" class="wb">
            <p><strong>Note:</strong></p>
            <ul>
                <li>All machine cycles such as <u style="text-decoration: overline;">MEMR</u>, <u
                        style="text-decoration: overline;">MEMW</u>,
                    I/O Read, and I/O Write typically require 3 T-states to complete their operations. However, the OP
                    code fetch cycle
                    is an exception, taking 4 T-states to complete.</li>
                <li>The OP code fetch cycle includes an additional T-state for decoding the OP code, extending its
                    duration to 4
                    T-states.</li>
                <li>For example, let's consider the instruction cycle, which encompasses the complete process of
                    fetching an
                    instruction, decoding its OP code, and executing it. This cycle's duration is determined by the
                    number of machine
                    cycles required for the specific instruction.</li>
                <li>During the 4 T-state OP code fetch cycle, the first three T-states are typically used for fetching
                    the
                    instruction's address from memory, and the fourth T-state is dedicated to decoding the OP code
                    retrieved in the
                    previous T-states.</li>
                <li>On the other hand, in a 3 T-state machine cycle such as I/O Read or I/O Write, each T-state is
                    utilized for
                    specific tasks like initiating the I/O operation, transferring data, and completing the operation
                    within the cycle's
                    duration.</li>
            </ul>
            <p><strong>Determine the machine cycles and total T-states required for execution of the following
                    instructions:</strong></p>
            <ul>
                <li>MOV A, B: only op code fetch (4T) (1m cycle) as there is no memory access or additional processing
                    involved. This instruction moves data from register B to register A.</li>
                <li>MOV A, M: Op fetch (4T) + MR (3T) (2m cycle) where MR stands for Memory Read. This instruction
                    involves fetching the op code, then reading data from the memory location addressed by the HL pair
                    and moving it to register A.</li>
                <li>MVI B, 32H: Op fetch (4T) + Data Write (3T) (2m cycle) as it involves fetching the op code and
                    writing immediate data (32H) to register B.</li>
                <li>LXI H, 2050H: Op fetch (4T) + Data Write (3T) (2m cycle) as it involves fetching the op code and
                    loading immediate data (2050H) into the HL pair.</li>
                <li>LDA 300H: Op fetch (4T) + MR (3T) (2m cycle) where MR stands for Memory Read. This instruction
                    involves fetching the op code and loading accumulator A with data from memory address 300H.</li>
                <li>STA 3050H: Op fetch (4T) + MW (3T) (2m cycle) where MW stands for Memory Write. This instruction
                    involves fetching the op code and storing accumulator A data into memory address 3050H.</li>
                <li>IN 00h: Op fetch (4T) + Input (3T) (2m cycle) as it involves fetching the op code and inputting data
                    from input port 00h.</li>
                <li>OUT FFh: Op fetch (4T) + Output (3T) (2m cycle) as it involves fetching the op code and outputting
                    data to output port FFh.</li>
                <li>LDAX B: Op fetch (4T) + MR (3T) (2m cycle) where MR stands for Memory Read. This instruction
                    involves fetching the op code and loading accumulator A with data from the address pointed to by
                    register pair BC.</li>
                <li>STA X D: Op fetch (4T) + MW (3T) (2m cycle) where MW stands for Memory Write. This instruction
                    involves fetching the op code and storing accumulator A data into the address pointed to by register
                    pair XD.</li>
            </ul>
        </div>
    </div>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script src="../../../../public/main.js"></script>
</body>

</html>