<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Overview of the Microsoft .NET Platform</title>
    <link rel="stylesheet" href="../../../../public/style.css">
    <link rel="icon" href="../../../../public/logo/favicon_io/favicon.ico">
    <link rel="stylesheet" id="highlightStylesheet"
        href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/tomorrow-night-blue.min.css">
</head>

<body class="bg-c">
    <div id="mySidepanel" class="sidepanel">
        <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">×</a>
        <a href="../index.html" class="home">back</a>
        <div class="fix-column-links">
            <a href="#" class="link"></a>
            <div class="botbut">
                <a href="../unit2/index.html" class="link">Next Topic &rarr;</a>
            </div>
        </div>
    </div>
    <div id="navbar" class="grad">
        <div>
            <div class="openbtn" onclick="openNav()">
                <div id="nav-icon1" for="nav-menu1">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </div>
        </div>
        <div>
            <h2>Overview of the Microsoft .NET Platform</h2>
        </div>
    </div>
    <div class="content-box">
        <div class="wh">
            <h3>The Problem Before .NET</h3>
            <ul>
                <li>Before .NET, developers faced many challenges when building software. They had to deal with:
                    <ul>
                        <li>Writing different code for different operating systems (Windows, macOS, Linux).</li>
                        <li>Using different programming languages with no easy way to make them work together.</li>
                        <li>Managing DLL Hell, a problem where different applications required different versions of the
                            same shared libraries, leading to conflicts.</li>
                    </ul>
                </li>
            </ul>

            <h3>Solution: Creation of .NET?</h3>
            <ul>
                <li>Microsoft wanted to create a platform that could solve these issues by:
                    <ul>
                        <li>Allowing code to run on multiple platforms (not just Windows).</li>
                        <li>Supporting multiple programming languages in a single environment.</li>
                        <li>Simplifying how applications are developed, deployed, and maintained.</li>
                    </ul>
                </li>
            </ul>
            <p>In the year <strong>2000</strong>, Microsoft introduced the .NET Framework.</p>

            <div class="in">
                <h3>What is .NET?</h3>
                <ul>
                    <li>.NET is a software framework, which is a collection of tools and libraries that help developers
                        build different types of applications (like desktop apps, web apps, and mobile apps).</li>
                    <li>A framework is a collection of technologies integrated together to develop applications that can
                        be executed anywhere.</li>
                </ul>
            </div>

            <div class="in">
                <h3>The Evolution of .NET</h3>
                <ul>
                    <li>Initially, the .NET Framework was designed for Windows-only applications. It included:
                        <ul>
                            <li>A runtime called Common Language Runtime (CLR), which ensured the applications could run
                                efficiently.</li>
                            <li>A large set of libraries to help with tasks like connecting to databases and handling
                                files.</li>
                        </ul>
                    </li>
                    <li>The Shift to .NET Core (2016):
                        <ul>
                            <li>As technology advanced, developers needed a framework that could work on more than just
                                Windows. Microsoft introduced .NET Core in 2016.</li>
                            <li>.NET Core was cross-platform, meaning you could use it to build apps for Windows, Linux,
                                and macOS.</li>
                        </ul>
                    </li>
                    <li>Unified .NET (2020 onwards):
                        <ul>
                            <li>In 2020, Microsoft released .NET 5, a unified version of .NET that merged the best
                                features of both the .NET Framework and .NET Core.</li>
                            <li>Now, developers just refer to it as .NET, which works on all platforms.</li>
                        </ul>
                    </li>
                </ul>
            </div>
            <div class="in">
                <h3>Components Provided by .NET</h3>
                <p>The .NET framework provides two main components:</p>
                <ol>
                    <li><strong>CLR (Common Language Runtime)</strong></li>
                    <li><strong>BCL (Base Class Library)</strong></li>
                </ol>

                <h3>CLR (Common Language Runtime)</h3>
                <ul>
                    <li>The CLR is the core runtime engine in the .NET framework responsible for executing applications.
                    </li>
                    <li>When .NET code is compiled, it is transformed into an Intermediate Language (IL). The CLR takes
                        this IL code and compiles it into native machine code that can be executed by the operating
                        system.
                    <br><img src="../../images/net1.jpeg" alt=""></li>
                    <li>The CLR handles important tasks such as:
                        <ul>
                            <li><strong>Memory Management:</strong> The CLR allocates and deallocates memory for .NET
                                applications through a process called garbage collection.</li>
                            <li><strong>Type Safety:</strong> It ensures that code adheres to strict type safety rules,
                                preventing unsafe operations.</li>
                            <li><strong>Exception Handling:</strong> The CLR provides a unified approach for handling
                                runtime errors across different programming languages in .NET.</li>
                            <li><strong>Security:</strong> It enforces code access security, managing what permissions
                                the application has while running.</li>
                        </ul>
                    </li>
                    <li>In short, the CLR is responsible for managing the execution of programs and providing essential
                        services like memory management and security.</li>
                        <li>In the .NET framework, the code is compiled twice:
                            <ol>
                                <li>First, the source code is compiled by the respective language compiler, which generates
                                    intermediate code known as MSIL (Microsoft Intermediate Language) or IL (Intermediate
                                    Language) or Managed Code.</li>
                                <li>Then, MSIL is converted into native code (code specific to the operating system) using
                                    the CLR.</li>
                            </ol>
                        </li>
                </ul>

                <h3>BCL (Base Class Library)</h3>
                <ul>
                    <li>The BCL is a collection of reusable classes, interfaces, and value types provided by Microsoft,
                        forming the foundation of all .NET applications.</li>
                    <li>It contains predefined classes and functions that provide common functionalities like:
                        <ul>
                            <li><strong>I/O operations:</strong> Handling input and output for file and stream
                                manipulation.</li>
                            <li><strong>Data Structures:</strong> Offering standard data structures such as lists,
                                dictionaries, queues, and more.</li>
                            <li><strong>Networking:</strong> Providing classes to work with network protocols like HTTP
                                and FTP.</li>
                            <li><strong>Threading:</strong> Enabling support for multithreading and asynchronous
                                programming.</li>
                        </ul>
                    </li>
                    <li>The BCL acts as a library of building blocks that developers can use to avoid rewriting common
                        tasks from scratch, ensuring consistency across different applications.</li>
                </ul>

                <h3>How CLR and BCL Work Together</h3>
                <p>The CLR and BCL work in harmony to provide an efficient execution environment for .NET applications:
                </p>
                <ul>
                    <li>When a .NET application is compiled, the IL code references classes from the BCL. The BCL
                        provides all the fundamental functionality needed to perform standard operations such as file
                        handling, data manipulation, and more.</li>
                    <li>The CLR takes this IL code and, at runtime, loads the necessary BCL components needed by the
                        application. For example, if your code uses a `List`, the CLR loads the `List` class from the
                        BCL.</li>
                    <li>The CLR also manages memory allocation and garbage collection for objects created using the BCL
                        types, ensuring that memory is efficiently managed.</li>
                    <li>Additionally, the CLR enforces security and type safety when the application interacts with BCL
                        components, preventing unsafe memory access or unauthorized operations.</li>
                </ul>
                <p>In summary, the BCL provides the necessary libraries for application development, while the CLR
                    handles the runtime execution, memory management, and security, ensuring that the application runs
                    smoothly and securely.</p>

            </div>

            <div class="in">
                <h3>Programming Languages Supported by .NET</h3>
                <p>.NET supports more than 70 programming languages, 9 of which are designed by Microsoft, while the
                    remaining are designed by other vendors.</p>

                <h3>Languages Designed by Microsoft</h3>
                <ol>
                    <li><strong>VB.NET (Visual Basic .NET)</strong> – A high-level programming language that is simple
                        and easy to use, often preferred for developing Windows applications with a graphical user
                        interface.</li>
                    <li><strong>C#.NET (C#)</strong> – A powerful, object-oriented language, widely used for enterprise
                        applications. It combines the ease of Visual Basic with the power of C++ and is the most popular
                        .NET language.</li>
                    <li><strong>Visual C++ .NET</strong> – A version of C++ designed for the .NET platform, offering
                        both object-oriented and low-level programming capabilities, primarily for performance-sensitive
                        applications.</li>
                    <li><strong>F#.NET</strong> – A functional-first programming language, known for its concise syntax
                        and strong support for parallel programming. It’s great for mathematical computations, data
                        analysis, and financial modeling.</li>
                    <li><strong>JScript.NET</strong> – A version of JavaScript optimized for server-side programming and
                        integration with the .NET framework. It is rarely used in modern applications.</li>
                    <li><strong>J#.NET (JSharp)</strong> – A language that was designed to help Java developers
                        transition to the .NET framework. It allows developers to use Java syntax while utilizing .NET's
                        capabilities, but it has been deprecated.</li>
                    <li><strong>PowerShell</strong> – A task automation and configuration management framework, built on
                        .NET. It’s mostly used for automating tasks in IT environments and managing systems.</li>
                    <li><strong>IronPython</strong> – A version of Python that is integrated with the .NET framework. It
                        allows Python developers to take advantage of the .NET libraries and runtime.</li>
                    <li><strong>IronRuby</strong> – A version of the Ruby programming language that runs on the .NET
                        framework. Like IronPython, it allows Ruby developers to integrate with .NET libraries and
                        components.</li>
                </ol>
            </div>
            <div class="in">
                <h3>Understanding the .NET Platform</h3>
                <p>The .NET platform is a software development framework created by Microsoft. It provides a range of
                    tools and services for building and running applications. To understand how the .NET platform works,
                    it's important to explore some of its key components: the Common Language Runtime (CLR), Common Type
                    System (CTS), Common Language Specification (CLS), and Common Intermediate Language (CIL). These
                    elements work together to ensure that applications run smoothly across different languages and
                    platforms. Additionally, the .NET platform supports platform independence, allowing applications to
                    run on various operating systems.</p>

                <h3>1. Common Language Runtime (CLR)</h3>
                <p>The CLR is the heart of the .NET platform. It provides a managed environment where .NET applications
                    are executed. The CLR handles essential tasks such as memory management, security, code
                    verification, and exception handling. It also enables different .NET languages to work together
                    seamlessly. When you run a .NET application, the CLR converts Intermediate Language (IL) code into
                    machine code that the specific platform can execute.</p>

                <h3>2. Common Type System (CTS)</h3>
                <p>The CTS is a crucial part of the .NET platform that defines a common set of data types that all .NET
                    languages can use. It ensures that these types are consistent and compatible across different
                    languages. By following CTS, developers can create components that work together smoothly,
                    regardless of the language used to create them. The CTS helps in defining how types are represented
                    and used in memory.</p>

                <h3>3. Common Language Specification (CLS)</h3>
                <p>The CLS is a subset of the CTS that outlines a set of rules and guidelines that .NET languages must
                    follow to ensure interoperability. It defines a common set of features that all .NET languages
                    should support. By adhering to CLS, developers can create components that are compatible with any
                    .NET language, making it easier to integrate and use components across different languages.</p>

                <h3>4. Common Intermediate Language (CIL)</h3>
                <p>CIL, also known as Intermediate Language (IL), is the intermediate code generated by .NET compilers.
                    It is a platform-independent bytecode that the CLR can understand. When a .NET application is
                    compiled, its source code is transformed into CIL. At runtime, the CLR performs Just-In-Time (JIT)
                    compilation, converting CIL into native machine code specific to the target platform. This allows
                    .NET applications to be decoupled from specific hardware and operating systems.</p>

                <h3>5. Platform Independence in .NET</h3>
                <p>Platform independence in .NET means that applications can run on different operating systems and
                    hardware without needing to change the application's code. This is achieved through the use of CIL
                    and the CLR. CIL serves as a platform-independent bytecode, while the CLR performs JIT compilation
                    to convert CIL into machine code for the specific platform. Additionally, cross-platform libraries
                    like ASP.NET Core and Xamarin help developers create applications that run on various platforms,
                    such as Windows, macOS, Linux, iOS, and Android.</p>
            </div>

            <div class="in">
                <h3>Managed Code and Unmanaged Code</h3>

                <p>When working with .NET, it's crucial to understand the difference between <strong>managed
                        code</strong> and <strong>unmanaged code</strong>. This distinction plays a big role in how code
                    is executed and how resources are managed within the system.</p>

                <p><strong>Why is this important?</strong></p>
                <p>In .NET, applications often need to handle memory, exceptions, and resources efficiently. Managed
                    code provides a way to let the .NET runtime (CLR) handle these tasks, freeing developers from manual
                    memory management and reducing the risk of common errors. However, not all code runs under the
                    control of the .NET runtime. Some older or low-level code, known as unmanaged code, operates outside
                    the CLR and interacts directly with the operating system. Knowing when and why each type of code is
                    used helps developers work more effectively and securely.</p>

                <h4><strong>Managed Code</strong></h4>
                <ul>
                    <li>Managed code is the code that runs under the control of the <strong>Common Language Runtime
                            (CLR)</strong>, the core runtime of the .NET framework.</li>
                    <li>Code written in languages like C# and VB.NET is automatically managed by the CLR. This means
                        that the runtime handles critical services like:
                        <ul>
                            <li><strong>Garbage collection</strong>: Automatically frees up memory by removing unused
                                objects.</li>
                            <li><strong>Exception handling</strong>: Ensures that errors are handled safely and
                                consistently.</li>
                            <li><strong>Type safety</strong>: Prevents the use of incompatible data types, ensuring more
                                stable and predictable code.</li>
                            <li><strong>Security enforcement</strong>: Manages access to system resources, ensuring that
                                the code cannot perform unauthorized actions.</li>
                        </ul>
                    </li>
                    <li>One of the advantages of managed code is that developers don’t have to worry about low-level
                        tasks like memory management or system-level errors. The CLR takes care of these automatically.
                    </li>
                    <li>Examples of managed code: C#.NET, VB.NET.</li>
                </ul>

                <h4><strong>Unmanaged Code</strong></h4>
                <ul>
                    <li>Unmanaged code runs directly on the operating system without the supervision of the CLR.</li>
                    <li>This code is usually written in languages like C or C++, where the developer has to handle
                        memory management, errors, and system-level tasks manually.</li>
                    <li>Unmanaged code is compiled directly to machine code, making it faster in some cases, but also
                        more error-prone because there is no runtime safety net (like garbage collection or type
                        safety).</li>
                    <li>Since unmanaged code interacts directly with the operating system, it is more platform-dependent
                        and must be recompiled for different system architectures.</li>
                    <li>Examples of unmanaged code: C, C++.</li>
                </ul>

                <h4><strong>Why Use Both Managed and Unmanaged Code?</strong></h4>
                <p>In modern applications, it is common to use both managed and unmanaged code together. For example,
                    you may write most of your application in managed C#, but use unmanaged C++ for performance-critical
                    components. .NET provides ways to <strong>interop</strong> with unmanaged code using techniques like
                    P/Invoke (Platform Invocation Services), allowing managed code to call unmanaged functions when
                    necessary.</p>
            </div>
        </div>
        <div class="wh">
            <h2>Understanding the Core: Assemblies (DLL HELL, Metadata, Namespace & Versioning)</h2>
            <p>When building applications in .NET, it's important to understand how assemblies work. Assemblies are the
                building blocks of .NET applications and contain code, resources, and metadata that define an
                application. Along with this, there are a few critical issues like the infamous "DLL Hell," which was a
                major problem before the introduction of the .NET framework. In this section, we’ll explore assemblies
                in detail, their components, and how .NET handles challenges like versioning, namespaces, and metadata.
            </p>
            <div class="in">
                <h3>1. What is an Assembly?</h3>
                <p>An <strong>assembly</strong> in .NET is a building block of an application. It's a compiled code
                    library
                    used for deployment, versioning, and security. It contains both the code (in the form of compiled
                    intermediate language) and the metadata that describes the code, making it a fundamental part of the
                    .NET architecture.</p>

                <p>Assemblies can be in two forms:</p>
                <ul>
                    <li><strong>Executable files (.exe)</strong>: These are application files that run standalone.</li>
                    <li><strong>Dynamic Link Libraries (.dll)</strong>: These are libraries that contain code which
                        other
                        applications or libraries can use.</li>
                </ul>

            </div>
            <div class="in">
                <h3>2. DLL Hell Problem</h3>
                <p>Before .NET, developers faced a common issue known as the <strong>DLL Hell problem</strong>. This
                    problem
                    occurred because different applications often used shared libraries (DLL files) with the same name
                    but
                    different versions, leading to conflicts.</p>

                <ul>
                    <li>Imagine you install Application A that uses <em>DLL_A</em> version 1.0.</li>
                    <li>Then, you install Application B that also uses <em>DLL_A</em> but version 2.0.</li>
                    <li>Since both applications are using a DLL with the same name, the system would overwrite the old
                        version (1.0) with the new one (2.0).</li>
                    <li>This would cause Application A to break because it was designed to work with version 1.0, but
                        now
                        it’s using version 2.0, which might be incompatible.</li>
                </ul>

                <p>This conflict where DLLs get overwritten and cause applications to fail is known as <strong>DLL
                        Hell</strong>. It made maintaining applications very difficult.</p>
                <div class="wh">
                    <h3>How .NET Solves DLL Hell</h3>
                    <p>With .NET, Microsoft introduced assemblies and versioning to solve this problem:</p>
                    <ul>
                        <li>Each assembly in .NET is uniquely identified by its name, version number, culture, and
                            public
                            key
                            token (for signed assemblies).</li>
                        <li>This allows different versions of the same assembly to coexist on the system without
                            overwriting
                            each other, eliminating the DLL Hell problem.</li>
                        <li>Assemblies are stored in the <strong>Global Assembly Cache (GAC)</strong>, a special
                            location on
                            the
                            machine that allows multiple versions of assemblies to be installed side by side.</li>
                    </ul>

                </div>
                <div class="wh">

                    <p><strong>Global Assembly Cache (GAC)</strong></p>
                    <p>The <strong>GAC</strong> is a centralized location in Windows where .NET assemblies are stored.
                        The GAC
                        allows multiple versions of the same assembly to coexist, making it easier to manage different
                        applications that depend on different versions of a DLL.</p>
                </div>
            </div>


            <div class="in">
                <h3>3. Versioning</h3>
                <p><strong>Versioning</strong> is the technique used to assign different versions to assemblies,
                    ensuring
                    that applications load the correct version of a DLL they were built against. This is especially
                    useful
                    for resolving DLL Hell.</p>

                <p>Each assembly has a version number in the format <strong>Major.Minor.Build.Revision</strong>:</p>
                <ul>
                    <li><strong>Major version</strong>: Indicates a significant change or redesign in the software.</li>
                    <li><strong>Minor version</strong>: Indicates new features, but the software is still compatible
                        with
                        the previous major version.</li>
                    <li><strong>Build number</strong>: Usually incremented with every build of the software.</li>
                    <li><strong>Revision</strong>: Used for minor fixes and updates, like bug fixes or patches.</li>
                </ul>

                <p>Example of an assembly version: <code>1.2.345.0</code></p>
                <ul>
                    <li><strong>1</strong>: Major version</li>
                    <li><strong>2</strong>: Minor version</li>
                    <li><strong>345</strong>: Build number</li>
                    <li><strong>0</strong>: Revision</li>
                </ul>
            </div>


            <div class="in">
                <h3>4. Metadata</h3>
                <p>Every assembly in .NET contains <strong>metadata</strong>, which is data about the code itself.
                    Metadata
                    provides the following information about the code:</p>
                <ul>
                    <li>The names and types of classes, methods, and properties.</li>
                    <li>The version of the assembly.</li>
                    <li>Information about the types of parameters and return values for each method.</li>
                    <li>Security permissions required by the code.</li>
                </ul>

                <p>Metadata is crucial because it allows assemblies to describe themselves, enabling features like
                    reflection, which lets programs examine and modify their own structure during runtime.</p>

            </div>
            <div class="in">
                <h3>5. Namespace</h3>
                <p>A <strong>namespace</strong> is a way of organizing and grouping related classes, interfaces, enums,
                    and
                    structs in .NET. It helps avoid name conflicts and makes the code more readable and maintainable.
                </p>

                <p>For example, the .NET framework uses a variety of namespaces:</p>
                <ul>
                    <li><strong>System</strong>: A root namespace that contains basic classes and base data types like
                        strings,
                        arrays, and numbers.</li>
                    <li><strong>System.IO</strong>: A namespace that contains classes for input and output operations,
                        such
                        as
                        reading from and writing to files.</li>
                    <li><strong>System.Net</strong>: Contains classes for networking tasks, like sending requests over
                        HTTP.
                    </li>
                </ul>

                <p>When using classes from a namespace, you can refer to the full name (namespace + class), like this:
                </p>

                <pre>
                <code>
using System;

class Program {
    static void Main() {
        Console.WriteLine("Hello, World!");
    }
}
                </code>
            </pre>

                <p>In the example above, <strong>System</strong> is the namespace, and <strong>Console</strong> is the
                    class. The
                    <strong>using System;</strong> statement allows you to refer to the class directly by name, without
                    needing
                    to type <strong>System.Console</strong> every time.
                </p>
            </div>

            <div class="in">
                <h3>6. Assemblies and Namespace Together</h3>
                <p>Namespaces help organize code within assemblies. A single assembly can contain multiple namespaces,
                    and
                    namespaces can span across multiple assemblies. This allows developers to structure their code in a
                    clean, logical way that is easy to maintain.</p>
            </div>

        </div>
    </div>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script src="../../../../public/main.js"></script>
</body>

</html>