<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Basic Input/Output Interface</title>
    <link rel="stylesheet" href="../../../../public/style.css">
    <link rel="icon" href="../../../../public/logo/favicon_io/favicon.ico">
</head>

<body class="bg-c">
    <div id="mySidepanel" class="sidepanel">
        <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">Ã—</a>
        <a href="../index.html" class="home">back</a>
        <div class="fix-column-links">
            <a href="#" class="link"></a>
            <div class="botbut">
                <a href="../unit4/index.html" class="link">Next Topic &rarr;</a>
                <a href="../unit2/index.html" class="link">&larr; Previous Topic</a>
            </div>
        </div>
    </div>
    <div id="navbar" class="grad">
        <div>
            <div class="openbtn" onclick="openNav()">
                <div id="nav-icon1" for="nav-menu1">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </div>
        </div>
        <div>
            <h2>Basic Input/Output Interface</h2>
        </div>
    </div>
    <div class="content-box">
        <h1>Basic Input/Output Interface</h1>
        <div class="wh">
            <h2>Programmable Peripheral Interface (8255)</h2>
            <ul>
                <li>
                    The 8085 microprocessor faced difficulties in terms of I/O interfacing capability due to limited
                    data and address buses. To address this issue and enhance the I/O capabilities, Intel introduced the
                    8255 IC, which significantly increased interfacing capacities.
                </li>
            </ul>
            <div class="in">
                <h3>Basics of 8255</h3>
                <ul>
                    <li>
                        The 8255 Programmable Peripheral Interface is designed to increase the I/O interfacing
                        capability of microprocessors.
                    </li>
                    <li>
                        It has 24 I/O pins that can be grouped into three 8-bit parallel ports: Port A, Port B, and Port
                        C.
                    </li>
                    <li>
                        Port C can be used as individual bits or can be split into two 4-bit parts: C<sub>upper</sub>
                        (C<sub>7</sub> - C<sub>4</sub>) and C<sub>lower</sub> (C<sub>3</sub> - C<sub>0</sub>).
                    </li>
                    <li>
                        The 8255 operates in the following modes:
                        <ol>
                            <li>
                                I/O Modes:
                                <ul>
                                    <li>Mode 0: Basic Input/Output</li>
                                    <li>Mode 1: Strobed Input/Output</li>
                                    <li>Mode 2: Bi-Directional Bus</li>
                                </ul>
                            </li>
                            <li>
                                BSR (Bit Set/Reset) Mode: This mode is used to set or reset individual bits in Port C.
                            </li>
                        </ol>
                    </li>
                </ul>
            </div>
            <div class="in">
                <h3>Control Signals of 8255</h3>
                <ul>
                    <li>
                        <u style="text-decoration: overline;">RD</u> &rarr; Active low signal.
                        <br>When <u style="text-decoration: overline;">RD</u> is active, the microprocessor reads data
                        from the selected port of the 8255.
                    </li>
                    <li>
                        <u style="text-decoration: overline;">WR</u> &rarr; Active low signal.
                        <br>When <u style="text-decoration: overline;">WR</u> is active, the microprocessor writes data
                        to the selected port of the 8255.
                    </li>
                    <li>
                        RESET &rarr; Active high signal.
                        <br>When RESET is active, it clears the control registers and sets all ports in input mode.
                    </li>
                    <li>
                        <u style="text-decoration: overline;">CS</u>, A<sub>0</sub>, and A<sub>1</sub> &rarr; Chip
                        Select and Address Lines.
                        <pre>
 __
 CS   A1   A0
 0    0    0    Port A 
 0    0    1    Port B 
 0    1    0    Port C 
 0    1    1    Control Register 
 1    X    X    8255 not selected
                        </pre>
                        The above table shows the selection of ports or the control register based on the values of <u
                            style="text-decoration: overline;">CS</u>, A<sub>0</sub>, and A<sub>1</sub>.
                    </li>
                </ul>
            </div>
            <div class="in">
                <h3>Block Diagram</h3>
                <img src="../../images/ppi.svg" alt="8255 Block Diagram" class="wb">
                <ul>
                    <li>
                        <strong>Interfacing Requirement:</strong>
                        <ul>
                            <li>The need for interfacing arises because of the difference in operating speeds between
                                the microprocessor and the peripherals. Microprocessors operate at high speeds, while
                                peripherals like keyboards, displays, and printers operate at comparatively lower
                                speeds.</li>
                            <li>The 8255 Programmable Peripheral Interface helps manage this speed mismatch by providing
                                a buffer and control logic that allows the microprocessor to communicate efficiently
                                with the peripherals.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Port Connections:</strong>
                        <ul>
                            <li><strong>Port A:</strong> This port can be configured as an 8-bit input or output port
                                and is connected to I/O devices that require higher data transfer rates or need to
                                handle 8-bit data simultaneously.</li>
                            <li><strong>Port B:</strong> Similar to Port A, Port B can also be configured as an 8-bit
                                input or output port, allowing it to interface with various I/O devices.</li>
                            <li><strong>Port C:</strong> This port can be split into two 4-bit ports (C<sub>upper</sub>
                                and C<sub>lower</sub>). It can be used for controlling individual bits or for
                                interfacing with devices that require less data transfer.</li>
                            <li><strong>Control Port:</strong> The control port is used by the microprocessor to
                                configure and control the operation of Ports A, B, and C. The microprocessor uses the
                                read (<u style="text-decoration: overline;">RD</u>), write (<u
                                    style="text-decoration: overline;">WR</u>), and chip select (<u
                                    style="text-decoration: overline;">CS</u>) signals to access and manage the control
                                port.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Block Diagram Overview:</strong>
                        <ul>
                            <li><strong>Data Bus Buffer:</strong> This part of the 8255 is connected to the system data
                                bus. It transfers data between the microprocessor and the 8255.</li>
                            <li><strong>Read/Write Control Logic:</strong> This section manages the read and write
                                operations between the microprocessor and the 8255. It generates the appropriate control
                                signals based on the input from the microprocessor.</li>
                            <li><strong>Group A and Group B Control:</strong> The control logic is divided into two
                                groups, A and B, each controlling one of the ports (A or B) and a portion of Port C.
                                This allows for flexible configuration of the ports.</li>
                            <li><strong>Ports (A, B, and C):</strong> These ports are connected to the I/O devices. The
                                configuration of these ports is managed by the control registers.</li>
                        </ul>
                    </li>
                </ul>
            </div>
        </div>
        <div class="wh">
            <h2>Keyboard and Display Controller (8279)</h2>
            <p>
                The 8279 is a programmable keyboard and display interface designed by Intel to manage input from a
                keyboard and output to a display. It helps in interfacing keyboards and displays with a microprocessor,
                providing efficient data entry and display management.
            </p>
            <div class="in">
                <h3>Features</h3>
                <ul>
                    <li>
                        The 8279 is designed by Intel.
                    </li>
                    <li>
                        It supports a 64-contact key matrix along with two additional keys: "CONTROL" and "SHIFT".
                    </li>
                    <li>
                        It provides three operation modes (or input modes):
                        <ol>
                            <li>Scanned Keyboard Mode: In this mode, the keys are scanned row by row for key presses.
                            </li>
                            <li>Scanned Sensor Matrix Mode: This mode is used for interfacing with sensors arranged in a
                                matrix form.</li>
                            <li>Strobed Input Mode: In this mode, the input is strobed and the data is latched with each
                                strobe signal.</li>
                        </ol>
                    </li>
                    <li>
                        It has an inbuilt debounce key feature to eliminate key bounce issues.
                    </li>
                    <li>
                        It provides a 16-byte display RAM to display up to 16 digits, allowing for efficient interfacing
                        and display of characters.
                    </li>
                    <li>
                        It offers two output modes:
                        <ol>
                            <li>Left Entry Mode: Data is entered from the left, similar to a typewriter.</li>
                            <li>Right Entry Mode: Data is entered from the right, similar to a calculator.</li>
                        </ol>
                    </li>
                    <li>
                        The interrupt output of the 8279 can be used to notify the CPU of a key press detection, which
                        eliminates the need for software polling. This means the CPU can perform other tasks and respond
                        to key presses as they occur.
                    </li>
                </ul>
            </div>
        </div>
        <div class="wh">
            <h2>8254 Programmable Interval Timer</h2>
            <ul>
                <li>
                    The 8254 is used to generate finite delays. It has three integrated counters, each with a capacity
                    of 16 bits.
                </li>
                <li>
                    <strong>Why do we use the 8254?</strong>
                    <br>
                    The initial versions of Intel microprocessors, such as the 8085 and 8086, did not have an integrated
                    timer. Without a hardware timer, generating delays required executing software loops, which had two
                    main issues:
                    <ol>
                        <li>The microprocessor would be busy while executing the delay program, meaning it couldn't
                            perform other tasks simultaneously.</li>
                        <li>The accuracy of the timing would depend on the execution time of the instructions, which
                            could vary.</li>
                    </ol>
                    These issues are resolved by using the 8254 IC.
                </li>
            </ul>
            <div class="in">
                <h3>Features of 8254 PIT IC</h3>
                <ul>
                    <li>
                        The 8254 is designed to work with various microprocessors, including the 8085 and 8086.
                    </li>
                    <li>
                        The 8254 is used as a timer to generate hardware delays.
                        <br>
                        <strong>Difference between hardware delay and software delay:</strong> A hardware delay is
                        generated by a dedicated timer IC, allowing the microprocessor to perform other tasks during the
                        delay period. In contrast, a software delay requires the microprocessor to execute a delay
                        program, making it unavailable for other tasks during the delay.
                    </li>
                    <li>
                        The 8254 can be used as a real-time clock or as a square wave generator.
                    </li>
                    <li>
                        Hardware delay is more useful than software delay because the microprocessor is not actively
                        involved in generating the delay. When the 8254 generates a delay, the microprocessor is free to
                        execute other programs.
                    </li>
                    <li>
                        The 8254 has three independent 16-bit down counters.
                        <br>
                        <strong>Down Counter:</strong> A down counter starts from a specified value and counts down to
                        zero.
                    </li>
                    <li>
                        These counters can operate in BCD (Binary-Coded Decimal) or binary mode.
                    </li>
                    <li>
                        Once a counter finishes counting (i.e., the required delay is reached), the 8254 interrupts the
                        microprocessor.
                    </li>
                </ul>
            </div>
        </div>
        <div class="wh">
            <h2>Programmable Communication Interface (8251)</h2>
            <p></p>
            <div class="in">
                <h3>Basics of 8251</h3>
                <ul>
                    <li>
                        The 8251 is a programmable chip designed for synchronous and asynchronous serial data
                        communication.
                    </li>
                    <li>
                        The 8251A is an advanced version of the 8251, with additional features and improvements.
                    </li>
                    <li>
                        The control logic of the 8251 is connected with the microprocessor to determine the function of
                        the 8251. The control logic essentially manages the mode of operation and the configuration of
                        the 8251.
                    </li>
                    <li>
                        The 8251 converts parallel data to serial format for transmission and converts serial data to
                        parallel format for reception.
                    </li>
                </ul>
            </div>
            <div class="in">
                <h3>Working of 8251</h3>
                <ul>
                    <li>
                        <strong>Transmitter Section:</strong>
                        <ul>
                            <li>Receives parallel data from the microprocessor.</li>
                            <li>Converts the parallel data into serial format.</li>
                            <li>Transmits the serial data on the TxD (Transmit Data) line.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Receiver Section:</strong>
                        <ul>
                            <li>Receives serial data on the RxD (Receive Data) line.</li>
                            <li>Converts the serial data into parallel format.</li>
                            <li>Transfers the parallel data to the microprocessor.</li>
                        </ul>
                    </li>
                    <li>
                        Data transmission can be done for both synchronous and asynchronous data transfer.
                    </li>
                </ul>
            </div>
            <div class="in">
                <h3>Control Signals of 8251</h3>
                <ul>
                    <li>
                        <strong><u style="text-decoration: overline;">CS</u> (Chip Select):</strong>
                        <br>
                        An active low signal that selects the 8251 for communication with the microprocessor. When this
                        signal is low, the 8251 is enabled for communication.
                    </li>
                    <li>
                        <strong><u style="text-decoration: overline;">RD</u> (Read):</strong>
                        <br>
                        An active low signal used to read data from the 8251. When this signal is low, the
                        microprocessor reads data from the 8251's data bus.
                    </li>
                    <li>
                        <strong><u style="text-decoration: overline;">WR</u> (Write):</strong>
                        <br>
                        An active low signal used to write data to the 8251. When this signal is low, the microprocessor
                        writes data to the 8251's data bus.
                    </li>
                    <li>
                        <strong><u style="text-decoration: overline;">C/D</u> (Control/Data):</strong>
                        <br>
                        This signal determines whether the data being transferred is control information or actual data.
                        When C/D is high, the data is control information; when low, the data is actual communication
                        data.
                    </li>
                    <li>
                        <strong><u style="text-decoration: overline;">RESET</u>:</strong>
                        <br>
                        An active high signal that resets the 8251, clearing the control registers and initializing the
                        device.
                    </li>
                    <li>
                        <strong><u style="text-decoration: overline;">CLK</u> (Clock):</strong>
                        <br>
                        Provides the timing signal necessary for the 8251 to operate. The clock signal synchronizes the
                        data transmission and reception processes.
                    </li>
                </ul>
            </div>
        </div>
        <div class="wh">
            <h2>Interrupts</h2>
            <p>Interrupts are signals that inform the processor about the occurrence of an event, allowing the processor
                to temporarily halt its current execution and address the event. Interrupts can be classified into two
                main types: hardware interrupts and software interrupts.</p>

            <div class="in">
                <h3>Hardware Interrupts</h3>
                <ul>
                    <li>
                        <strong>Definition:</strong>
                        <br>
                        Hardware interrupts are generated by external hardware devices, such as keyboards, mice,
                        printers, or other peripheral devices, to signal the processor that an event has occurred that
                        requires immediate attention.
                    </li>
                    <li>
                        <strong>Characteristics:</strong>
                        <ul>
                            <li>Triggered by external devices.</li>
                            <li>Used for real-time processing and handling of external events.</li>
                            <li>Examples include interrupts from a mouse click or a keystroke.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Process:</strong>
                        <ul>
                            <li>The external device sends an interrupt signal to the processor.</li>
                            <li>The processor pauses its current tasks and saves the current state.</li>
                            <li>The processor executes the interrupt service routine (ISR) to handle the event.</li>
                            <li>After the ISR completes, the processor resumes its previous tasks.</li>
                        </ul>
                    </li>
                </ul>
            </div>

            <div class="in">
                <h3>Software Interrupts</h3>
                <ul>
                    <li>
                        <strong>Definition:</strong>
                        <br>
                        Software interrupts are generated by executing specific instructions in the software, typically
                        used to request system services from the operating system.
                    </li>
                    <li>
                        <strong>Characteristics:</strong>
                        <ul>
                            <li>Triggered by software instructions.</li>
                            <li>Used for system calls and to handle software events.</li>
                            <li>Examples include system calls for file operations or memory allocation.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Process:</strong>
                        <ul>
                            <li>The software executes a specific interrupt instruction.</li>
                            <li>The processor recognizes the software interrupt and pauses the current tasks.</li>
                            <li>The processor executes the corresponding interrupt service routine (ISR) to perform the
                                requested service.</li>
                            <li>After the ISR completes, the processor resumes its previous tasks.</li>
                        </ul>
                    </li>
                </ul>
            </div>
        </div>
        <div class="wh">
            <h2>8259 Programmable Interrupt Controller (PIC)</h2>
            <p>The 8259 Programmable Interrupt Controller (PIC) is a specialized IC designed to manage hardware
                interrupts and prioritize them before sending them to the processor. It is used to enhance the interrupt
                handling capabilities of microprocessors.</p>

            <div class="in">
                <h3>Basics of 8259</h3>
                <ul>
                    <li>
                        <strong>Purpose:</strong>
                        <br>
                        The 8259 PIC is used to handle and prioritize multiple interrupt requests from various hardware
                        devices, ensuring efficient interrupt management in a system.
                    </li>
                    <li>
                        <strong>Interrupt Vector:</strong>
                        <br>
                        It generates an interrupt vector address that points to the appropriate interrupt service
                        routine (ISR) for the processor to execute.
                    </li>
                    <li>
                        <strong>Compatibility:</strong>
                        <br>
                        The 8259 is designed to work seamlessly with the 8085, 8086, and other microprocessors,
                        enhancing their interrupt handling capabilities.
                    </li>
                    <li>
                        <strong>Interrupt Requests:</strong>
                        <br>
                        It can handle up to 8 interrupt requests (IR0-IR7), which can be expanded by cascading multiple
                        8259 PICs.
                    </li>
                </ul>
            </div>

            <div class="in">
                <h3>Features of 8259</h3>
                <ul>
                    <li>
                        <strong>Priority Resolver:</strong>
                        <br>
                        The 8259 contains a priority resolver that determines the priority of the incoming interrupt
                        requests and services them accordingly.
                    </li>
                    <li>
                        <strong>Cascading:</strong>
                        <br>
                        Multiple 8259 PICs can be cascaded to handle more than 8 interrupt requests, allowing for a
                        scalable interrupt management system.
                    </li>
                    <li>
                        <strong>Interrupt Masking:</strong>
                        <br>
                        Individual interrupt lines can be masked using the Interrupt Mask Register (IMR), allowing
                        selective enabling or disabling of interrupt requests.
                    </li>
                    <li>
                        <strong>Interrupt Modes:</strong>
                        <ul>
                            <li>Fully Nested Mode: Prioritizes interrupts in a fixed order (IR0-IR7).</li>
                            <li>Special Fully Nested Mode: Allows certain interrupts to have higher priority.</li>
                            <li>Rotating Priority Mode: Rotates the priority of interrupts, giving each interrupt line a
                                chance to be the highest priority.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>End of Interrupt (EOI):</strong>
                        <br>
                        The 8259 uses an EOI command to signal the completion of an interrupt service routine, allowing
                        it to handle the next interrupt request.
                    </li>
                </ul>
            </div>

            <div class="in">
                <h3>Control Signals of 8259</h3>
                <ul>
                    <li>
                        <strong><u style="text-decoration: overline;">CS</u> (Chip Select):</strong>
                        <br>
                        An active low signal that selects the 8259 for communication with the microprocessor.
                    </li>
                    <li>
                        <strong><u style="text-decoration: overline;">RD</u> (Read):</strong>
                        <br>
                        An active low signal used to read data from the 8259.
                    </li>
                    <li>
                        <strong><u style="text-decoration: overline;">WR</u> (Write):</strong>
                        <br>
                        An active low signal used to write data to the 8259.
                    </li>
                    <li>
                        <strong><u style="text-decoration: overline;">INT</u> (Interrupt):</strong>
                        <br>
                        An active high signal sent to the processor to indicate that an interrupt request has occurred.
                    </li>
                    <li>
                        <strong><u style="text-decoration: overline;">INTA</u> (Interrupt Acknowledge):</strong>
                        <br>
                        An active low signal sent by the processor to the 8259 to acknowledge the receipt of the
                        interrupt request.
                    </li>
                    <li>
                        <strong><u style="text-decoration: overline;">SP/EN</u> (Slave Program/Enable Buffer):</strong>
                        <br>
                        Determines whether the 8259 is in master or slave mode in a cascaded configuration, and can also
                        be used to enable buffer.
                    </li>
                </ul>
            </div>
        </div>
        <div class="wh">
            <h2>Direct Memory Access (DMA)</h2>
            <ul>
                <li>
                    Direct Memory Access (DMA) is a method that allows data to be moved from one location to another
                    without the direct intervention of the Central Processing Unit (CPU). This method significantly
                    speeds up data transfer operations within a computer system.
                </li>
                <li>
                    DMA provides a faster way of transferring data within the computer because it bypasses the CPU,
                    which can be a bottleneck in data transfer operations. By allowing peripheral devices to communicate
                    directly with memory, DMA improves overall system performance.
                </li>
                <li>
                    The DMA I/O technique provides direct access to memory while the microprocessor is temporarily
                    disabled. This means that the CPU can continue to perform other tasks while the DMA controller
                    handles the data transfer, leading to more efficient use of system resources.
                </li>
                <li>
                    The DMA controller temporarily borrows the address bus, data bus, and control bus from the
                    microprocessor. It transfers the data directly from external devices (like disk drives or network
                    cards) to a series of memory locations. This direct transfer bypasses the CPU, allowing for faster
                    data movement.
                </li>
                <li>The 8257 DMA controller is a crucial component in computer systems, particularly for enhancing data transfer efficiency. For instance, when you want to play a high-definition video file stored on a hard disk on your computer, the DMA controller directly accesses the system's memory and the graphics card, bypassing the CPU for data transfer operations. This means that the controller efficiently moves the video data from the hard disk to the graphics card's memory without burdening the CPU, ensuring smooth playback without interruptions or slowdowns in other tasks being performed by the CPU. DMA is essential as it offloads data transfer tasks from the CPU, allowing the CPU to focus on processing instructions and running applications, ultimately improving overall system performance and ensuring efficient handling of data-intensive tasks.</li>
            </ul>

            <div class="in">
                <h3>Basic DMA Operations</h3>
                <p>
                    Two control signals are used to request and acknowledge a DMA transfer in a microprocessor-based
                    system. These two signals are:
                <ol>
                    <li>HOLD: The HOLD signal is used by the DMA controller to request control of the system
                        buses from the CPU.
                        <ul>
                            <li>
                                The HOLD signal is an input to the processor used to request DMA action. When the DMA
                                controller
                                needs to transfer data, it asserts the HOLD signal, asking the CPU to release control of
                                the
                                buses.
                            </li>
                        </ul>
                    </li>
                    <li>HLDA (Hold Acknowledge): The HLDA signal is used by the CPU to acknowledge that it has
                        relinquished control of the system buses to the DMA controller.
                        <ul>
                            <li>
                                The HLDA (Hold Acknowledge) signal is an output from the processor that acknowledges the
                                DMA
                                action. When the CPU receives the HOLD signal, it finishes its current operation, places
                                the
                                buses in a high-impedance state (effectively disconnecting from them), and then asserts
                                the HLDA
                                signal to indicate that the DMA controller can take control of the buses.
                            </li>
                        </ul>
                    </li>
                </ol>
                </p>

                <p>
                    Note: The HOLD signal has the highest priority compared to other interrupt signals like INTR
                    (Interrupt Request) and NMI (Non-Maskable Interrupt). However, the RESET signal has the absolute
                    highest priority.
                </p>

                <ul>
                    <li>
                        When the HLDA signal becomes active, it indicates that the processor has put its buses in a
                        high-impedance state. In this state, the buses are effectively disconnected from the processor,
                        allowing the DMA controller to take over and transfer data directly between I/O devices and
                        memory. This means the microprocessor is free to execute other tasks or go into a low-power
                        state.
                    </li>
                    <li>
                        DMA operations occur directly between I/O devices and memory without involving the
                        microprocessor. This direct transfer method significantly speeds up data transfer processes and
                        frees up the CPU to perform other tasks, leading to more efficient system performance.
                    </li>
                </ul>
            </div>
            <div class="in">
                <h3>DMA Read and Write Operations</h3>
                <ul>
                    <li>
                        <strong>DMA Read Operation:</strong>
                        <ol>
                            <li>The DMA controller asserts the HOLD signal to request control of the system buses from
                                the CPU.</li>
                            <li>The CPU finishes its current operation, places the buses in a high-impedance state, and
                                asserts the HLDA signal.</li>
                            <li>The DMA controller takes control of the buses and reads data from the memory address
                                specified in the DMA request.</li>
                            <li>The data is transferred from memory to the I/O device.</li>
                            <li>Once the transfer is complete, the DMA controller deasserts the HOLD signal, and the CPU
                                regains control of the buses.</li>
                        </ol>
                    </li>
                    <li>
                        <strong>DMA Write Operation:</strong>
                        <ol>
                            <li>The DMA controller asserts the HOLD signal to request control of the system buses from
                                the CPU.</li>
                            <li>The CPU finishes its current operation, places the buses in a high-impedance state, and
                                asserts the HLDA signal.</li>
                            <li>The DMA controller takes control of the buses and writes data to the memory address
                                specified in the DMA request.</li>
                            <li>The data is transferred from the I/O device to memory.</li>
                            <li>Once the transfer is complete, the DMA controller deasserts the HOLD signal, and the CPU
                                regains control of the buses.</li>
                        </ol>
                    </li>
                </ul>
            </div>
        </div>
        <div class="wh">
                <h2>8237 DMA Controller</h2>
                <ul>
                    <li>
                        <strong>Introduction:</strong>
                        <br>
                        The 8237 DMA controller is a programmable device used to manage DMA operations, allowing
                        peripheral devices to directly read from and write to memory without CPU intervention.
                    </li>
                    <li>
                        <strong>Features:</strong>
                        <ul>
                            <li>Contains four independent DMA channels, each capable of transferring data between memory
                                and I/O devices.</li>
                            <li>Supports both memory-to-memory and peripheral-to-memory transfers.</li>
                            <li>Each channel has a 64KB address range.</li>
                            <li>Provides data transfer modes such as single transfer, block transfer, demand transfer,
                                and cascade mode.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Addressing:</strong>
                        <br>
                        The 8237 DMA controller uses a base address and a current address register for each channel to
                        keep track of the memory locations involved in the transfer.
                    </li>
                    <li>
                        <strong>Transfer Modes:</strong>
                        <ul>
                            <li>Single Transfer Mode: Transfers a single byte of data per request.</li>
                            <li>Block Transfer Mode: Transfers a block of data in a single burst.</li>
                            <li>Demand Transfer Mode: Continues transferring data as long as the peripheral is
                                requesting it.</li>
                            <li>Cascade Mode: Used for cascading multiple DMA controllers to handle more channels.</li>
                        </ul>
                    </li>
                </ul>
            </div>
        </div>
    </div>
    <script src="../../../../public/main.js"></script>
</body>

</html>