<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bitwise Manipulations</title>
    <link rel="stylesheet" href="../../../../public/style.css">
    <link rel="stylesheet" id="highlightStylesheet"
        href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/tomorrow-night-blue.min.css">
        <link rel="icon" href="../../../../public/logo/favicon_io/favicon.ico">
</head>

<body class="bg-c">
    <div id="mySidepanel" class="sidepanel">
        <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">Ã—</a>
        <a href="../index.html" class="home">back</a>
        <a href="#t1" class="link">Bitwise AND ( & )</a>
        <a href="#t2" class="link">Bitwise OR ( | )</a>
        <a href="#t3" class="link">Bitwise XOR ( ^ )</a>
        <a href="#t4" class="link">One's complement ( ~ )</a>
        <a href="#t5" class="link">Bitwise left shift ( << )</a>
                <a href="#t6" class="link">Bitwise right shift ( >> )</a>
                <a href="#t7" class="link">Programs</a>
                <a href="#t8" class="link">Bit masking</a>
                <a href="#t9" class="link">Application of bitwise operator</a>
                <div class="botbut">
                    <a href="../string/index.html" class="link">Next Topic &rarr;</a>
                    <a href="../pointer/index.html" class="link">&larr; Previous Topic</a>
                </div>
    </div>
    <div id="navbar" class="grad">
        <div>
            <div class="openbtn" onclick="openNav()">
                <div id="nav-icon1" for="nav-menu1">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </div>
        </div>
        <div>
            <h2>Bitwise Manipulations</h2>
        </div>
    </div>
    <div class="content-box">
        <h1>Bitwise Manipulations</h1>
        <ul>
            <li>We know that inside the computer, data is represented in binary digits called bits (0 and 1).</li>
            <li>Till now we were able to access and manipulate bytes only. But some applications, such as system
                programming require manipulation of individual bits within a byte.</li>
            <li>In most high-level languages this facility is not available, but C has the special feature to manipulate
                individual bits of a byte. This feature is implemented through bitwise operators that support bitwise
                operations.</li>
            <li>These bitwise operators are:</li>
            <pre>
                <code>
Operator            Meaning
    &           bitwise AND
    |           bitwise OR
    ^           bitwise exclusive OR ( XOR )
    ~           One's complement
    <<          bitwise left shift
    >>          bitwise right shift
                </code>
            </pre>
            <li>Here all the operators are binary, except the complement operator, which is unary.</li>
            <li>These bitwise operator work on data of integral type only i.e. char, int, shot, long including both
                signed and unsigned types. When these operators are applied to signed types, the result may be
                implementation dependent, because different implementations represent the signed data in different ways.
            </li>
            <li>These operators operate on each bit of operand, so while using these operators we'll consider the binary
                representation (bit pattern) of the operand.</li>
            <li><b>Note:</b> We'll represent the integers in hexadecimal, because it is easier to convert hexadecimal to
                binary and vice versa.</li>
            <li>All bitwise operatos except the complement operator can be combined with the assignment operator to form
                the compound assignment operators:
                <ul>
                    <li>&=, |=, <<=,>>=, ^=</li>
                </ul>
            </li>
        </ul>
        <div id="t1" class="wh">
            <h2>Bitwise AND ( & )</h2>
            <ul>
                <li>It is binary operator and requires two operands. These operands are compared bitwise i.e. all the
                    corresponding bits in both operands are compared. The resulting bit is 1, only when the bits in both
                    operands are 1, otherwise it is 0.</li>
            </ul>
            <pre>
                <code>
Bits of operand1    Bit of operand2     Resulting Bit
       0                 0                   0
       0                 1                   0
       1                 0                   0
       1                 1                   1
                </code>
            </pre>
            <ul>
                <li>Let us take a = 0x293B and b = 0x1A2F are two integer variables. The binary representation of these
                    variables and the result after performing bitwise AND operation is shown below-
                    <pre>
                        <code>
Note: 0x293B in 16 bits = 000000000000293B
a    0010  1001  0011  1011     (0x293B)
b    0001  1010  0010  1111     (0x1A2F)
----------------------------
a&b  0000  1000  0010  1011     (0x082B)
                        </code>
                    </pre>
                </li>
            </ul>
            <p>Program code &darr;</p>
            <div class="code">
                <div class="dotc"></div>
                <pre>
                <code>
#include&lt;stdio.h>
int main()
{
    int a, b;
    printf("Enter values of a and b : ");
    scanf("%d%d", &a, &b);
    printf("a = %d\t\t", a);
    printf("b = %d\t\t", b);
    printf("a&b = %d\t\t", a&b);
    return 0;
}
/*
    if a = 8 and b = 9 then the output will be 8
      1000
    & 1001
    -------
      1000
*/
                </code>
            </pre>
            </div>
        </div>
        <div id="t2" class="wh">
            <h2>Bitwise OR ( | )</h2>
            <ul>
                <li>The corresponding bits of both operands are compared and the resulting bit is 0, only when the bits
                    in both operands are 0, otherwise it is 1.</li>
            </ul>
            <pre>
                <code>
Bits of operand1    Bit of operand2     Resulting Bit
       0                 0                   0
       0                 1                   1
       1                 0                   1
       1                 1                   1
                </code>
            </pre>
            <ul>
                <li>The result of bitwise OR operation performed between variables a and b is shown below-
                    <pre>
                        <code>
a    0010  1001  0011  1011     (0x293B)
b    0001  1010  0010  1111     (0x1A2F)
----------------------------
a&b  0011  1011  0011  1111     (0x3B3F)
                        </code>
                    </pre>
                </li>
            </ul>
            <p>Program code &darr;</p>
            <div class="code">
                <div class="dotc"></div>
                <pre>
                <code>
#include&lt;stdio.h>
int main()
{
    int a, b;
    printf("Enter values of a and b : ");
    scanf("%d%d", &a, &b);
    printf("a = %d\t\t", a);
    printf("b = %d\t\t", b);
    printf("a&b = %d\t\t", a|b);
    return 0;
}
/*
    if a = 8 and b = 9 then the output will be 9
      1000
    | 1001
    -------
      1001
*/
                </code>
            </pre>
            </div>
        </div>
        <div id="t3" class="wh">
            <h2>Bitwise XOR ( ^ )</h2>
            <ul>
                <li>The corresponding of both operands are compared and the resulting bit is 1, if bit of both operands
                    have different value, otherwise it is 0.</li>
            </ul>
            <pre>
                <code>
Bits of operand1    Bit of operand2     Resulting Bit
       0                 0                   0
       0                 1                   1
       1                 0                   1
       1                 1                   0
                </code>
            </pre>
            <ul>
                <li>The result of bitwise XOR operation performed between variables a and b is shown below-
                    <pre>
                        <code>
a    0010  1001  0011  1011     (0x293B)
b    0001  1010  0010  1111     (0x1A2F)
----------------------------
a&b  0011  0011  0001  0100     (0x3314)
                        </code>
                    </pre>
                </li>
            </ul>
            <p>Program code &darr;</p>
            <div class="code">
                <div class="dotc"></div>
                <pre>
                <code>
#include&lt;stdio.h>
int main()
{
    int a, b;
    printf("Enter values of a and b : ");
    scanf("%d%d", &a, &b);
    printf("a = %d\t\t", a);
    printf("b = %d\t\t", b);
    printf("a&b = %d\t\t", a^b);
    return 0;
}
/*
    if a = 8 and b = 9 then the output will be 1
      1000
    ^ 1001
    -------
      0001
*/
                </code>
            </pre>
            </div>
        </div>
        <ul>
            <li>When the bitwise operators &, |, ^ operate on two operands of different sizes, then the size of smallest
                operand is increased to match the size of larger operand.</li>
            <li>For example if there are two operands of sizes 16 and 32 bits, then the 16-bit operand will be converted
                to 32 bits.</li>
            <li>The extra bits are added to the left of the smaller operand. If the smaller operand is <i>unsigned</i>
                then all these extra bits are filled with zeros, and if it is <i>signed</i> then these bits are filled
                with the sign bit.</li>
        </ul>
        <div id="t4" class="wh">
            <h2>One's Complement ( ~ )</h2>
            <ul>
                <li>One's complement operator is a unary operator and requires only one operand.</li>
                <li>It negates the value of the bit.</li>
                <li>If the bit of the operand is 1 then the resulting bit is 0 and if the bit of the operand is 0 then
                    the resulting bit is 1.</li>
            </ul>
            <pre>
                <code>
Bits of operand        Resulting Bit
       0                     1
       1                     0

       
a   0010  1001  0011  1011    (0x293B)
~a  1101  0110  1100  0100    (0xD6C4)

b   0001  1010  0010  1111    (0x1A2F)
~b  1110  0101  1101  0000    (0xE5D0)
                </code>
            </pre>
            <ul>
                <li>The ~ operator should be used carefully. The result of ~ operator on a small number can be a big
                    number if the reuslt is stored in an unsigned variable. And the result may be a negative number if
                    the result is stored in a signed variable (assuming that the negative numbers are stored in 2's
                    complement form where the leftmost bit is the sign bit)</li>
            </ul>
            <p>Program code &darr;</p>
            <div class="code">
                <div class="dotc"></div>
                <pre>
                <code>
#include&lt;stdio.h>
int main()
{
    unsigned int a;
    printf("Enter values of a : ");
    scanf("%d", &a);
    printf("a = %d\n", a);
    printf("Signed result of ~a = %d\n", ~a);
    printf("Unsigned result of ~a = %u\n", ~a);
    return 0;
}
/*
    if a = 1 then the output will be -2 (signed) and 4294967294 (unsigned)
*/
                </code>
            </pre>
            </div>
            <ul>
                <li>When the complement operator is applied to an operand twice, then result is the original operand
                    i.e., ~(~a) is equal to a.</li>
                <li>This feature of complement operator can be used for encrypting and decrypting data. </li>
                <li>To encrypt the data, we can apply complement oeprator to it, and to decrypt the data i.e. to get
                    back the original data we can apply the complement operator to the encrypted data.</li>
                <li>For example <br>
                    Original data : 0000 1111 0101 0011
                    <br>Ecrypted data : 1111 0000 1010 1100 (By applying ~ to original data)
                    <br>Decrypted data : 0000 1111 0101 0011 (By applying ~ to encrypted data)
                </li>
            </ul>
        </div>
        <div id="t5" class="wh">
            <h2>Bitwise Left Shift ( << )</h2>
                    <ul>
                        <li>This operator is used for shifting the bits left. It requires two operands. The left operand
                            is the operand whose bits are shifted and the right operand indicates the number of bits to
                            be shifted.</li>
                        <li>On shifting the bits left, an equal number of bit position on the right are vacated. These
                            positions are filled in with 0 bits.</li>
                    </ul>
                    <img src="../../images/bitman1.svg" alt="" class="wb">
                    <div class="code">
                        <div class="dotc"></div>
                        <pre>
                <code>
#include &lt;stdio.h>
int main()
{
    int a;
    printf("Enter values of a : ");
    scanf("%d", &a);
    a = a << 2;
    printf("a << 2 = %d\t\t", a);
    return 0;
}
                </code>
            </pre>
                    </div>
                    <p>Output &darr;</p>
                    <pre>
                        <code>
Enter values of a : 1
a << 2 = 4 
                        </code>
                    </pre>
        </div>
        <div id="t6" class="wh">
            <h2>Bitwise Right Shift ( >> )</h2>
            <img src="../../images/bitman2.svg" alt="" class="wb">
            <ul>
                <li>Logical shift - The vacated bits are always filled with zeros.</li>
                <li>Arithmetic shift - The vacated bits are filled with the value of the leftmost bit in the initial bit
                    pattern. If the left most bit is 1, then the vacated positions are filled with 1, and if the left
                    most bit 0, then the vacated posisitons are filled with 0.</li>
            </ul>
            <div class='code'>
                <div class='dotc'></div>
                <pre>
                <code>
#include &lt;stdio.h>
int main()
{
    int a;
    printf("Enter values of a : ");
    scanf("%d", &a);
    a = a >> 2;
    printf("a >> 2 = %d\t\t", a);
    return 0;
}
                </code>
            </pre>
            </div>
            <p>Output &darr;</p>
            <pre>
                <code>
Enter values of a : 9
a << 2 = 2  
                </code>
            </pre>
        </div>
        <div id="t7" class="wh">
            <h2>Some programs</h2>
            <div class="in">
                <h3>Program to swap two number using bitwise operator</h3>
                <pre>
                    <code>
#include &lt;stdio.h>
int main()
{
    int a = 10, b = 7;
    printf("The value of a and b before swap : a = %d & b = %d\n", a, b);
    a = a ^ b;
    b = a ^ b;
    a = a ^ b;
    printf("The value of a and b after swap : a = %d & b = %d\n", a, b);
    return 0;
}
                    </code>
                </pre>
            </div>
            <div class="in">
                <h3>Program to enter a decimal number and print its binary form and check whether it is even or odd.
                </h3>
                <div class='code'>
                    <div class='dotc'></div>
                    <pre>
                       <code>
#include &lt;stdio.h>

void decimalToBinary(int num)
{
    int binary[32];
    int i = 0;

    // Convert decimal to binary using bit manipulation
    while (num > 0)
    {
        binary[i] = num & 1;
        num >>= 1;
        i++;
    }

    printf("Binary representation: ");

    // Print binary representation in reverse order
    for (int j = i - 1; j >= 0; j--)
    {
        printf("%d", binary[j]);
    }

    printf("\n");
}

void checkEvenOdd(int num)
{
    // Check the least significant bit to determine even/odd
    if ((num & 1) == 0)
    {
        printf("The number is even.\n");
    }
    else
    {
        printf("The number is odd.\n");
    }
}

int main()
{
    int decimalNum;

    printf("Enter a decimal number: ");
    scanf("%d", &decimalNum);

    decimalToBinary(decimalNum);
    checkEvenOdd(decimalNum);

    return 0;
}
                       </code>
                   </pre>
                </div>
            </div>
        </div>
        <div id="t8" class="wh">
            <h2>Bit masking</h2>
            <ul>
                <li>Bit masking involves using bitwise operators to selectively manipulate specific bits of a variable
                    while leaving the other bits unchanged. It is commonly used for tasks like setting, clearing, or
                    checking specific bits in a variable.</li>
            </ul>
            <div class="in">
                <h3>checking if a bit is set (1) or not</h3>
                <div class='code'>
                    <div class='dotc'></div>
                    <pre>
                       <code>
#include &lt;stdio.h>
int isBitSet(int num, int bitPos)
{
    int mask = 1 << bitPos;
    return ((num & mask) > 0);
}
int main()
{
    int num = 10; // Binary: 0000 1010

    // Check if bit at position 3 is set
    if (isBitSet(num, 3))
        printf("Bit at position 3 is set.\n");
    else
        printf("Bit at position 3 is not set.\n");

    return 0;
}
                       </code>
                   </pre>
                </div>
                <ul>
                    <li>Explanation: In this function, the bit at the desired position is isolated using the left shift
                        operator (<<) to shift 1 by bitPos positions. This creates a bit mask with only the bit at the
                            desired position set to 1. The bitwise AND operation (&) is then performed between num and
                            the bit mask. If the result is non-zero, it means the bit at the specified position is set
                            (1); otherwise, it is not set (0). The function returns this result.</li>
                    <li>Note: Bit numbering starts from 0 so position bit 3 means 4th location from rightmost bit.</li>
                </ul>
            </div>
            <div class="in">
                <h3>Setting a specific bit</h3>
                <ul>
                    <li>We are going to use 'setBit()' function.</li>
                    <li>The setBit() function is used to set a specific bit to 1 in a given number. It takes two
                        parameters: num, which represents the number you want to modify, and bitPos, which indicates the
                        position of the bit you want to set. Here's the function implementation:</li>
                </ul>
                <div class='code'>
                    <div class='dotc'></div>
                    <pre>
                       <code>
#include &lt;stdio.h>
// Function to set a specific bit
int setBit(int num, int bitPos)
{
    int mask = 1 << bitPos;
    return num | mask;
}
int main()
{
    int num = 10; // Binary: 0000 1010

    // Set bit at position 2
    printf("Initially number was : %d\n", num);
    num = setBit(num, 2);
    printf("After setting bit at position 2 : %d\n", num);

    return 0;
}
                       </code>
                   </pre>
                </div>
                <p>Output &darr;</p>
                <pre>
                    <code>
Initially number was : 10
After setting bit at position 2 : 14
                    </code>
                </pre>
                <ul>
                    <li>num in binary was 0000 1010 = 10
                        <br>after shifting 1 (0000 0001) by 2 we get 4 (0000 0100)
                        <br>0000 1010 | 0000 0100 = 0000 1110 = 14
                    </li>
                </ul>
            </div>
            <div class="in">
                <h3>Clearing a bit</h3>
                <ul>
                    <li>The clearBit() function is used to clear a specific bit to 0 in a given number. It takes two
                        parameters: num, which represents the number you want to modify, and bitPos, which indicates the
                        position of the bit you want to clear. Here's the function implementation:</li>
                </ul>
                <div class='code'>
                    <div class='dotc'></div>
                    <pre>
                       <code>
#include &lt;stdio.h>
// Function to clear a specific bit
int clearBit(int num, int bitPos)
{
    int mask = 1 << bitPos;
    return num & ~mask;
}
int main()
{
    int num = 10; // Binary: 0000 1010

    // Clear bit at position 1
    num = clearBit(num, 1);
    printf("After clearing bit at position 1: %d\n", num);
    
    return 0;
}
                       </code>
                   </pre>
                </div>
                <p>Output &darr;</p>
                <pre>
                    <code>
After clearing bit at position 1: 8
                    </code>
                </pre>
                <ul>
                    <li>In this example, we clear the bit at position 1 (counting from the rightmost bit starting at 0)
                        to 0 in the number num, which is initially 10. The resulting value, after clearing the bit, is
                        8. This change occurs while preserving the other bits in the number.</li>
                </ul>
            </div>
            <div class="in">
                <h3>Toggling a bit</h3>
                <ul>
                    <li>The toggleBit() function is used to toggle a specific bit in a given number, which means
                        changing it from 0 to 1 or from 1 to 0. It takes two parameters: num, which represents the
                        number you want to modify, and bitPos, which indicates the position of the bit you want to
                        toggle. Here's the function implementation:</li>
                </ul>
                <div class='code'>
                    <div class='dotc'></div>
                    <pre>
                       <code>
#include &lt;stdio.h>
// Function to toggle a specific bit
int toggleBit(int num, int bitPos)
{
    int mask = 1 << bitPos;
    return num ^ mask;
}
int main()
{
    int num = 10; // Binary: 0000 1010

    // Toggle bit at position 0
    num = toggleBit(num, 0);
    printf("After toggling bit at position 0: %d\n", num);
    
    return 0;
}
                       </code>
                   </pre>
                </div>
                <p>Output &darr;</p>
                <pre>
                    <code>
After toggling bit at position 0: 11
                    </code>
                </pre>
                <ul>
                    <li>In this example, we toggle the bit at position 0 (counting from the rightmost bit starting at 0)
                        in the number num, which is initially 10. The resulting value, after toggling the bit, is 11.
                        This change occurs while preserving the other bits in the number.</li>
                </ul>
            </div>
        </div>
        <div id="t9" class="wh">
            <h2>Application of bitwise operator</h2>
            <ul>
                <li>Bitwise operators are used to perfrom operations on individual bit of integer values. They
                    manipulate
                    the binary representation of numbers of a bit level. Here are some common applications of bitwise
                    operators:
                    <ol>
                        <li>Bit manipulation: Bitwise operators allow you to manipulate individual bits within a binary
                            number, which can be useful in various scenarios such as setting, clearing, or toggling
                            specific bits.</li>
                        <li>Flags and masks: Bitwise operators are commonly used to represent and manipulate sets of
                            flags or options. Each flag corresponds to a specific bit, and bitwise operations like AND,
                            OR, XOR, and shifting can be used to enable, disable, or check the status of individual
                            flags.</li>
                        <li>Bit-level data storage and retrieval: Sometimes, data needs to be packed into a compact
                            representation to save memory or storage space. Bitwise operators can be used to store
                            multiple Boolean values or small integers in a single integer variable.</li>
                        <li>Bitwise operations on binary representations: Bitwise operators are essential in computer
                            arithmetic and logical operations. They are used in addition, subtraction, multiplication,
                            division, and other mathematical operations on binary numbers.</li>
                        <li>Bitwise shifting: Shifting operators (left shift and right shift) allow you to move the bits
                            of a binary number to the left or right. This operation is equivalent to multiplying or
                            dividing the number by powers of 2, respectively.</li>
                        <li>
                            Performance optimizations: In some cases, bitwise operations can provide performance
                            optimizations in low-level programming or when dealing with specific algorithms. They can be
                            used to replace costly arithmetic operations or provide efficient implementations of certain
                            algorithms.
                        </li>
                    </ol>
                </li>
                <li>Overall, bitwise operators are primarily used in low-level programming, embedded systems, network
                    protocols, graphics programming, cryptography, and other areas where direct manipulation of
                    individual bits is required.</li>
            </ul>
        </div>
    </div>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script src="../../../../public/main.js"></script>
</body>

</html>