<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Linux Case Study</title>
    <link rel="stylesheet" href="../../../../public/style.css">
    <link rel="icon" href="../../../../public/logo/favicon_io/favicon.ico">
    <link rel="stylesheet" id="highlightStylesheet"
        href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/tomorrow-night-blue.min.css">
</head>

<body class="bg-c">
    <div id="mySidepanel" class="sidepanel">
        <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">×</a>
        <a href="../index.html" class="home">back</a>
        <a href="#t1" class="link">Working of Linux</a>
        <a href="#t2" class="link">Why use Linux?</a>
        <a href="#t3" class="link">Creation of Linux</a>
        <a href="#t4" class="link">Development of Linux</a>
        <a href="#t5" class="link">Linux Files</a>
        <a href="#t7" class="link">Standard Unix Streams</a>
        <a href="#t6" class="link">Shell and programs</a>
        <div class="botbut">
            <a href="../unit4/index.html" class="link">&larr; Previous Topic</a>
        </div>
    </div>
    <div id="navbar" class="grad">
        <div>
            <div class="openbtn" onclick="openNav()">
                <div id="nav-icon1" for="nav-menu1">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </div>
        </div>
        <div>
            <h2>Linux Case Study</h2>
        </div>
    </div>
    <div class="content-box">
        <h1>Linux</h1>
        <ul>
            <li>Linux is a popular open-source operating system.</li>
            <li>It was initially created by Linus Torvalds in 1991. At the time, Torvalds was a computer science student
                at the University of Helsinki, Finland and began working on the Linux project as a personal endeavor.
                The name Linux is a combination of his first name, Linus, and Unix, the operating system that inspired
                his projects.</li>
            <li>Linux is considered one of the most stable, secure and reliable operating systems and is widely used in
                servers, supercomputers and enterprise environments.</li>
            <li>Today, Linux is one of the most widely used operating systems in the world, with an estimated 2.76% of
                all desktop computers and more than 90% of the world’s top supercomputers running on Linux, and approx.
                71.85% of all mobile devices run on Android, which is, you guessed it, Linux-based.</li>
            <li>The Linux community has expanded to include thousands of developers and users who work on the creation
                and upkeep of the operating system. Nowadays Linux has many distributions (versions) namely:
                <ol>
                    <li>Ubuntu</li>
                    <li>Fedora</li>
                    <li>Arch</li>
                    <li>Plasma</li>
                    <li>KDE</li>
                    <li>Mint</li>
                    <li>Manjaro</li>
                    <li>Nitrux (best for begginers)</li>
                    <li>Zorin OS (best for Windows user)</li>
                    <li>Pop!_OS (best for gaming)</li>
                    <li>Kodachi (best for privacy and security)</li>
                    <li>Rescatux (best for repair and rescue)</li>
                </ol>
            </li>
        </ul>
        <div id="t1" class="wh">
            <h2>How does Linux Work?</h2>
            <ul>
                <li>All Linux-based operating systems include a Linux kernel that manages hardware resources and a set
                    of software packages that make up the rest of the operating system. Organizations can also run linux
                    operating systems on Linux servers.
                    <ul>
                        <li><b>Kernel: </b>This is actually a component of the “Linux” system as a whole. The kernel,
                            which controls the CPU, memory, and peripherals, serves as the brain of the system. The
                            operating system’s kernel is at the most fundamental level.</li>
                        <li><b>Desktop Environment: </b>The user actually engages in interaction at this point. There
                            are numerous desktop environments available (GNOME, Cinnamon, Mate, Pantheon, Enlightenment,
                            KDE, Xfce, etc.). Every desktop environment has pre-installed programmes (file managers,
                            configuration tools, web browsers, games, etc.).</li>
                        <li><b>Shell: </b>Linux uses a command-line interface called a shell, which allows users to
                            interact with the operating system by typing commands. The shell interprets these commands
                            and communicates them to the kernel for execution.</li>
                    </ul>
                </li>
            </ul>
        </div>
        <div id="t2" class="wh">
            <h2>Why Use Linux?</h2>
            <p>There are several reasons why one might choose to use linux:</p>
            <ul>
                <li><b>Open-source: </b>Linux is open-source software, meaning that the source code is freely available
                    for anyone to use, modify, and distribute. This allows for a large and active community of
                    developers to contribute to the development and maintenance of the operating system.</li>
                <li><b>Customizability:</b> Linux is highly customizable, means users can easily install and configure
                    different software packages to suit their needs.</li>
                <li><b>Stability and security:</b> Linux is known for its stability and security, as it is less prone to
                    crashes and viruses than other operating systems.</li>
                <li><b>Cost-effective:</b> Linux is free to download and use, making it a cost- effective option for
                    individuals and businesses.</li>
            </ul>
        </div>
        <div id="t3" class="wh">
            <h2>Events leading to the creation of Linux</h2>
            <p>The emergence of Linux, one of the world’s most widely used open-source operating systems, can be traced
                to several important events and the work of a few people. Below is a summary of the major events that
                led to the emergence of Linux.</p>
            <ol>
                <li><b>Unix development:</b> Linux was heavily influenced by the Unix operating system developed by Bell
                    Labs in the late 1960s and early 1970s. Unix was developed as a multi-user, multi-tasking operating
                    system and has been widely used in science and research.</li>
                <li><b>Minix is born:</b> In the early 1980s, computer science professor Andrew S. Tanenbaum created a
                    small Unix-like operating system called Minix. Minix was developed as an educational tool and the
                    source code was made available to students.</li>
                <li><b>Linux is born: </b> In 1991, a 21-year-old student named <b>Linus Torvalds</b> began working on a
                    new operating system, he named it Linux. Linus was inspired by his Minix and used its source code as
                    a starting point for his own projects. He also drew heavily on Unix design principles.</li>
                <li><b>Release of Linux 0.01:</b> In September 1991, Linus released the first version of his Linux
                    called Linux 0.01. It was a command-line operating system and was freely distributed on the
                    Internet.</li>
                <li><b>Linux community development:</b> In the years that followed, Linux quickly gained popularity
                    among programmers and enthusiasts. A community of developers began to form around Linux,
                    contributing to the development of the operating system by writing code, filing bug reports, and
                    providing feedback.</li>
                <li><b>Enterprise Adoption:</b> In the late 1990s and early 2000s, the open- source nature of Linux made
                    it more flexible, cost-effective, and more secure than proprietary operating systems such as
                    Windows, making
                    it a popular choice for enterprises and businesses. started being hired by companies. This increased
                    acceptance led to the development of commercial support and services for Linux.</li>
                <li><b>Linux Distribution Growth:</b> As Linux became more popular, various groups of developers began
                    creating their own versions of the operating system, called distributions (distro). Some of the most
                    popular distributions are Red Hat, Debian, and Ubuntu. These distros contain the Linux kernel and a
                    number of packages of easy-to-use tools and software that make using Linux easy for both developers
                    and end users.</li>
                <li><b>Linux in the Consumer Market:</b> Linux has also entered the consumer market with the advent of
                    Linux-based mobile devices, smart TVs, and other consumer electronics.</li>
            </ol>
        </div>
        <div id="t4" class="wh">
            <h2>Development of Linux</h2>
            <p>The Linux ecosystem is a constantly evolving and expanding platform, so there is a lot of development
                going on. Notable recent developments include:</p>
            <ul>
                <li>Linux 5.11 kernel release. It includes new features such as AMD Zen 3 processor support, memory
                    management system improvements, and new hardware support.</li>
                <li>Continued development of various Linux distributions. Ubuntu 21.04 released in April 2021. It
                    features an updated Gnome desktop environment, improved ZFS file system support, and new security
                    features.</li>
                <li>Development of new open-source software and tools for Linux. For example, the release of version 6.0
                    of Ansible automation tools brings new features such as support for Windows Subsystem for Linux 2
                    (WSL2) and improved support for Kubernetes.</li>
                <li>The rise of containerization and orchestration technologies such as
                    Docker and Kubernetes. They are becoming more and more common in
                    deploying and managing Linux-based applications.</li>
                <li>Linux is growing in popularity in the cloud computing space, with
                    many major cloud providers offering Linux-based virtual machines and managed services.</li>
                <li>ecurity Enhancements: Linux developers have been actively working on improving security measures.
                    Features like secure boot, kernel lockdown, and improved access controls have been introduced to
                    enhance the overall security posture of Linux-based systems. Efforts have also been made to address
                    vulnerabilities and mitigate potential threats through regular security updates.</li>
                <li>Artificial Intelligence and Machine Learning: Linux has become a popular platform for AI and machine
                    learning applications. Frameworks like TensorFlow, PyTorch, and scikit-learn are widely used for
                    developing and deploying machine learning models on Linux systems. There has been a focus on
                    optimizing these frameworks and providing better support for hardware acceleration.</li>
            </ul>
        </div>
        <div id="t5" class="wh">
            <h2>Linux Files</h2>
            <ul>
                <li>In Linux system, everything is a file and if it is not a file, it is a process. A file doesn't
                    include only text files, images and compiled programs but also include partitions, hardware device
                    drivers and directories. Linux consider everything as as file.</li>
                <li><b>Types of Files:</b>
                    <ol>
                        <li><b>Regular files: </b>It contain programs, executable files and text files.</li>
                        <li><b>Directory files (d)</b>: It is shown in blue color. It contain list of files.</li>
                        <li><b>Special files</b>
                            <ul>
                                <li>Block file (b)</li>
                                <li>Character device file (c)</li>
                                <li>Named pipe file (p)</li>
                                <li>Symbolic link file (l)</li>
                                <li>Socket file (s)</li>
                            </ul>
                        </li>
                    </ol>
                </li>
            </ul>
            <div class="in">
                <h3>Absolute and Relative Pathnames</h3>
                <ul>
                    <li>A path is a unique location of a file or a folder in a file system of an OS. A path to a file is
                        combination of / and alpha-numeric characters.</li>
                </ul>
                <div class="wh">
                    <p><b>Absolute Pathname</b></p>
                    <ul>
                        <li>An absolute path is defined as the specifying the location of a file or directory from the
                            root directory (/).</li>
                    </ul>
                    <p>To write an abosulte path-name:
                    <ul>
                        <li>Start at the root directory (/) and work down.</li>
                        <li>Write a slash (/) after every directory name (last one is optional)</li>
                        <li>For example:
                            <pre>
                                    <code>  
$cat abc.sql
                                    </code>
                                </pre>
                            Note: we don't have to write '$' its already written in terminal. <br>
                            'cat' command is used for displaying content of a file, in this case abc.sql.
                            <br>The above command only work when there is a file 'abc.sql' in the current directory.
                            <pre>
                                    <code>  
$cat /home/database/abc.sql
                                    </code>
                                </pre>
                            In the above example, if the first character of a pathname is /, the file’s location must be
                            determined with respect to root.
                        </li>
                        <li>An <b>absolute path</b> is defined as specifying the location of a file or directory from
                            the root directory(/). In other words,we can say that an absolute path is a complete path
                            from start of actual file system from / directory.</li>
                    </ul>
                    </p>
                </div>
                <div class="wh">
                    <p><b>Relative path</b></p>
                    <ul>
                        <li>Relative path is defined as the path related to the present working directly(pwd). </li>
                        <li>It starts at your current directory and never starts with a /.</li>
                        <li>To be more specific let’s take a look on the below figure in which if we are looking for
                            photos then absolute path for it will be provided as /home/jono/photos but assuming that we
                            are already present in jono directory then the relative path for the same can be written as
                            simple <i>photos</i>.
                            <br><img src="../../images/linux1.svg" alt="" class="wb">
                        </li>
                    </ul>
                    <p><b>Using . and .. in Relative Path-names</b></p>
                    <ul>
                        <li>Linux offers a shortcut in the <b>relative pathname</b> that uses either the current or
                            parent directory as reference and specifies the path relative to it. </li>
                        <li>A relative path name uses one of these cryptic symbols:
                            <ul>
                                <li><b>. (a single dot) - </b> this represents the current directory.</li>
                                <li><b>.. (two dots)</b> - this represents the parent directory.</li>
                            </ul>
                        </li>
                        <li>If we are currently in directory /home/kt/abc and now you use .. as an argument to
                            <b>cd</b> to move to the parent directory /home/kt as :
                            <pre>
                                <code>
$pwd 
/home/kt/abc 
$cd ..            *** moves one level up ***
$pwd 
/home/kt 
                                </code>
                            </pre>
                            Note: Now when / is used with .. has a different meaning, instead of moving down a
                            level, it moves one level up.
                            <pre>
                        <code>
$pwd 
/home/kt/abc 
$cd ../..          *** moves two level up ***
$pwd 
/home
                        </code>
                    </pre>
                        </li>
                    </ul>
                </div>
            </div>
            <div class="in">
                <h3>Example of Absolute and Relative Path</h3>
                <p>Suppose you are currently located in home/kt and you want to change your directory to home/kt/abc.
                    Let's see both the absolute and relative path concepts to do this:</p>
                <div class="wh">
                    <p><b>1. Changing directory with relative path concept:</b></p>
                    <pre>
                        <code>
$pwd 
/home/kit 
$cd abc 
$pwd 
/home/kit/abc
                        </code>
                    </pre>
                </div>
                <div class="wh">
                    <p><b>2. Changing directory with absolute path concept:</b></p>
                    <pre>
                        <code>
$pwd 
/home/kit 
$cd /home/kt/abc 
$pwd 
/home/kit/abc
                        </code>
                    </pre>
                </div>
            </div>
            <div class="in">
                <h3>Commands to navigate your Linux file system</h3>
                <div class="wh">
                    <p><b>pwd</b></p>
                    <ul>
                        <li>This command displays the <i>present working directory</i>, letting you know where you are
                            now.</li>
                    </ul>
                    <p>Example &darr;</p>
                    <pre>
                        <code>
$pwd
/home/database/sql/dataone/
                        </code>
                    </pre>
                </div>
                <div class="wh">
                    <p><b>tree</b></p>
                    <ul>
                        <li>The tree command displays filesystem information in a similar manner to a graphical
                            interface. This can be handy for new Linux users who are more used to the hierarchical
                            filesystem display in other operating systems.</li>
                    </ul>
                    <img src="../../images/linux2.svg" alt="" class="wb">
                </div>
                <div class="wh">
                    <p><b>cd</b></p>
                    <ul>
                        <li>This command moves you to the specified directory, changing your present working directory
                            location.</li>
                        <li>For example, to use an absolute path to move to the /etc/ssh directory, type the following
                            command:
                            <pre>
                                <code>
$cd /etc/ssh
                                </code>
                            </pre>
                            By using the absolute path, it doesn't matter where in the filesystem you currently are.
                        </li>
                    </ul>
                </div>
                <div class="wh">
                    <p><b>. .. ~</b></p>
                    <p>Take a shortcut. These make navigation easier. Three of them are:
                    <ol>
                        <li>Single dot, or .</li>
                        <li>Double dot, or ..</li>
                        <li>Tilde, or ~</li>
                    </ol>
                    </p>
                    <ul>
                        <li>The single dot represents the present working directory, or where you are right now. Say
                            you're in your home directory and you want to copy the sshd_config file from /etc/ssh. You
                            can specify it with just a dot because you're copying the file to your current directory.
                            The command looks like this:
                            <pre>
                                <code>
$sudo cp /etc/ssh/sshd_config .
                                </code>
                            </pre>
                        </li>
                        <li>Double dots represent the parent directory, or the directory immediately above the current
                            one in the filesystem. If there's a subdirectory namedRockin theMusicdirectory, thenMusicis
                            the parent directory ofRock. As another example, consider where log files are stored:
                            /var/log. In that case, var is the parent directory of log (and the filesystem root / is the
                            parent of var).
                            <br>So, to move from the current <i>Rock</i> directory to the <i>Music</i> directory above
                            it, type:
                            <pre>
                                <code>
$cd ..
                                </code>
                            </pre>
                        </li>
                        <li>Similarly, the tilde character ~ represents the current, logged-on user's home directory. To
                            copy the sshd_config file from /etc/ssh to your home directory (no
                            matter where in the filesystem I'm presently located), type:
                            <pre>
                            <code>
$cp /etc/ssh/sshd_config ~
                            </code>
                        </pre>
                        </li>
                    </ul>
                </div>
                <div class="wh">
                    <p>Home directory</p>
                    <ul>
                        <li>The directory in which you find yourself when you first login is called your home directory.
                        </li>
                        <li>You can go in your home directory anytime using the following command −
                            <pre>
                                <code>
$cd ~
                                </code>
                            </pre>
                        </li>
                        <li>Here ~ indicates the home directory. Suppose you have to go in any other user's home
                            directory, use the following command −
                            <pre>
                            <code>
$cd ~username
                            </code>
                        </pre>
                        </li>
                        <li>To go in your last directory, you can use the following command −
                            <pre>
                                <code>
$cd -
                                </code>
                            </pre>
                        </li>
                    </ul>
                </div>
                <div class="wh">
                    <p><b>ls</b></p>
                    <ul>
                        <li>Listing Directories: To list the files in a directory, you can use the following syntax -
                            <pre>
                                <code>
$ls dirname
                                </code>
                            </pre>
                        </li>
                    </ul>
                </div>
                <div class="wh">
                    <p><b>mkdir</b></p>
                    <ul>
                        <li>Creating Directories, directories are created by the following command -
                            <pre>
                                <code>
$mkdir mydir
                                </code>
                            </pre>
                            Creates the directory <b>mydir</b> in the currect directory.
                        </li>
                        <li> Here is another example -
                            <pre>
                            <code>
$mkdir /tmp/test-dir
                            </code>
                        </pre>
                            This command creates the directory test-dir in the /tmp directory. The mkdir command
                            produces no output if it successfully creates the requested directory.
                        </li>
                        <li>
                            If you give more than one directory on the command line, mkdir creates each of the
                            directories. For example, −
                            <pre>
                                <code>
$mkdir docs pub
                                </code>
                            </pre>
                            Creates the directories docs and pub under the current directory.
                        </li>
                    </ul>
                </div>
                <div class="wh">
                    <p>Creating Parent Directories</p>
                    <ul>
                        <li>Sometimes when you want to create a directory, its parent directory or directories might not
                            exitst. In this case, <b>mkdir</b> issues an error message as follows-
                            <pre>
                            <code>
$mkdir /tmp/amrood/test
mkdir: Failed to make directory "/tmp/amrood/test";
No such file or directory
                            </code>
                        </pre>
                        </li>
                        <li>In such cases, you can specify the <b>-p</b> option to the <b>mkdir</b> command. It creates
                            all the necessay directories for you. For example -
                            <pre>
                            <code>
$mkdir -p /tmp/amrood/test
                            </code>
                        </pre>
                        </li>
                    </ul>
                </div>
                <div class="wh">
                    <p><b>rmdir</b></p>
                    <ul>
                        <li>Removing Directories: Directories can be deleted using the <b>rmdir</b> command as follows -
                            <pre>
                            <code>
$rmdir dirname
                            </code>
                        </pre>Note − To remove a directory, make sure it is empty which means there should not be
                            any file or sub-directory inside this directory.
                        </li>
                        <li>You can remove multiple directories at a time as follows -
                            <pre>
                                <code>
$rmdir dirname1 dirname2 dirname3
                                </code>
                            </pre>
                            The above command removes the directories dirname1, dirname2, and dirname3, if they are
                            empty. The rmdir command produces no output if it is successful.
                        </li>
                    </ul>
                </div>
                <div class="wh">
                    <p><b>mv</b></p>
                    <ul>
                        <li>Renaming Directores: The mv (move) command can also be used to rename a directory. The
                            syntax is as follows -
                            <pre>
                                <code>
$mv olddir newdir
$mv mydir yourdir
                                </code>
                            </pre>
                        </li>
                    </ul>
                </div>
                <div class="wh">
                    <p><b>ls -la</b></p>
                    <ul>
                        <li>
                            If we enter the command to show a listing of the current working directories/files and use
                            the <b>-a option</b> to list all the files and the <b>-l option</b> to provide the long
                            listing, we will receive the following result
                            <pre>
                                <code>
pravin@Pravins-MacBook-Air BCA % ls -la
total 64
drwxr-xr-x@ 10 pravin  staff   320 Apr 18 19:01 .
drwxrwxrwx@  8 pravin  staff   256 Feb 15 09:46 ..
-rw-r--r--@  1 pravin  staff  8196 Jun  4 10:58 .DS_Store
drwxr-xr-x  15 pravin  staff   480 Jun  5 12:29 .git
-rw-r--r--   1 pravin  staff     8 Feb 18 12:13 .gitignore
drwxr-xr-x   3 pravin  staff    96 Apr 18 19:01 .vscode
-rw-r--r--@  1 pravin  staff  8661 May 28 09:15 index.html
drwxr-xr-x   9 pravin  staff   288 May 21 10:34 public
-rw-r--r--   1 pravin  staff   674 Apr 17 06:09 readme.md
drwxr-xr-x   6 pravin  staff   192 Apr 27 16:18 resources
                                </code>
                            </pre>
                        </li>
                    </ul>
                </div>
                <div class="wh">
                    <p><b>Creating files</b></p>
                    <ul>
                        <li>You can use <b>vi</b> editor to create ordinary files on any Unix system. You simply need to
                            give the following command:</li>
                    </ul>
                    <pre>
                        <code>
$vi filename
                        </code>
                    </pre>
                    <ul>
                        <li>The above command will open a file with the given filename. Now, press the key <b>i</b> to
                            come into the edit mode. Once you are in the edit mode, you can start writing your content
                            in the file as in the following program :</li>
                    </ul>
                    <pre>
                        <code>
This is unix file... and we are writing on this file.
I'm going to save this content in the file.
                        </code>
                    </pre>
                    <ul>
                        <li>Press <b>esc</b> to come out of the edit mode</li>
                        <li>Press two keys <b>Shift + Z</b> together to come out of the file completely.</li>
                        <li>You will now have a file with <b>filename</b> in the current directory.</li>
                    </ul>
                </div>
                <div class="wh">
                    <p><b>Editing files</b></p>
                    <ul>
                        <li>You can edit an existing file using the <b>vi</b> editor.</li>
                    </ul>
                    <pre>
                        <code>
$vi filename
                        </code>
                    </pre>
                    <ul>
                        <li>Once the file in opened, you can come in the edit mode by pressing the key <b>i</b> and then
                            you can proceed by editingg the file.</li>
                    </ul>
                </div>
                <div class="wh">
                    <p>Display content of a file</p>
                    <ul>
                        <li>Use <b>cat</b> command to see the content of a file. Following is the simple content of the
                            above created file:</li>
                    </ul>
                    <pre>
                        <code>
$cat filename
This is unix file... and we are writing on this file.
I'm going to save this content in the file.
$
                        </code>
                    </pre>
                </div>
                <div class="wh">
                    <p><b>Copying files</b></p>
                    <ul>
                        <li>To make a copy of a file use the <b>cp</b> command. The basic syntax of the command is:</li>
                    </ul>
                    <pre>
                        <code>
$cp source_file destination_file
                        </code>
                    </pre>
                    <ul>
                        <li>Following is the example to create a copy of the existing file <b>filename.</b></li>
                    </ul>
                    <pre>
                        <code>
$cp filename copyfile
                        </code>
                    </pre>
                    <ul>
                        <li>You wil find one more file <b>copyfile</b> in your current directory. This file will exactly
                            be the same as the original file <b>filename.</b></li>
                    </ul>
                </div>
                <div class="wh">
                    <p><b>Renaming files</b></p>
                    <ul>
                        <li>We same command for files as we have used for folders.</li>
                        <li>To change the name of a file, use the <b>mv</b> command. Following is the basic syntax:</li>
                    </ul>
                    <pre>
                        <code>
$mv myold_file newfile
                        </code>
                    </pre>
                </div>
                <div class="wh">
                    <p><b>Deleting files</b></p>
                    <ul>
                        <li>To delete an existing file, use the <b>rm</b> command. Following is the basic syntax:</li>
                    </ul>
                    <pre>
                        <code>
$rm filename
                        </code>
                    </pre>
                    <ul>
                        <li>You can remove multiple files at a time with the command given below −</li>
                    </ul>
                    <pre>
                        <code>
$rm filename1 filename2 filename3
                        </code>
                    </pre>
                </div>
            </div>
        </div>
        <div id="t7" class="wh">
            <h2>Standard Unix Streams</h2>
            <p>Under normal circumstances, every Unix program has three streams (files) opened for it when it starts up
            </p>
            <ul>
                <li><b>stdin:</b> This is referred to as the standard input and the associated file descriptor is 0.
                    This is also represented as STDIN. The Unix program will read the default input from STDIN.</li>
                <li><b>stdout: </b>This is referred to as the standard output and the associated file descriptor is 1.
                    This is also represented as STDOUT. The Unix program will write the default output at STDOUT.</li>
                <li><b>stderr: </b> This is referred to as the standard error and the associated file descriptor is 2.
                    This is also represented as STDERR. The Unix program will write all the error messages at STDERR.
                </li>
            </ul>
            <p>We will discuss in detail about file permission and access modes in Unix. File ownership is an important
                component of Unix that provides a secure method for storing files. Every file in Unix has the following
                attributes −</p>
            <ul>
                <li><b>Owner permissions:</b> The owner's permissions determine what actions the owner of the file can
                    perform on the file.</li>
                <li><b>Group permissions:</b> The group's permissions determine what actions a user, who is a member of
                    the group that a file belongs to, can perform on the file.</li>
                <li><b>Other (world) permissions:</b> The permissions for others indicate what action all other users
                    can perform on the file.</li>
            </ul>
            <div class="in">
                <h3>The Permission Indicators
                </h3>
                <ul>
                    <li>While using ls -l command, it displays various information related to file permission as
                        follows:</li>
                </ul>
                <pre>
                    <code>
 $ls -l /home/amrood
-rwxr-xr-- 1 amrood users 1024 Nov 2 00:10 myfile 
drwxr-xr--- 1 amrood users 1024 Nov 2 00:10 mydir
                    </code>
                </pre>
                <ul>
                    <li>Here, the first column represents different access modes, i.e., the permission associated with a
                        file or a directory.
                    </li>
                    <li>The permissions are broken into groups of threes, and each position in the group denotes a
                        specific permission, in this order: read (r), write (w), execute (x):
                        <ul>
                            <li>The first three characters (2-4) represent the permissions for the file's owner. For
                                example, -rwxr-xr-- represents that the owner has read (r), write (w) and execute (x)
                                permission.</li>
                            <li>The second group of three characters (5-7) consists of the permissions for the group to
                                which the file belongs. For example, -rwxr-xr-- represents that the group has read (r)
                                and execute (x) permission, but no write permission.</li>
                            <li>The last group of three characters (8-10) represents the permissions for everyone else.
                                For example,-rwxr-xr--represents that there isread (r) only permission.</li>
                        </ul>
                    </li>
                </ul>
            </div>
            <div class="in">
                <h3>File Access Modes</h3>
                <p>The permissions of a file are the first line of defense in the security of a Unix system. The basic
                    building blocks of Unix permissions are the read, write, and execute permissions, which have been
                    described below :</p>
                <ul>
                    <li><b>Read</b>: Grants the capability to read, i.e., view the contents of the file.</li>
                    <li><b>Write</b>: Grants the capability to modify, or remove the content of the file.
                    </li>
                    <li><b>Execute</b>: User with execute permissions can run a file as a program.</li>
                </ul>
            </div>
            <div class="in">
                <h3>Directory Access Modes</h3>
                <p>
                    Directory access modes are listed and organized in the same manner as any other file. There are a
                    few differences that need to be mentioned:</p>
                <ul>
                    <li><b>Read</b>: Access to a directory means that the user can read the contents. The user can look
                        at the filenames inside the directory.</li>
                    <li><b>Write</b>: Access means that the user can add or delete files from the directory.</li>
                    <li><b>Execute</b>: Executing a directory doesn't really make sense, so think of this as a traverse
                        permission. A user must have execute access to the bin directory in order to execute the ls or
                        the cd command.</li>
                </ul>
            </div>
            <div class="in">
                <h3>Changing Permissions</h3>
                <p>To change the file or the directory permissions, you use the chmod (change mode) command. There are
                    two ways to use chmod — the symbolic mode and the absolute mode.</p>
                <div class="wh">
                    <p><b>Using chmod in Symbolic Mode</b></p>
                    <p>The easiest way for a beginner to modify file or directory permissions is to use the symbolic
                        mode.
                        With symbolic permissions you can add, delete, or specify the permission set you want by using
                        the
                        operators in the following table.</p>
                    <pre>
                    <code>
Sr. No          Chmod operator & Description
  1             +   Adds the designated permission(s) to file or directory
  2             -   Removes the designated permission(s) to file or directory
  3             =   Sets the designated permission(s).
                    </code>
                </pre>
                    <p>Here's an example using testfile. Running ls -l on the testfile shows that the file's permissions
                        are
                        as follows</p>
                    <pre>
                        <code>
$ls -l testfile
-rwxrwxr-- 1 amrood users 1024 Nov 2 00:10 testfile
                        </code>
                    </pre>
                    <p>Then each example chmod command from the preceding table is run on the testfile, followed by ls
                        –l, so you can see the permission changes</p>
                    <pre>
                        <code>
$chmod o+wx testfile
$ls -l testfile
-rwxrwxrwx 1 amrood users 1024 Nov 2 00:10 testfile 
$chmod u-x testfile
$ls -l testfile
-rw-rwxrwx 1 amrood users 1024 Nov 2 00:10 testfile 
$chmod g = rx testfile
$ls -l testfile
-rw-r-xrwx 1 amrood users 1024 Nov 2 00:10 testfile
                        </code>
                    </pre>
                    <p>Here's how you can combine these commands on a single line</p>
                    <pre>
                        <code>
$chmod o+wx,u-x,g = rx testfile
$ls -l testfile
-rw-r-xrwx 1 amrood users 1024 Nov 2 00:10 testfile
                        </code>
                    </pre>
                </div>
                <div class="wh">
                    <p><b>Using chmod with Absolute Permissions</b></p>
                    <p>The second way to modify permissions with the chmod command is to use a number to specify each
                        set of permissions for the file.</p>
                    <p>
                        Each permission is assigned a value, as the following table shows, and the total of each set of
                        permissions provides a number for that set.</p>
                    <pre>
                            <code>
Number   Octal Permission Representation                                     Ref 
  0          No permission                                                   ---
  1          Execute permission                                              --x
  2          Write permission                                                -w-
  3          Execute and write permission: 1 (execute) + 2 (write) = 3       -wx
  4          Read permission                                                 r--
  5          Read and execute permission: 4 (read) + 1 (execute) = 5         r-x
  6          Read and write permission: 4 (read) + 2 (write) = 6             rw-
  7          All permissions: 4 (read) + 2 (write) + 1 (execute) = 7         rwx
                            </code>
                        </pre>
                    <p>Here's an example using the testfile. Running ls -1 on the testfile shows that the file's
                        permissions are as follows:</p>
                    <pre>
                            <code>
$ls -l testfile
-rwxrwxr-- 1 amrood users 1024 Nov 2 00:10 testfile
                            </code>
                        </pre>
                    <p>
                        Then each example chmod command from the preceding table is run on the testfile, followed by ls
                        –l, so you can see the permission changes</p>
                    <pre>
                                <code>
$ chmod 755 testfile
$ls -l testfile
-rwxr-xr-x 1 amrood users 1024 Nov 2 00:10 testfile $chmod 743 testfile
$ls -l testfile
-rwxr---wx 1 amrood users 1024 Nov 2 00:10 testfile $chmod 043 testfile
$ls -l testfile
----r---wx 1 amrood users 1024 Nov 2 00:10 testfile
                                </code>
                            </pre>
                </div>
            </div>
            <div class="in">
                <h3>Changing Ownership</h3>
                <p>The <b>chown</b> command changes the ownership of a file. The basic syntax is as follows:</p>
                <pre>
                    <code>
$chown user filelist
                    </code>
                </pre>
                <p>The value of the user can be either the name of a user on the system or the user id (uid) of a user
                    on the system.
                    <br>The following example will help you understand the concept
                </p>
                <pre>
                    <code>
$chown amrood testfile
$
                    </code>
                </pre>
                <p>Changes the owner of the given file to the user amrood. <br>
                    <b>NOTE</b> − The super user, root, has the unrestricted capability to change the ownership of any
                    file but normal users can change the ownership of only those files that they own.
                </p>
            </div>
            <div class="in">
                <h3>Changing Group Ownership</h3>
                <p>The <b>chgrp</b> command changes the group ownership of a file. The basic syntax is as follows</p>
                <pre>
                    <code>
$ chgrp group filelist
                    </code>
                </pre>
                <p>The value of group can be the name of a group on the system or the group ID (GID) of a group on the
                    system. <br>
                    Following example helps you understand the concept: </p>
                <pre>
                        <code>
$ chgrp special testfile 
$ 
                        </code>
                    </pre>
                <p>Changes the group of the given file to special group.</p>
            </div>
            <div class="in">
                <h3>SUID and SGID File Permission</h3>
                <p>Often when a command is executed, it will have to be executed with special privileges in order to
                    accomplish its task.
                    <br><br>
                    As an example, when you change your password with the <b>passwd</b> command, your new password is
                    stored in the file <b>/etc/shadow</b>.
                    <br><br>
                    As a regular user, you do not have <b>read</b> or <b>write</b> access to this file for security
                    reasons, but when you change your password, you need to have the write permission to this file. This
                    means that the <b>passwd</b> program has to give you additional permissions so that you can write to
                    the file <b>/etc/shadow</b>.
                    <br><br>Additional permissions are given to programs via a mechanism known as the Set User ID (SUID)
                    and Set Group ID (SGID) bits.
                    <br><br>
                    When you execute a program that has the SUID bit enabled, you inherit the permissions of that
                    program's owner. Programs that do not have the SUID bit set are run with the permissions of the user
                    who started the program.
                    <br><br>This is the case with SGID as well. Normally, programs execute with your group permissions,
                    but instead your group will be changed just for this program to the group owner of the program.
                    <br><br>The SUID and SGID bits will appear as the letter "s" if the permission is available. The
                    SUID "s" bit will be located in the permission bits where the owners’ execute permission normally
                    resides.
                    <br>For example, the command
                </p>
                <pre>
    <code>
$ ls -l /usr/bin/passwd
-r-sr-xr-x 1 root bin 19031 Feb 7 13:47 /usr/bin/passwd* $
    </code>
</pre>
                <p>
                    Shows that the SUID bit is set and that the command is owned by the root. A capital letter <b>S</b>
                    in the execute position instead of a lowercase s indicates that the execute bit is not set.
                    <br>If the sticky bit is enabled on the directory, files can only be removed if you are one of the
                    following users:
                <ul>
                    <li>The owner of the sticky directory</li>
                    <li>The owner of the file being removed</li>
                    <li>The super user, root</li>
                </ul>
                To set the SUID and SGID bits for any directory try the following command
                </p>
                <pre>
                    <code>
$ chmod ug+s dirname
$ ls -l
drwsr-sr-x 2 root root 4096 Jun 19 06:45 dirname 
$
                    </code>
                </pre>
            </div>
        </div>
        <div id="t6" class="wh">
            <ul>
                <li>A Shell provides you with an interface to the Unix system. It gathers input from you and executes
                    programs based on that input. When a program finishes executing, it displays that program's output.
                </li>
                <li>Shell is an environment in which we can run our commands, programs, and shell scripts. There are
                    different flavors of a shell, just as there are different flavors of operating systems. Each flavor
                    of shell has its own set of recognized commands and functions.
                </li>
            </ul>
            <h2>Shell Prompt</h2>
            <ul>
                <li>The prompt, <b>$</b> which is called the <b>command prompt</b>, issued by the shell. While the
                    prompt is displayed, you can type a command.</li>
                <li>Shell reads your input after you press <b>Enter</b>. It determines the command you want executed by
                    looking at the first word of your input. A word is an unbroken set of characters. Spaces and tabs
                    separate words.</li>
                <li>Following is a simple example of <b>data</b> command, which displays the current date and time-</li>
                <pre>
                    <code>
$date
                    </code>
                </pre>
            </ul>
            <p><b>Shell Types</b></p>
            <ul>
                <li>In unix, there are two major types of shells-
                    <ol>
                        <li>Bourne shell: If you are using a Bourne-type shell, the <b>$</b> character is the default
                            prompt.</li>
                        <li>C shell: If you are using a C-type shell, the <b>%</b> character is the default prompt.</li>
                    </ol>
                </li>
                <li>The bourne shell has the following subcategories:
                    <ol>
                        <li>Bourne shell</li>
                        <li>Korn shell</li>
                        <li>Bourne again shell</li>
                        <li>POSIX shell</li>
                    </ol>
                </li>
                <li>The different C-type shells follow:
                    <ul>
                        <li>C shell</li>
                        <li>TENEX/TOPS C shell</li>
                    </ul>
                </li>
                <li>The original Unix shell was written in the mid-1970s by Stephen R. Bourne while he was at the AT & T
                    Bell labs in New Jersey.</li>
                <li>Bourne shell was the first shell to appear on Unix systems, thus it is referred to as "the shell".
                </li>
                <li>We are going to cover most of the shell concepts that are based on the Borne shell.</li>
            </ul>
            <div class="in">
                <h3>Shell scripts</h3>
                <ul>
                    <li>Comments are preceded by <b>#</b> sign.
                        <pre>
                        <code>
# this is a comment
                        </code>
                    </pre>
                    </li>
                    <li>Comments provide information about the script, such as its purpose, author, and date. The
                        comment lines are not executed by the shell and are purely for human readability.</li>
                </ul>
            </div>
            <div class="in">
                <h3>Example scripts</h3>
                <ul>
                    <li>Scripts have <b>.sh</b> extension.</li>
                    <li>Before you add anything else to your script, you need to alert the system that a shell script is
                        being started. This is done using the <b>shebang</b> construct. For example:
                        <pre>
                        <code>
#!/bin/sh
                        </code>
                    </pre>
                    </li>
                    <li>This tells the system that the commands that follow are to be executed by the Bourne shell. It's
                        called a shebang because the <b>#</b> symbol is called a hash, and <b>!</b> symbol is called a
                        bang.</li>
                    <li>To create a script containing these commands, you put the shebang line first and then add the
                        commands:
                        <pre>
                            <code>
#!/bin/bash
pwd
ls
                            </code>
                        </pre>
                    </li>
                </ul>
            </div>
            <div class="in">
                <h3>Shell comments</h3>
                <ul>
                    <li>You can put your comments in your script as follows:</li>
                </ul>
                <pre>
                    <code>
#!/bin/bash 

# Author: Zara Ali
# Copyright(c) Tutorialspoint.com 
# Script follows here:
pwd 
ls
                    </code>
                </pre>
            </div>
            <div class="in">
                <h3>Extended Shell Scripts</h3>
                <ul>
                    <li>Shell scripts have several required constructs that tell the shell environment what to do and
                        when to do it.</li>
                    <li>The shell is a real programming language, complete with variables, control structures, and so
                        forth. No matter how complicated a script gets, it is still just a list of commands executed
                        sequentially.
                    </li>
                    <li>The following script uses the read command which takes the input from the keyboard and assigns
                        it as the value of the variable PERSON and finally prints it on STDOUT.</li>
                </ul>
                <pre>
                    <code>
#!/bin/sh
# Author : Zara Ali
# Copyright (c) Tutorialspoint.com # Script follows here:
echo "What is your name?" 
read PERSON
echo "Hello, $PERSON"
                    </code>
                </pre>
                <ul>
                    <li>Here is a sample run of the script:</li>
                </ul>
                <pre>
                    <code>
$./test.sh
What is your name? Zara Ali
Hello, Zara Ali
$
                    </code>
                </pre>
            </div>
            <div class="in">
                <h3>String programs in Linux</h3>
                <ul>
                    <li>String concatenation is the process of appending a string to the end of another string. This can
                        be done with shell scripting using two methods: using the += operator, or simply writing strings
                        one after the other. The examples below
                        show some shell scripts that can be used to concatenate strings.</li>
                </ul>
                <div class="wh">
                    <p><b>Example 1:</b>
                        <br>In this example, we will concatenate two strings using <b>+=</b> operator. The input strings
                        will be stored in two variables, <b>a</b> and <b>b</b>.
                        <br>Code &darr;
                    </p>
                    <pre>
                    <code>
#Read inputs a and b and store string variables in them.

read a b 
#append b to the string a 
a+=$b

#Output the resulting string 
echo $a
                    </code>
                </pre>
                </div>
                <div class="wh">
                    <p><b>Example 2:</b>
                        <br>In this example, we have two variables a and b, and we stored a string in each variable. We
                        want to concatenate them one after the other. The result of concatenation will be stored in the
                        variable c.
                        <br>Code &darr;
                    </p>
                    <pre>
                    <code>
#Read inputs a and b and store string variables in them. 

read a b

#concatenate the strings by writing one after the other. Store the result in c

c=$a$b

#output c
echo $c
                    </code>
                </pre>
                </div>
                <div class="wh">
                    <p><b>Problem solution:</b>
                        <br>Here, we will create a shell script program to create two variables and then print values of
                        variables on the console screen.
                        <br><b>Program/Source code:</b>
                        <br>The source code to <b>create a Linux shell script program to create and print the value of
                            variables</b> is given below. The given program is compiled and executed successfully on
                        Ubuntu 20.04.
                    </p>
                    <pre>
                <code>
#!/bin/bash

# Program name: "printVar.sh"

# Linux shell script program to create and print the value of variables.

country="India"
year=2021

echo "Country name: $country" 
echo "Year: $year"
                </code>
            </pre>
                    <p>Output &darr;</p>
                    <pre>
                <code>
$ sh printVar.sh
Country name: India
Year: 2021
                </code>
            </pre>
                    <p><b>Explanation:</b>
                        <br>
                        Here, we created two variables country, year. which are initialized
                        with "India", 2021 respectively. After that, we printed the value of variables on the console
                        screen using echo command.
                    </p>
                </div>
            </div>
            <div class="wh">
                <p><b>Problem solution:</b>
                    <br>Here, we will create a shell script program to add two integer numbers and then print the sum of
                    numbers on the console screen.
                    <br><b>Program/Source code:</b>
                    <br>The source code to <b>create a Linux shell script program to add two numbers</b> is given below.
                </p>
                <pre>
            <code>
#!/bin/bash

# Program name: "add_two_num.sh"

# Shell script program to add two numbers.

num1=10
num2=20

num3=`expr $num1 + $num2`

echo "Sum is: $num3"
            </code>
        </pre>
                <p>Now, we will save the shell script program with "add_two_num.sh" name.</p>
                <p><b>Output &darr;</b></p>
                <pre>
            <code>
$ sh add_two_num.sh
Sum is: 30
            </code>
        </pre>
                <p><b>Explanation:</b>
                    <br>In the above program, we created two variables num1, num2 that are initialized with 10 and 20
                    respectively. Here, we used the expr command to add two values of variables and then print the sum
                    of two numbers on the console screen.
                </p>
            </div>
            <div class="wh">
                <p><b>Problem solution:</b>
                    <br>Here, we will create a shell script program to swap to numbers and then print both variables
                    after swapping on the console screen.
                    <br><b>Program/Source code:</b>
                    <br>The source code to create a Linux shell script program to swap two numbers is given below.
                </p>
                <pre>
                    <code>
#!/bin/bash

# Program name: "swap.sh"

# shell script program to swap two numbers.

num1=10
num2=20

echo "Before Swapping" 
echo "Num1: $num1"
echo "Num2: $num2"

num3=$num1
num1=$num2
num2=$num3

echo "After Swapping" 
echo "Num1: $num1" 
echo "Num2: $num2"
                    </code>
                </pre>
                <p>Output &darr;</p>
                <pre>
                    <code>
$ sh swap.sh
Before Swapping
Num1: 10
Num2: 20
After Swapping
Num1: num2
Num2: num3
                    </code>
                </pre>
            </div>
        </div>
    </div>
    <div class="content-box">
        <h2>Previous Year Question</h2>
        <div class="wh">
            <h3>Q- Explain various file handling commands in Linux with example.</h3>
        </div>
        <div class="wh">
            <h3>Explain the working of logical and relational operators in Linux.</h3>
            <div class="in">
                <p>Sol:</p>
                <ul>
                    <li>Logical and relational operatos in Linux are primarily used within shell scripting and
                        command-line operations. These operators allow you to perform logical and relational comparisons
                        on values or expressions to determine the truth or falsehood of a condition. They are commonly
                        used in conditional statements, loops, and decision making processes.</li>
                </ul>
                <p><b>Logical Operators</b></p>
                <ul>
                    <li>AND (&&): Represents the logical AND operation. It returns true if both operands are true,
                        otherwise, it return fale.</li>
                    <li>OR (||): Represents the logical OR operation. It returns true if either of the operands is true;
                        otherwise, it returns false.</li>
                    <li>NOT (!): Represents the logical NOT operation. It reverses the logical state of its operand. If
                        a condition is true, the NOT operator makes it false, and vice versa.</li>
                </ul>
                <p>These operators are typically used to combine multiple conditions or expressions and evaluate the
                    result based on their logical relationship.
                    <br>Example &darr;
                </p>
                <pre>
                    <code>
#!/bin/bash
# This is a script to compare two numbers using logical operator.

# Assign values to variables
x=5
y=10

# Check if both conditions are true using logical AND operator (&&)
if ((x > 0)) && ((y < 10)); then
    echo "Both conditions are true."
fi

# Check if either of the conditions is true using logical OR operator (||)
if ((x > 0)) || ((y < 10)); then
    echo "At least one condition is true."
fi

# Check if a condition is false using logical NOT operator (!)
if ! ((x == y)); then
    echo "The numbers are not equal."
fi
                    </code>
                </pre>
                <p><b>Relational Operators</b></p>
                <ul>
                    <li>Equal to (==): Checks if two values or expressions are equal.</li>
                    <li>Not equal to (!=): Checks if two values or expressions are not equal.</li>
                    <li>Greater than (>): Checks if the left operand is greater than the right operand.</li>
                    <li>Less than (<): Checks if the left operand is less than the right operand.</li>
                    <li>Greater than or equal to (>=): Checks if the left operand is greater than or equal to the right
                        operand.</li>
                    <li>Less than or equal to (<=): Checks if the left operand is less than or equal to the right
                            operand.</li>
                </ul>
                <p>These operators are primarily used for comparing values or variables and returning a true or false
                    result based on the comparison.
                    <br>Example &darr;
                </p>
                <pre>
                    <code>
#!/bin/bash
# This is a script to compare two numbers relational operator.

# Assign values to variables
x=5
y=10

# Compare the values using relational operators
if ((x == y)); then
    echo "The numbers are equal."
elif ((x > y)); then
    echo "x is greater than y."
else
    echo "x is less than y."
fi
                    </code>
                </pre>
            </div>
        </div>
        <div class="wh">
            <h3>Q- What are the file permissions in LINUX and how you can change the permission for a particular file?
            </h3>
        </div>
    </div>
    <div class="content-box">
        <p>Reference &darr;</p>
        <ul>
            <li><a href="https://www.techradar.com/best/best-linux-distros" target="_blank">www.techradar.com (Linux
                    distribution name)</a></li>
        </ul>
    </div>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script src="../../../../public/main.js"></script>
</body>

</html>