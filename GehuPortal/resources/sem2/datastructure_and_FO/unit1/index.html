<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithm Basics</title>
    <link rel="stylesheet" href="../../../../public/style.css">
    <link rel="stylesheet" id="highlightStylesheet"
        href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/tomorrow-night-blue.min.css">
        <link rel="icon" href="../../../../public/logo/favicon_io/favicon.ico">
</head>

<body class="bg-c">
    <div id="mySidepanel" class="sidepanel">
        <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">×</a>
        <a href="../index.html" class="home">back</a>
        <a href="#t1" class="link">Algorithm definition</a>
        <a href="#t2" class="link">Characteristics</a>
        <a href="#t3" class="link">Algorithm Complexity</a>
        <a href="#t4" class="link">Efficiency of algorithm</a>
        <a href="#t5" class="link">Time-space trade-off</a>
        <a href="#t6" class="link">Time and space complexity</a>
        <a href="#t7" class="link">Asymptotic ananlysis and notations</a>
        <a href="#t8" class="link">Big O time complexity exmples</a>
        <a href="#t9" class="link">Calculating time complexity of an algorithm</a>
        <div class="botbut">
            <a href="./intro_data.html" class="link">Next Topic &rarr;</a>
        </div>
    </div>
    <div id="navbar" class="grad">
        <div>
            <div class="openbtn" onclick="openNav()">
                <div id="nav-icon1" for="nav-menu1">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </div>
        </div>
        <div>
            <h2>Algorithm Basics</h2>
        </div>
    </div>
    <div class="content-box">
        <h1 id="t1">Algorithm Basics</h1>
        <div class="wh">
            <ul>
                <li><b>Algorithm: </b>An algorithm is the well defined list of steps to solve any particular problem.
                </li>
                <li>It is a finite set of instructions which perform a specific task using
                    computational manner.</li>
            </ul>
            <div id="t2" class="in">
                <h3>Characteristics</h3>
                <ol>
                    <li><b>Input &rArr;</b> An algorithm should take finite number of inputs.
                        <ul>
                            <li>It is essential for any algorithm before starting.</li>
                            <li>Input should be given to it initially before the Algorithm begins.</li>
                        </ul>
                    </li>
                    <li><b>Output &rArr;</b> An algorithm must give at least one required result from the given set of
                        input values. These output values are known as the solution to a problem.</li>
                    <li><b>Definiteness &rArr;</b> Each step should be unique
                        <ul>
                            <li>No step should be repeated</li>
                            <li>Each step must be clear and precisely defined.</li>
                        </ul>
                    </li>
                    <li><b>Finiteness &rArr;</b> It means algorithm should be terminated after a finite number of steps.
                        <ul>
                            <li>Also, each step should be finished in a finite amout of time.</li>
                        </ul>
                    </li>
                    <li><b>Correctness &rArr;</b> Output should be correct.</li>
                </ol>
            </div>
            <div class="in">
                <h3>Types of algorithm</h3>
                <ol>
                    <li><b>Sequential algorithms</b> are a type of algorithm that executes a set of instructions
                        in a fixed order, one after the other.</li>
                    <li><b>Conditional algorithms</b> are a type of algorithm that executes different sets of
                        instructions based on certain conditions.</li>
                    <li><b>Looping algorithms</b>, also known as iterative algorithms, are a type of algorithm
                        that repeats a set of instructions multiple times until a certain condition is met.
                    </li>
                </ol>
            </div>
            <div class="in">
                <h3>Example</h3>
                <p>Algorithm to swap two numbers without using third variable &darr;</p>
                <pre>
                    <code>
step 1. input a and b 
step 2. a = a + b
        b = a - b
        a = a - b
step 3. print a and b
                    </code>
                </pre>
                <p>Algorithm to find largest number in an array &darr;</p>
                <pre>
                    <code>
step 1. input size 
step 2. input elements in an array arr[size] 
step 3. largest = arr[0] and i = 0
step 4. repeat step 5 while i <= size 
step 5. if(arr[i] > largest)
            largest = arr[i] 
        end of if
        i = i + 1;
step 6. print largest
                    </code>
                </pre>
                <p>Algorithm to delete an element from an array &darr;</p>
                <pre>
                    <code>
A is an Array 
pos is the location of the element to be deleted
N is the size of the array 
E is the element to be deleted
deletion(A, pos, N)
step 1. E = A[pos]
step 2. for i = pos to N - 1 repeat step 3 
step 3. A[i] = A[i+1]
        end of for loop
step 4. N = N - 1
                    </code>
                </pre>
                <p>Algorithm to reverse an character array &darr;</p>
                <pre>
                    <code>
S is the character array 
L is the length of the character array 
start is the pointer pointing to first element 
end is pointing to last element 
swap(S, L)
step 1. repeat step 2 while start < end 
step 2. temp = S[start]
        S[start] = S[end]
        S[end] = temp 
        start = start + 1
        end = end - 1
step 3. print S [reversed character array]
                    </code>
                </pre>
            </div>
        </div>
        <div id="t3" class="wh">
            <h2>Algorithm Complexity</h2>
            <p>Algorithm complexity refers to the amount of time and /or space requried by an algorithm to solve a
                problem. It is a measure of how efficient an algorithm is, and it is typically expressed as a function
                of the size of the input. <br>There are two types of algorithm complexity:</p>
            <ol>
                <li>Time complexity: This refers to the amount of time an algorithm takes to solve a problem, as a
                    function of the size of the input. <ul>
                        <li>The time complexity is usually measured in terms of the number of operations or steps the
                            algorithm takes.</li>
                    </ul>
                </li>
                <li>Space complexity: This refers to the amount of memory an alogrithm requiers to solve a problem, as a
                    function of the size of the input.
                    <ul>
                        <li>Space complexity is usually measured in terms of the amount of memory required for the
                            input, the output, and any additional storage required by the algorithm</li>
                    </ul>
                </li>
            </ol>
            <p>Both time and space complexity are important factors to consider when analyzing the performance of an
                algorithm. A good algorithm should have a low time and space complexity, meaning that it should be able
                to solve a problem quickly and with minimal use of memory. On the other hand, a poor algorithm may have
                a high time and space complexity, which can lead to slow performance or even failure to solve the
                problem for large input sizes.</p>
        </div>
        <div id="t4" class="wh">
            <h2>Efficiency of Algorithm</h2>
            <ul>
                <li>Time and space are two major measures of the efficiency of an algorithm.</li>
            </ul>
            <p>
                Example:
            <pre>
                    <code>
          A           B
time    10 sec      15 sec  
space   40 mb       13 mb

Algorithm A is more efficient tham B

          A           B
time    10 sec      10 sec  
space   15 mb        3 mb

Algorithm B is more efficient tham A
                    </code>
                </pre>
            </p>
        </div>
        <div id="t5" class="wh">
            <h2>Time-space trade-off</h2>
            <ul>
                <li>S &Proportional; 1 / T</li>
                <li>Time-space trade-off is a concept in computer science that involves making a choice between using
                    more time to execute an algorithm or using more space to store data in order to optimize the overall
                    performance of the algorithm.</li>
                <li>This trade-off between time and space complexity is often influenced by the specific requirements of
                    the problem being solved and the available resources. For example, in a system with limited memory,
                    it may be necessary to prioritize space efficiency over time efficiency to ensure that the algorithm
                    can run at all. In contrast, in a system with abundant memory, it may be more practical to
                    prioritize time efficiency over space efficiency to achieve faster performance.</li>
                <li>In general, the goal of time-space trade-off is to find the optimal balance between time and space
                    complexity for a given problem, taking into account the available resources and the specific
                    requirements of the problem being solved.</li>
            </ul>
        </div>
        <div id="t6" class="wh">
            <h2>Time Complexity and Space complexity of an Algorithm</h2>
            <p>Criteria for measurement</p>
            <ul>
                <li>Two criteria are used to judge algorithms:
                    <ol>
                        <li>Time complexity</li>
                        <li>Space complexity</li>
                    </ol>
                </li>
            </ul>
            <p><u>Space complexity </u>of an algorithm is the amount of memory it needs to run to completion.</p>
            <p><u>Time complexity</u> of an algorithm is the amount of CPU time it needs to run to completion.</p>
            <pre>
                <code>
Factors of time and space complexity 

 Time                             Space 
- Operations                     - Variables
- Comparisons                    - Data structures
- Loop stuff                     - Allocations
- Pointer references             - Funtion call
- Function calls to outside
                </code>
            </pre>
            <div class="in">
                <h3>Time complexity of Algorithm</h3>
                <ul>
                    <li><b>Time complexity</b> of an algorithm is the <u>amount of time (or the number of steps)
                        </u>needed by a <u>program to complete its task</u> (to execute a particular algorithm.)</li>
                    <li>The time taken for an algorithm is comprised of two times:
                        <ol>
                            <li>Compilation time</li>
                            <li>Run time</li>
                        </ol>
                    </li>
                    <li><b>Compile time </b>
                        <ul>
                            <li>Compilation time is the time taken to <u>compile an algorithm.</u></li>
                            <li>While <u>compiling it checks for the syntax and semantic errors</u> in the program and
                                <u>links it with the standard libraries.</u>
                            </li>
                        </ul>
                    </li>
                    <li><b>Run time</b>
                        <ul>
                            <li>It is the time to <u>execute the compiled program.</u></li>
                            <li>The run time of an algorithm depend upon <u>the number of instructions present in the
                                    algorithm.</u></li>
                            <li>Note that <u>run time is calculated only for executable statements</u> and <u>not for
                                    declaration statements.</u></li>
                        </ul>
                    </li>
                </ul>
                <h3>Types of Time Complexity</h3>
                <ul>
                    <li>Time complexity of an algorithm is generally classified into three types.</li>
                </ul>
                <img src="../../images/timespace.svg" alt="" class="wb">
                <div class="wh">
                    <p>Example - sum of n numbers &darr;</p>
                    <pre>
                        <code>
step 1. input n 
step 2. result = 0, i = 1
step 3. repeat step 4 while i <= n 
step 4. result = result + i 
        i = i + 1
step 5. print result 
                        </code>
                    </pre>
                    <ul>
                        <li>The time complexity of this algorithm can be calculated by counting the number of operations
                            1 to n.</li>
                        <li>Here the time complexity of the algorithm is O(n), since the running time increases linearly
                            with the size of the input.</li>
                    </ul>
                </div>
            </div>
            <div class="in">
                <h3>Space complexity</h3>
                <ul>
                    <li>Space complexity is a measure of the amount of memory space required by an algorithm to solve a
                        problem.</li>
                    <li>It is typically expressed in terms of the amount of memory space used by an algorithm in
                        relation to the input size. In other words, it is the amount of memory used by an algorithm to
                        store the data structures and other variables used during the execution of the algorithm.</li>
                    <li>To calculate the space complexity of an algorithm, we can use the Big O notation, which
                        expresses the upper bound of the growth rate of the space used by the algorithm. For example, if
                        an algorithm has a space complexity of O(n), it means that the amount of space used by the
                        algorithm grows linearly with the input size. Similarly, if an algorithm has a space complexity
                        of O(n^2), it means that the amount of space used by the algorithm grows quadratically with the
                        input size.</li>
                </ul>
            </div>
        </div>
        <div id="t7" class="wh">
            <h2>Asymptotic Analysis and Notations</h2>
            <ul>
                <li>Asymptotic analysis of an algorithm refers to
                    <u>defining the mathematical boundation/framing of its run-time performance.</u>
                <li>Using asymptotic analysis, we can very <u>conclude the best case, average case, and worst case
                        scenario of an algorithm.</u></li>
                <li>Asymptotic analysis refers to <u>computing the running time of any operation</u> in mathematical
                    units of computation.</li>
                </li>
            </ul>
            <img src="../../images/worstcase.svg" class="wb" alt="">
        </div>
        <div id="t8" class="wh">
            <h2>Big O Time Complexity Examples</h2>
            <div class="in">
                <h3>O(1): Constant Time</h3>
                <ul>
                    <li>When your algorithm is not dependent on the input size n, it is said to have a constant time
                        complexity with order O(1).</li>
                    <li>This means that the run time will always be the same regardless of the input size.</li>
                    <li>Examples:
                        <ul>
                            <li>Accessing Array index (int a = Arr[5];)</li>
                        </ul>
                    </li>
                </ul>
            </div>
            <div class="in">
                <h3>O(n): Linear Time</h3>
                <ul>
                    <li>When the running time of an algorithm increases linearly with the size of the input.</li>
                    <li>This means that when a function has an iteration that iterates over an input size of n, it is
                        said to have a time complexity of order O(n).</li>
                </ul>
                <pre>
                       <code>
// factorial program 
int calcFactorial(int n)
{
    int ,factorial = 1, i;
    for(i = 0; i <= n; i++)
    {
        factorial = factorial * i;
    }
    return factorial;
}
                       </code>
                   </pre>
                <ul>
                    <li>The fact that the runtime depends on the input size means that the time complexity is linear
                        with the order O(n).</li>
                </ul>
                <p>Here the programs like inserting, printing array elements have the O(n) complexity.</p>
            </div>
            <div class="in">
                <h3>O(n<sup>2</sup>): Quadratic Time</h3>
                <ul>
                    <li>When there is nested iteration, meaning having a loop in a loop and inner loop is dependent on
                        outer loop, here the time complexity is
                        quadratic, which is horrible.</li>
                    <li>A perfect way to explain this would be if you have an array with n items. The outer loop will
                        run n times, and the inner loop will run n times for each iteration of the outer loop, which
                        will give total n<sup>2</sup> prints. If the array has ten items, it will print 100 times
                        (10<sup>2</sup>).</li>
                </ul>
            </div>
            <div class="in">
                <h3>O(log n): Logarithm Time</h3>
                <ul>
                    <li>This is similar to linear time complexity, except that the runtime does not depend on the input
                        size but rather on half the input size.</li>
                    <li>When the input size decreases on each iteration or step, an algorithm is said to have
                        logarithmic time complexity.</li>
                    <li>Certain divide and conquer algorithms based on linear functionality.</li>
                    <li>This method is the second best because programs run for half the input size rather than the full
                        size. After all, the input size decreases with each iteration.</li>
                    <li>A great example is binary search functions, which divide your sorted array based on the target
                        value.</li>
                </ul>
                <div class="npanel">
                <pre>
                       <code>                
// binary search
int binarySearch(int arr[], int size, int target)
{
    int low = 0;
    int high = size - 1;
    int mid;
    while(low <= high)
    {
        int mid = (low + high)/2;
        if(arr[mid] == target)
        {
            return mid;
        }
        if(arr[mid] > target)
        {
            high = mid - 1;
        }
        else 
        {
            low = mid + 1;
        }
    }
    return -1;
}
                       </code>
                   </pre>
                </div>
            </div>
            <div class="in">
                <h3>O(n log n)</h3>
                <ul>
                    <li>Examples:
                        <ul>
                            <li>Merge sort</li>
                            <li>Heap sort</li>
                            <li>Quick sort</li>
                        </ul>
                    </li>
                </ul>
            </div>
        </div>
        <div id="t9" class="wh">
            <h2>How to Calculate Time Complexity of an Algorithm</h2>
            <ul>
                <li>Drop the constants:
                    <ul>
                        <li>Anything you might think is O(kn) (where k is a constant) is O(n) as well. This is
                            considered a better representation of the time complexity since the k term would not affect
                            the complexity much for a higher value of n.</li>
                    </ul>
                </li>
                <li>Drop the non-dominant terms:
                    <ul>
                        <li>
                            Anything you represent as O(n^2+n) can be written as O(n^2). Similar to when non-dominant
                            terms are ignored for a higher value of n.
                        </li>
                    </ul>
                </li>
                <li>Consider all variables which are provided as input:
                    <ul>
                        <li>O(mn) and O(mnq) might exist for some cases.</li>
                        <li>In most cases, we try to represent the runtime in terms of the inputs which can even be more
                            than one in number. For example, The time taken to paint a park of dimension m*n → O(kmn) →
                            O(mn)</li>
                    </ul>
                </li>
            </ul>
            <div class="in">
                <h3>Practise questions</h3>
                <div class="wh">
                    <p>1. Find the time complexity of the func1 function in the program shown below &darr;</p>
                    <img src="../../images/ques1.svg" alt="" class="wb">
                </div>
                <div class="wh">
                    <p>2.</p>
                    <img src="../../images/ques2.svg" alt="" class="wb">
                </div>
                <div class="wh">
                    <p>3. Find the complexity of the following code which tests whether a given number is prime or not?
                    </p>
                    <img src="../../images/ques3.svg" class="wb" alt="">
                </div>
                <div class="wh">
                    <p>4. What is the time complexity of the following snippet of code?</p>
                    <img src="../../images/ques4.svg" alt="" class="wb">
                </div>
            </div>
        </div>
    </div>
    <div class="content-box">
        <p>References &darr;</p>
        <ul>
            <li><a href="https://www.freecodecamp.org/news/big-o-cheat-sheet-time-complexity-chart/">www.freecodecamp.org
                    (time complexity)</a></li>
            <li><a
                    href="https://stackoverflow.com/questions/1592649/examples-of-algorithms-which-has-o1-on-log-n-and-olog-n-complexities">stackoverflow.com
                    (Big Oh notations)</a></li>
        </ul>
    </div>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script src="../../../../public/main.js"></script>
</body>

</html>