<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Software Reliability & Quality Assurance</title>
    <link rel="stylesheet" href="../../../../public/style.css">
    <link rel="icon" href="../../../../public/logo/favicon_io/favicon.ico">
</head>

<body class="bg-c">
    <div id="mySidepanel" class="sidepanel">
        <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">×</a>
        <a href="../index.html" class="home">back</a>
        <a href="#" class="link"></a>
        <div class="botbut">
            <a href="../unit5/index.html" class="link">Next Topic &rarr;</a>
            <a href="../unit3/index.html" class="link">&larr; Previous Topic</a>
        </div>
    </div>
    <div id="navbar" class="grad">
        <div>
            <div class="openbtn" onclick="openNav()">
                <div id="nav-icon1" for="nav-menu1">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </div>
        </div>
        <div>
            <h2>Software Reliability & Quality Assurance</h2>
        </div>
    </div>
    <div class="content-box">
        <h1>Software Reliability & Quality Assurance</h1>
        <ul>
            <li>In the unit of Software Reliability & Quality Assurance, we will delve into crucial aspects of software
                engineering aimed at ensuring the dependability and quality of software systems.</li>

            <li>The curriculum encompasses an exploration of reliability issues, including the identification and
                mitigation of potential challenges.</li>

            <li>We will become familiar with reliability metrics, understanding how to quantify and measure the
                reliability of software through matrices and other measurement tools.</li>

            <li>The unit also addresses reliability growth modeling, providing insights into how software reliability
                evolves over time.</li>

            <li>An integral part of the syllabus focuses on software quality, with an examination of ISO 9000
                certification specific to the software industry.</li>

            <li>Additionally, we will gain an understanding of the SEI Capability Maturity Model (CMM) and its role in
                enhancing software development processes.</li>

            <li>The unit culminates in a comparison between ISO and SEI CMM, offering us a comprehensive view of the
                standards and models that underpin software reliability and quality assurance in the professional
                landscape.</li>
        </ul>
        <div class="wh">
            <h2>Software Reliability</h2>
            <ul>
                <li><strong>Definition:</strong> Software reliability refers to the trustworthiness or dependability of
                    a software product.</li>

                <li><strong>Probability:</strong> It is quantified as the probability of the software product
                    functioning correctly over a specific period of time.</li>
            </ul>
        </div>
        <div class="wh">
            <h2>Reliability Issues</h2>
            <p><strong>Reliability issues</strong> in software engineering encompass challenges related to the
                trustworthiness and dependability of a software product. One significant challenge is the difficulty in
                mathematically characterizing the relationship between software reliability and the number of bugs. The
                impact of bug location adds complexity, as fixing errors in less utilized parts of the software often
                yields minimal improvement. Moreover, software reliability is not solely contingent on bug quantity but
                is also influenced by the specific location of these errors in the code. User-dependent factors, such as
                how the product is used, further contribute to the intricacies of measuring reliability. In summary,
                reliability issues involve navigating the nuances of bug location, observer-dependent perceptions, and
                the continuous evolution of a product's reliability as errors are detected and addressed.</p>
            <ul>
                <li><strong>Mathematical Characterization:</strong> It is challenging to express software reliability in
                    terms of bugs through a mathematical expression. Understanding the relationship between reliability
                    and the number of bugs is complex.</li>

                <li><strong>Impact of Bug Location:</strong> Removing errors from less usable parts of software has
                    minimal impact on perceived reliability. Approximately 90% of a program's execution time is spent on
                    executing only 10% of its instructions, known as the core. Removing defects from the least used
                    parts results in a limited improvement.</li>

                <li><strong>Location Dependency:</strong> Reliability depends not only on the number of bugs but also on
                    the precise location of errors in the code. Fixing a bug in frequently used parts significantly
                    improves reliability compared to fixing bugs in less used sections.</li>

                <li><strong>User-Dependent Reliability:</strong> Software reliability is influenced by how the product
                    is used. If users interact with correctly implemented features, the perceived reliability is high.
                    Conversely, invoking functions with errors leads to numerous failures, lowering the perceived
                    reliability.</li>

                <li><strong>Challenges in Measurement:</strong> Software reliability measurement is complicated due to
                    factors such as the location-dependent impact of fixing a bug, observer-dependent perceived
                    reliability, and continuous changes in reliability as errors are detected and fixed.</li>
            </ul>
        </div>
        <div class="wh">
            <h2>Reliability Metrics</h2>
            <p><strong>Reliability metrics</strong> play a crucial role in software engineering, addressing the diverse
                reliability requirements across different categories of software products. The Software Requirements
                Specification (SRS) document becomes essential for specifying the reliability of software. Despite the
                inherent difficulty in formulating reliability, practicality demands quantitative expressions. Here, six
                metrics are discussed to measure software reliability.</p>

            <ol>
                <li><strong>Rate of Occurrence of Failure (ROCOF):</strong> ROCOF quantifies the frequency of failures
                    by dividing the total number of observed failures by the duration of observation.</li>

                <li><strong>Mean Time to Failure (MTTF):</strong> MTTF represents the average time between two
                    successive failures over a large number of occurrences. Only run time is considered in the time
                    measurements, excluding error fixing and boot time.</li>

                <li><strong>Mean Time to Repair (MTTR):</strong> MTTR measures the average time spent on error tracking
                    and fixing once a failure occurs.</li>

                <li><strong>Mean Time Between Failure (MTBF):</strong> MTBF is derived by combining MTTF and MTTR,
                    indicating the expected time until the next failure after a failure occurrence.</li>

                <li><strong>Probability of Failure on Demand (POFOD):</strong> POFOD assesses the likelihood of system
                    failure when a service request is made, expressed as a probability (e.g., a POFOD of 0.001 means 1
                    out of 1000 service requests results in failure).</li>

                <li><strong>Availability:</strong> Availability measures the likelihood of a system being available for
                    use over a specific period, accounting for the number of failures and repair time (down time) when a
                    failure occurs.</li>
            </ol>
        </div>
        <div class="wh">
            <h2>Reliability Growth Modeling</h2>
            <p><strong>Reliability growth modeling</strong> involves using mathematical models to illustrate how the
                reliability of a software product improves as errors are identified and corrected. We discuss three key
                models, each providing insights into the dynamic nature of reliability improvement.</p>
            <div class="in">
                <h3>Jelinski and Moranda Model (1972):</h3>
                <ul>
                    <li><strong>Basic Assumptions:</strong> The Jelinski and Moranda model, proposed in 1972, relies on
                        two key assumptions:
                        <ul>
                            <li>The reliability increases by a constant increment with each error detection and repair,
                                implicitly assuming perfect error fixing in every instance.</li>
                            <li>All errors contribute equally to reliability growth, assuming a uniform impact across
                                different types of errors.</li>
                        </ul>
                    </li>

                    <li><strong>Realism Considerations:</strong> Acknowledging the limitations of the model, it's
                        important to note that these assumptions are unrealistic. In reality, different errors
                        contribute differently to reliability growth, and error fixes may not always be perfect,
                        potentially introducing new types of errors.</li>

                    <li><strong>Reliability Growth Prediction:</strong> Despite its limitations, the Jelinski and
                        Moranda model predicts reliability growth, as illustrated in the accompanying Figure. The graph
                        represents a step function model of reliability growth over time.</li>

                    <li><strong>Instantaneous Failure Rate:</strong> The model defines the instantaneous failure rate
                        (also called the hazard rate) as Z(t) = ∆ × (N – i), where ∆ is a constant, N is the total
                        number of errors in the program, and t is any time between the ith and (i + 1)th failure. This
                        means the failure rate remains constant between two failures and improves by ∆ after every
                        failure.</li>

                    <li><strong>Graphical Representation:</strong> Refer to the accompanying Figure for a visual
                        representation of the step function model of reliability growth, providing insights into how the
                        reliability of a software product evolves over time according to the Jelinski and Moranda model.
                    </li>
                </ul>
                <img src="../../images/model1.svg" alt="" class="wb">
                <ul>
                    <li>On the graph diagram, with time (on the
                        x-axis) and ROCOF (on the y-axis), the plot visualizes how the rate of failure occurrence
                        changes
                        over time as errors are detected and repaired. The ROCOF curve reflects the model's assumption
                        that
                        reliability increases by a constant increment each time an error is identified and fixed. This
                        visualization helps in understanding the dynamic nature of reliability improvement predicted by
                        the
                        Jelinski and Moranda model.</li>
                </ul>
            </div>
            <div class="in">
                <h3>Littlewood and Verall’s Model:</h3>
                <ul>
                    <li><strong>Negative Reliability Growth:</strong> Littlewood and Verall’s model allows for negative
                        reliability growth, acknowledging that fixing a bug may introduce additional errors, potentially
                        decreasing the overall reliability of the software.</li>

                    <li><strong>Imperfect Bug Fixes:</strong> In contrast to the Jelinski and Moranda model, it
                        recognizes the imperfections in bug fixes, understanding that they may introduce new errors,
                        affecting the software's reliability.</li>

                    <li><strong>Diminishing Returns:</strong> The model accounts for diminishing returns as errors are
                        repaired over time. Initially, the average improvement to product reliability per repair may be
                        substantial, but as testing and fixing progress, this improvement decreases.</li>

                    <li><strong>Independent Error Contribution:</strong> An error's contribution to reliability
                        improvement is treated as an independent random variable following a Gamma distribution. This
                        captures the idea that error corrections with larger impacts on reliability are addressed first.
                    </li>
                </ul>
            </div>
            <div class="in">
                <h3>Goel-Okutomo Model:</h3>
                <ul>
                    <li><strong>Exponential Distribution of Execution Times:</strong> The Goel-Okutomo model assumes
                        that execution times between failures follow an exponentially distributed pattern.</li>

                    <li><strong>Expected Number of Failures:</strong> The expected number of failures at any time is
                        represented as µ(t) and is calculated as the expected value of failures between time t and time
                        t + ∆t.</li>

                    <li><strong>Non-Homogeneous Poisson Process (NHPP):</strong> The reliability growth in this model is
                        assumed to follow a Non-Homogeneous Poisson Process. This means that the expected number of
                        error occurrences is proportional to the expected number of undetected errors existing at time
                        t.</li>

                    <li><strong>Immediate and Perfect Error Correction:</strong> Once a failure is detected, the model
                        assumes immediate and perfect error correction, enhancing the reliability of the software.</li>

                    <li><strong>Formula for Number of Failures:</strong> The number of failures at time t is given by
                        the formula µ(t) = N(1 – e–bt), where N is the expected number of defects, and b is the rate at
                        which the failure rate decreases.</li>

                    <li><strong>Graphical Representation:</strong> The change in the number of failures over time has
                        been graphically plotted, providing a visual representation of how failures evolve as the
                        software undergoes testing and error correction.</li>
                </ul>
                <img src="../../images/model2.svg" alt="" class="wb">
            </div>
        </div>
        <div class="wh">
            <h2>Software Quality</h2>
            <ul>
                <li><strong>Traditional Definition:</strong> Traditionally, product quality is defined in terms of
                    fitness for purpose, meaning a quality product fulfills user expectations. This concept is
                    interpreted in the Software Requirements Specification (SRS) document.</li>

                <li><strong>Limitations in Software Quality Definition:</strong> However, for software products, the
                    "fitness for purpose" definition has limitations. For example, a functionally correct software
                    product may not be considered of high quality if it has an almost unusable user interface.</li>
                <li><strong>Modern View of Quality:</strong> In the modern perspective, several quality factors or
                    attributes are associated with software products, including:
                    <ul>
                        <li><strong>Portability:</strong> A software product is considered portable if it can easily run
                            on different hardware and operating system environments and interface with external hardware
                            devices and software products.</li>

                        <li><strong>Usability:</strong> Usability refers to a software product being user-friendly,
                            catering to both expert and novice users.</li>

                        <li><strong>Reusability:</strong> Reusability is observed when different modules of the software
                            can easily be reused to develop new products.</li>

                        <li><strong>Correctness:</strong> A software product is correct if it correctly implements the
                            specified requirements in the SRS document.</li>

                        <li><strong>Maintainability:</strong> Maintainability indicates that errors can be easily
                            corrected, new functions can be added, and existing functionalities can be modified without
                            significant challenges.</li>
                    </ul>
                </li>
            </ul>
        </div>
        <div class="wh">
            <h2>ISO 9000 Certification for Software Industry</h2>
            <div class="in">
                <h3>What is ISO 9000 Certification?</h3>
                <ul>
                    <li><strong>Reference for Contract:</strong> ISO 9000 certification acts as a reference for
                        contracts
                        between independent parties. The standard provides guidelines for maintaining a quality system,
                        addressing both operational and organizational aspects.</li>

                    <li><strong>Operational and Organisational Aspects:</strong> ISO 9000 addresses operational aspects,
                        including processes, and organizational aspects such as responsibilities and reporting. It
                        offers
                        recommendations for high-quality product development without being directly concerned about the
                        product itself.</li>

                    <li><strong>Types of ISO 9000 Standards:</strong> ISO 9000 consists of three standards—ISO 9001, ISO
                        9002, and ISO 9003. Each applies to specific types of organizations in different industries.
                        <ul>
                            <li><strong>ISO 9001:</strong> Applicable to organizations engaged in design, development,
                                production, and servicing of goods, including most software development organizations.
                            </li>

                            <li><strong>ISO 9002:</strong> Applies to organizations not involved in product design but
                                focused on production, excluding software development organizations.</li>

                            <li><strong>ISO 9003:</strong> Applies to organizations exclusively involved in the
                                installation
                                and testing of products.</li>
                        </ul>
                    </li>
                </ul>
            </div>
            <div class="in">
                <h3>ISO 9000 for Software Industry</h3>
                <ul>
                    <li><strong>Challenges in Interpretation:</strong> Many clauses of ISO 9000 use generic
                        terminologies,
                        posing challenges for interpretation in the context of software development. Software's
                        intangibility and reliance on data as the only raw material contribute to these challenges.</li>

                    <li><strong>Software Development Differences:</strong> Software's intangibility makes it challenging
                        to
                        control and manage until development is complete. Unlike traditional manufacturing, software
                        development doesn't involve physical raw materials like iron-ore or coal, rendering certain ISO
                        9000
                        clauses irrelevant.</li>

                    <li><strong>ISO 9000 Part-3:</strong> Due to these differences, ISO released ISO 9000 Part-3 in
                        1991,
                        offering guidance specifically tailored for the software industry. However, official guidance
                        remains limited, requiring continuous cross-referencing with ISO 9000-3.</li>
                </ul>
            </div>
        </div>
        <div class="wh">
            <h2>SEI Capability Maturity Model (SEI CMM)</h2>

            <h3>Overview</h3>
            <p>The Software Engineering Institute (SEI) Capability Maturity Model (SEI CMM) was introduced by the
                Software Engineering Institute of Carnegie Mellon University, USA. Originally developed to aid the US
                Department of Defense (DoD) in software acquisition, SEI CMM proved instrumental in enhancing software
                quality for organizations. In simple terms, CMM serves as a reference model for categorizing software
                process maturity into different levels.</p>

            <div class="in">
                <h3>Usage of SEI CMM</h3>
                <p>SEI CMM can be utilized in two ways: Capability Evaluation and Software Process Assessment.
                    Capability
                    Evaluation assesses an organization's software process capability and is conducted by the contract
                    awarding authority. Software Process Assessment is for internal use, enabling organizations to
                    enhance
                    their own process capability.</p>
            </div>
            <div class="in">
                <h3>Maturity Levels</h3>
                <ul>
                    <li><strong>Level 1: Initial</strong>
                        <p>The initial level has no specific requirements. Few or no defined processes lead to chaotic
                            development efforts, with engineers following individual processes.</p>
                    </li>

                    <li><strong>Level 2: Repeatable</strong>
                        <p>Basic project management activities are prepared, including cost and schedule tracking.
                            Configuration management tools are used, but processes are not documented. Repeatability is
                            achieved when producing similar products.</p>
                    </li>

                    <li><strong>Level 3: Defined</strong>
                        <p>Processes for management and development activities are defined and documented. There is a
                            common
                            organization-wide understanding of activities, roles, and responsibilities. Process and
                            product
                            qualities are not yet measured.</p>
                    </li>

                    <li><strong>Level 4: Managed</strong>
                        <p>Focus shifts to software metrics, collecting both process and product metrics. Quantitative
                            quality goals are set, and tools like Pareto charts and fishbone diagrams are used for
                            measurement.</p>
                    </li>

                    <li><strong>Level 5: Optimizing</strong>
                        <p>Process and product metrics are collected and analyzed for continuous improvement. The
                            organization adapts to innovative ideas and technologies based on quantitative feedback from
                            process measurements.</p>
                    </li>
                </ul>
            </div>
            <div class="in">
                <h3>CMM Shortcomings</h3>
                <ul>
                    <li><strong>Lack of Guidance:</strong> Organizations often express a need for more guidance on how
                        to
                        improve, despite understanding the areas requiring improvement.</li>

                    <li><strong>Documentation Overload:</strong> CMM's emphasis on thicker documents and detailed
                        information contrasts with agile practices, which prioritize reducing complexity and minimizing
                        documentation without sacrificing relevant details.</li>

                    <li><strong>Maturity Level Measurement:</strong> Getting an accurate measure of an organization's
                        current maturity level is challenging, as CMM takes an activity-based approach without assessing
                        the
                        effectiveness of these activities in delivering intended results.</li>
                </ul>
            </div>
        </div>
        <div class="wh">
            <h2>Comparison between ISO & SEI CMM</h2>

            <h3>Overview</h3>
            <p>The comparison between ISO (International Organization for Standardization) and SEI CMM (Software
                Engineering Institute Capability Maturity Model) sheds light on the distinctive features of two
                prominent frameworks for ensuring quality and maturity in software development processes.</p>

            <img src="../../images/model3.svg" alt="" class="wb">

            <h3>Comparison</h3>
            <p>While both ISO and SEI CMM aim to improve processes and ensure quality, they differ in scope and
                application. ISO offers broad applicability across industries, emphasizing adherence to international
                quality standards. In contrast, SEI CMM is specifically designed for the software industry, focusing on
                the gradual maturity of software development processes. The choice between ISO and SEI CMM depends on
                the organization's industry and its primary objectives in quality management and process improvement.
            </p>
        </div>
    </div>
    <script src="../../../../public/main.js"></script>
</body>

</html>