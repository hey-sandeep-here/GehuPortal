<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Introduction to Android</title>
    <link rel="stylesheet" href="../../../../public/style.css">
    <link rel="icon" href="../../../../public/logo/favicon_io/favicon.ico">
    <link rel="stylesheet" id="highlightStylesheet"
        href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/tomorrow-night-blue.min.css">
    <style>
        #lessSpace,
        #lessSpace li,
        #lessSpace ul {
            margin: 0;
            padding: 0;
        }

        #lessSpace {
            padding-left: 30px;
        }

        #lessSpace>li>ul,
        #lessSpace>li>ul>li>ul,
        #lessSpace>li>ul>li>ul>li>ul {
            padding-left: 40px;
        }
    </style>
</head>

<body class="bg-c">
    <div id="mySidepanel" class="sidepanel">
        <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">×</a>
        <a href="../index.html" class="home">back</a>
        <div class="fix-column-links">
            <a href="#" class="link"></a>
            <div class="botbut">
                <a href="../unit2/index.html" class="link">Next Topic &rarr;</a>
            </div>
        </div>
    </div>
    <div id="navbar" class="grad">
        <div>
            <div class="openbtn" onclick="openNav()">
                <div id="nav-icon1" for="nav-menu1">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </div>
        </div>
        <div>
            <h2>Introduction to Android</h2>
        </div>
    </div>
    <div class="content-box">
        <div class="wh">
            <h2>Introduction to Mobile Platforms</h2>
            <p>Mobile platforms are the operating systems that run on smartphones and other mobile devices. Each
                platform has its own unique features, development environment, and programming languages. Some of the
                most common mobile platforms include Android, iOS, Windows, and BlackBerry. Each platform requires
                different tools and languages for app development, and some are open to all developers, while others
                have restrictions such as requiring specific hardware or accounts.</p>
            <img src="../../images/ap3.png" alt="">
        </div>
        <div class="wh">
            <h2>App Distribution Methods</h2>
            <p>Different mobile platforms provide various ways to distribute applications. Some platforms have strict
                requirements, like needing to submit apps to an official app store, while others allow more flexible
                distribution methods such as through corporate websites or direct installation via USB.
            </p>
            <img src="../../images/ap4.png" alt="">
        </div>
        <div class="wh">
            <h2>History of Android</h2>
            <p>Android is an open-source mobile operating system built on the Linux kernel. It was mainly developed for
                devices like smartphones and tablets. Since its launch, it has become the most popular mobile operating
                system worldwide. Let’s look at what Android is and how it all started.</p>

            <div class="in">
                <h3>What is Android?</h3>
                <p>Android is an operating system created by Google, designed for mobile devices. It allows developers
                    to make apps that can run on different types of hardware without needing to know the specifics of
                    each device. Its flexibility, open nature, and easy-to-use tools have made it a popular choice.</p>
                <ul>
                    <li><b>Open Source:</b> Android is open-source, meaning anyone can use or change its code for free.
                    </li>
                    <li><b>Linux-Based:</b> It is built on the Linux kernel, which helps it manage hardware and run
                        software efficiently.</li>
                    <li><b>Customizable:</b> Device makers can modify the operating system to match their devices and
                        create their own user experiences.</li>
                </ul>
            </div>

            <div class="in">
                <h3>How Android Started</h3>
                <p>Android Inc. was founded in 2003 by Andy Rubin, Rich Miner, Nick Sears, and Chris White. Initially,
                    it was meant to power digital cameras, but they soon shifted their focus to making it a mobile phone
                    operating system.</p>
                <ul>
                    <li><b>2005 Acquisition by Google:</b> In 2005, Google bought Android Inc. and continued its
                        development, seeing its potential for mobile phones.</li>
                    <li><b>Open Handset Alliance (OHA):</b> In 2007, Google formed the Open Handset Alliance (OHA), a
                        group of tech companies working together to develop Android as an open platform for mobile
                        devices.</li>
                    <li><b>First Android Device:</b> The first Android phone, the HTC Dream (also called T-Mobile G1),
                        was released in 2008, marking the start of Android’s success in the smartphone world.</li>
                </ul>
            </div>

            <div class="in">
                <h3>Open Handset Alliance (OHA)</h3>
                <p>The Open Handset Alliance (OHA) is a group of 84 technology companies, including Google, Intel, Dell,
                    HTC, and China Mobile. This group was created to work together to improve mobile technology and
                    promote Android as a free and open platform.</p>
                <ul>
                    <li><b>Founded by Google:</b> Google led the creation of the OHA, officially forming it on November
                        5, 2007.</li>
                    <li><b>Mission:</b> The OHA aims to speed up innovation in mobile phones and provide users with a
                        better and more affordable mobile experience.</li>
                    <li><b>Developers of Android:</b> The OHA developed Android, the first complete, open, and free
                        platform for mobile devices.</li>
                    <li><b>Google’s Leadership:</b> Google plays a leading role in the OHA, guiding its efforts to push
                        Android forward as the ‘captain’ of the alliance.</li>
                </ul>
            </div>
        </div>
        <div class="wh">
            <h2>Android Development Methods</h2>
            <p>When developing Android applications, there are different types of apps that you can create depending on
                your needs and goals. These include native apps, pure web apps, and hybrid apps. Each type has its own
                characteristics, advantages, and limitations.</p>
            <div class="in">
                <h3>1: Native Apps</h3>
                <p>Native apps are built specifically for a platform using the platform’s supported languages and tools.
                    For Android, this means using Java or Kotlin and Android Studio. They offer the best performance and
                    user experience.</p>
                <ul>
                    <li><b>Characteristics:</b>
                        <ol>
                            <li>Performance: Provides the best performance and responsiveness.</li>
                            <li>Access to Features: Full access to device features such as the camera, GPS, and sensors.
                            </li>
                            <li>Platform-Specific: Developed specifically for one platform. Native apps can only
                                generate an installer (package) for their own platform.</li>
                        </ol>
                    </li>
                    <li><b>Development Tools:</b>
                        <ul>
                            <li>iOS: Xcode, Swift, Objective-C</li>
                            <li>Android: Android Studio, Java/Kotlin</li>
                            <li>Windows: Visual Studio, C#</li>
                        </ul>
                    </li>
                    <li><b>Examples:</b>
                        <ol>
                            <li>Google Maps: Offers advanced mapping and navigation features tailored to Android.</li>
                            <li>Settings: A system app providing access to device settings and configurations.</li>
                        </ol>
                    </li>
                </ul>
            </div>
            <div class="in">
                <h3>2: Pure Web Apps</h3>
                <p>Pure web apps are essentially websites designed to be accessed via a mobile browser. They do not
                    require installation on the device and rely on universal access through web browsers.</p>
                <ul>
                    <li><strong>Characteristics:</strong>
                        <ol>
                            <li>Installation: No need for installation; accessed through a web browser.</li>
                            <li>Limitations: Cannot access mobile hardware features like GPS, camera, and touch sensors.
                            </li>
                            <li>Automatic Updates: Since content comes from the server, updates are automatically
                                applied.</li>
                            <li>Universal Access: Works across different platforms as long as the browser is compatible.
                            </li>
                        </ol>
                    </li>
                    <li><b>Development Language:</b>
                        <ul>
                            <li>HTML, CSS, JavaScript</li>
                        </ul>
                    </li>
                    <li><strong>Examples:</strong>
                        <ol>
                            <li>Facebook Mobile Website: Provides a basic version of the social media site through a
                                browser.</li>
                            <li>Online Banking Sites: Accessible via the browser for managing financial transactions
                                without app installation.</li>
                        </ol>
                    </li>
                </ul>
            </div>
            <div class="in">
                <h3>3: Hybrid Apps</h3>
                <p>Hybrid apps combine web technologies (HTML, CSS, JavaScript) with a native container that allows them
                    to be installed like native apps. They offer a blend of both web app flexibility and native app
                    access to device features.</p>
                <ul>
                    <li><strong>Characteristics:</strong>
                        <ol>
                            <li>Cross-Platform: Can be used across multiple platforms with minimal changes.</li>
                            <li>Access to Features: Some access to device features through a thin native container.</li>
                            <li>Development Efficiency: Faster development compared to fully native apps by reusing code
                                across platforms.</li>
                        </ol>
                    </li>
                    <li><b>Development Environments:</b>
                        <ul>
                            <li>Cordova, Xamarin (C#, Microsoft)</li>
                            <li>Ionic Framework (powered by Cordova)</li>
                            <li>Appcelerator Titanium, Sencha</li>
                        </ul>
                    </li>
                    <li><strong>Examples:</strong>
                        <ol>
                            <li>Uber: Ride-sharing app that uses native features like GPS and integrates web
                                technologies for the user interface.</li>
                            <li>Pinterest: Visual discovery app that blends native and web technologies to offer a
                                responsive interface.</li>
                            <li>eBay: E-commerce app using web technologies for product listings combined with native
                                performance for user interactions.</li>
                        </ol>
                    </li>
                </ul>
            </div>
        </div>
        <div class="wh">
            <h2>Factors to be Considered for Development</h2>
            <p>When developing mobile applications, several factors must be considered to ensure that the app performs
                well and provides a great user experience across different devices and environments. These factors
                include device fragmentation, screen size, screen density, user interaction methods, computing power,
                memory, and battery capacity.</p>

            <div class="in">
                <h3>1: Device Fragmentation</h3>
                <p>The mobile ecosystem is highly fragmented, with various platforms like Android, iOS, Windows, and
                    BlackBerry, each with its own versions and specifications. This presents a challenge for developers
                    as they must ensure compatibility and functionality across a wide range of devices and operating
                    systems.</p>
                <ul>
                    <li>Platform Variability: Developers need to handle differences in operating systems and versions
                        that are continually evolving.</li>
                    <li>Device Compatibility: Ensuring consistent app behavior on devices with varying capabilities,
                        screen sizes, and hardware configurations.</li>
                </ul>
            </div>

            <div class="in">
                <h3>2: Screen Size</h3>
                <p>Mobile devices come in various screen sizes, from small smartphones to large tablets. Designing for
                    smaller screens requires simplifying the layout and focusing on key functionalities while
                    maintaining usability.</p>
                <ul>
                    <li>Responsive Design: UI elements must adapt to different screen sizes for an optimal user
                        experience.</li>
                    <li>Streamlined Navigation: Mobile design prioritizes simplicity, minimizing unnecessary tabs and
                        options, unlike desktop applications, which may use extensive menus and toolbars.</li>
                    <li>Challenges: Ensuring that an application is optimized for different devices with various screen
                        densities and sizes can be complex.</li>
                </ul>
            </div>

            <div class="in">
                <h3>3: Screen Density</h3>
                <p>Screen density refers to the number of pixels per inch (PPI) on a display. Different devices have
                    varying screen densities, so developers need to ensure that images and other graphical elements look
                    sharp and clear across devices.</p>
                <ul>
                    <li>Support for Multiple Densities: High-resolution graphics are necessary to support devices with
                        higher screen densities.</li>
                    <li>Scalable UI Elements: Icons, fonts, and other elements should be scalable without losing
                        quality.</li>
                </ul>
            </div>

            <div class="in">
                <h3>4: User Interaction</h3>
                <p>Mobile devices support different types of user interaction, from mouse and keyboard to touch and
                    sensor-based input. Designing for touch and gesture-based interactions can involve multiple actions
                    such as single taps, double taps, long touches, and more.</p>
                <ul>
                    <li><b>Mouse & Keyboard:</b> Primarily used in desktop environments or on devices with attached
                        keyboards.</li>
                    <li><b>Touch:</b> The dominant interaction method for smartphones and tablets. Gestures like
                        swiping, pinching, and tapping provide more dynamic interaction options.</li>
                    <li><b>Sensor-Based:</b> Devices come equipped with various sensors like accelerometers, gyroscopes,
                        and GPS, enabling features like auto-rotation, gesture recognition, and location-based services.
                    </li>
                </ul>
            </div>

            <div class="in">
                <h3>5: Computing & Memory Capacity</h3>
                <p>Mobile devices generally have less computing power and memory capacity compared to desktops and
                    servers. Developers must optimize their applications to run smoothly within these limitations.</p>
                <ul>
                    <li>Efficient Algorithms: Developers need to create optimized code to handle the limited computing
                        power and memory of mobile devices.</li>
                    <li>Memory Management: Apps must manage memory efficiently to avoid crashes or slowdowns, especially
                        on lower-end devices.</li>
                </ul>
            </div>

            <div class="in">
                <h3>6: Battery Capacity</h3>
                <p>Battery life is a critical factor for mobile devices, as complex or poorly optimized apps can quickly
                    drain battery power. Unlike enterprise systems, where power isn't a concern, mobile apps must be
                    designed with energy efficiency in mind.</p>
                <ul>
                    <li>Battery-Efficient Algorithms: Developers should design algorithms and code that minimize battery
                        usage.</li>
                    <li>Optimized Processes: Reduce background processes and unnecessary resource use to preserve
                        battery life.</li>
                </ul>
            </div>
        </div>
        <div class="wh">
            <h2>Android SDK</h2>

            <p>The Android SDK (Software Development Kit) is a comprehensive set of development tools that enable
                developers to create Android applications. It provides everything needed to build, test, debug, and
                deploy apps across a wide range of Android devices. The SDK includes libraries, APIs, build tools,
                debuggers, emulators, and documentation to streamline the app development process.</p>

            <div class="in">
                <h3>1: What is Android SDK?</h3>
                <p>The Android SDK is a collection of tools, libraries, and resources that developers use to create
                    Android apps. It allows apps to communicate with Android’s operating system and hardware while
                    providing a set of pre-built components that speed up and simplify development.</p>
                <ul>
                    <li><b>Key Components:</b>
                        <ul>
                            <li><b>Libraries:</b> A collection of reusable code that provides functionalities for
                                various tasks, such as managing graphics, user interfaces, databases, and network
                                operations.</li>
                            <li><b>API (Application Programming Interface):</b> The SDK offers APIs that allow
                                developers to use Android’s core features, such as camera access, location services, and
                                system notifications.</li>
                            <li><b>Emulator:</b> A virtual device that mimics the behavior of an actual Android device,
                                allowing developers to test their applications without the need for physical hardware.
                            </li>
                            <li><b>Build Tools:</b> Tools that compile and package the app into an APK (Android Package
                                Kit) file, which can be installed on Android devices.</li>
                            <li><b>Debugger:</b> A tool that allows developers to inspect and fix code errors in
                                real-time, making it easier to identify issues during development.</li>
                            <li><b>Android Virtual Device (AVD):</b> This tool lets developers create and configure
                                various virtual devices with different screen sizes, resolutions, and Android versions,
                                to test the app on a wide range of environments.</li>
                            <li><b>Command-line Tools:</b> Android SDK includes command-line utilities to manage
                                devices, create emulators, and perform other development tasks directly from the
                                terminal.</li>
                        </ul>
                    </li>
                    <li><b>Development Environment:</b> The SDK integrates seamlessly with Android Studio, the official
                        Integrated Development Environment (IDE) for Android development. Android Studio provides a
                        user-friendly interface for writing code, designing user interfaces, debugging, and managing
                        resources.</li>
                </ul>
            </div>

            <div class="in">
                <h3>2: How Does the Android SDK Work?</h3>
                <p>When a developer builds an Android app, they utilize the Android SDK’s libraries and APIs to interact
                    with the Android operating system. These components simplify common tasks like displaying user
                    interfaces, handling network requests, and accessing device hardware like cameras and sensors.</p>
                <ul>
                    <li><b>APIs and Libraries:</b> Instead of writing everything from scratch, developers use the SDK's
                        pre-built APIs to handle things like:
                        <ul>
                            <li>UI elements: Buttons, text fields, and layouts.</li>
                            <li>Data storage: Managing databases (SQLite), shared preferences, or files.</li>
                            <li>Network operations: Handling internet connections, making HTTP requests, or syncing
                                data.</li>
                            <li>Multimedia: Playing audio and video, or using the device’s camera.</li>
                            <li>Sensors and hardware access: Accessing features like GPS, accelerometer, and
                                Bluetooth.</li>
                        </ul>
                    </li>
                    <li><b>Emulator & AVD:</b> The SDK emulator is used for testing apps on virtual devices that
                        simulate real-world scenarios like different screen sizes, operating system versions, or
                        hardware configurations. This makes it easier to test compatibility across various devices
                        without having to own them.</li>
                </ul>
            </div>

            <div class="in">
                <h3>3: Benefits of Using Android SDK</h3>
                <p>The Android SDK provides several advantages to developers:</p>
                <ul>
                    <li><b>Speed and Efficiency:</b> The SDK provides pre-built libraries and components, which save
                        time and effort when developing apps. Developers can focus on building the core features of
                        their app rather than writing common functionalities from scratch.</li>
                    <li><b>Wide Range of Tools:</b> The SDK includes tools for testing, debugging, and building apps.
                        This integrated toolkit allows developers to work in one environment (Android Studio) without
                        needing external tools.</li>
                    <li><b>Multi-Device Testing:</b> Developers can test their apps on a variety of virtual devices with
                        different screen sizes, hardware configurations, and Android versions, ensuring the app runs
                        smoothly across a wide range of Android devices.</li>
                    <li><b>Access to Android Features:</b> By using the SDK’s APIs, developers can access the full range
                        of Android features, including notifications, sensors, and hardware, enabling them to create
                        rich and powerful apps.</li>
                    <li><b>Frequent Updates:</b> Google regularly updates the SDK to provide new features, support for
                        the latest Android versions, and tools that enhance app performance and security.</li>
                </ul>
            </div>

            <div class="in">
                <h3>4: Development Workflow Using the Android SDK</h3>
                <p>The typical workflow when building an Android app with the SDK involves:</p>
                <ul>
                    <li><b>1. Setting Up Android Studio:</b> The developer installs Android Studio, which comes with the
                        Android SDK bundled in it.</li>
                    <li><b>2. Writing Code:</b> Using Android Studio, the developer writes code in Java or Kotlin,
                        utilizing the SDK’s libraries and APIs to build the app's functionality.</li>
                    <li><b>3. Designing UI:</b> The developer uses the UI design tools in Android Studio to create the
                        app’s interface, making it responsive across different device screen sizes.</li>
                    <li><b>4. Testing with Emulator:</b> The app is tested on various virtual devices using the SDK’s
                        emulator, ensuring compatibility and performance across different Android versions and hardware.
                    </li>
                    <li><b>5. Debugging:</b> The SDK’s debugging tools help the developer find and fix issues in the app
                        before it is ready for deployment.</li>
                    <li><b>6. Building the APK:</b> Once development is complete, the SDK’s build tools are used to
                        compile the app and package it into an APK (Android Package Kit), which can be installed on
                        Android devices.</li>
                </ul>
            </div>

            <div class="in">
                <h3>5: Why the Android SDK is Essential for Android Development</h3>
                <p>The Android SDK is essential because it provides the core tools and components that developers need
                    to build, test, and deploy Android apps efficiently. Without the SDK, developers would have to
                    create everything from scratch, which would be time-consuming and error-prone.</p>
                <ul>
                    <li>The SDK gives developers access to the same tools used by Google and other leading Android
                        developers.</li>
                    <li>It ensures that apps are optimized for performance and compatibility across the vast range of
                        Android devices.</li>
                    <li>It simplifies the process of integrating Android’s unique features (like notifications, sensors,
                        or background services) into apps.</li>
                </ul>
            </div>


        </div>
        <div class="wh">
            <h2>Android Architecture</h2>

            <p>Android architecture is the structure of the Android operating system, designed to support a variety of
                applications and services. It is built on a Linux kernel and consists of several layers that work
                together to handle different functions of the system and apps.</p>
            <img src="../../images/ap2.png" alt="">
            <div class="in">
                <h3>Linux Kernel</h3>
                <p>The Linux kernel is the core of the Android operating system. It is not just a standard Linux OS but
                    is tailored for Android devices, acting as a layer between the hardware and software.</p>
                <img src="../../images/ap5.png" alt="">
                <ul>
                    <li><b>Role:</b> Provides essential functions and services to manage the device.</li>
                    <li><b>Key Functions:</b>
                        <ul>
                            <li><b>Security:</b> Ensures that data and operations are protected.</li>
                            <li><b>Memory Management:</b> Manages the device's memory allocation.</li>
                            <li><b>Process Management:</b> Handles running processes and tasks.</li>
                            <li><b>Network Stack:</b> Manages network connections and communication.</li>
                            <li><b>Driver Model:</b> Controls hardware components such as audio, display, and more.</li>
                        </ul>
                    </li>
                </ul>
                <ul>
                    <li><b>Drivers:</b> Special programs that control and communicate with hardware components. Examples
                        include:
                        <ul>
                            <li><b>Audio:</b> Manages sound output and input.</li>
                            <li><b>Binder:</b> Handles communication between different apps and processes.</li>
                            <li><b>Display:</b> Controls what is shown on the screen.</li>
                            <li><b>Keypad:</b> Manages input from physical and virtual keyboards.</li>
                            <li><b>Bluetooth:</b> Handles wireless communication with other devices.</li>
                            <li><b>Camera:</b> Manages the device's camera functions.</li>
                            <li><b>Shared Memory:</b> Allows different processes to access common data.</li>
                            <li><b>USB:</b> Manages connections to USB devices.</li>
                            <li><b>Wi-Fi:</b> Handles wireless network connections.</li>
                        </ul>
                    </li>
                    <li><b>Power Management:</b> Manages how the device uses and conserves battery power.</li>
                </ul>
            </div>
            <div class="in">
                <h3>Hardware Abstraction Layer (HAL)</h3>
                <p>The Hardware Abstraction Layer (HAL) sits just above the Linux kernel and provides a standard
                    interface for hardware components. It helps the Android system communicate with different hardware
                    without needing specific drivers for each device.</p>
                <img src="../../images/ap6.png" alt="">
                <ul>
                    <li><b>Role:</b> Acts as an interface between the hardware and the higher-level software.</li>
                    <li><b>Purpose:</b> Allows Android to support a wide range of hardware by providing a consistent
                        API.</li>
                    <li><b>Components:</b> Includes drivers for various hardware such as audio, camera, and sensors.
                    </li>
                </ul>
            </div>
            <div class="in">
                <h3>Libraries</h3>
                <p>These libraries are written in C/C++ and operate in the background of the system, providing essential
                    functions and performance optimizations specifically for Android's embedded Linux environment.</p>
                <img src="../../images/ap7.png" alt="">
                <ul>
                    <li><b>Function:</b> Supports various system and application functions efficiently.</li>
                    <li><b>Examples:</b>
                        <ul>
                            <li><b>WebKit:</b> A web engine for rendering web pages.</li>
                            <li><b>OpenMAX AL:</b> A multimedia library for audio and video processing.</li>
                            <li><b>libc:</b> The standard C library for basic functions.</li>
                            <li><b>Media Framework:</b> Handles media playback and recording.</li>
                            <li><b>OpenGL ES:</b> Provides graphics rendering capabilities.</li>
                        </ul>
                    </li>
                </ul>
            </div>
            <div class="in">
                <h3>Android Runtime</h3>
                <p>The Android Runtime (ART) is crucial for running Android applications. It replaces the older Dalvik
                    VM, offering improved performance and efficiency.</p>
                <img src="../../images/ap8.png" alt="">
                <ul>
                    <li><b>ART (Android Runtime):</b> Executes app code and provides runtime services.</li>
                    <li><b>Dalvik Virtual Machine:</b> The previous runtime environment for Android apps. It was
                        register-based and executed files in the Dalvik Executable (.dex) format.</li>
                    <li><b>Core Libraries:</b> Provide fundamental Java functionalities for app development.</li>
                    <li><b>Note:</b> Each Android app runs in its own process with a separate instance of the runtime
                        for better security and stability.</li>
                </ul>
            </div>
            <div class="in">
                <h3>Java API Framework</h3>
                <p>This layer simplifies app development by providing APIs that allow apps to interact with system
                    services and components.</p>
                <img src="../../images/ap9.png" alt="">
                <ul>
                    <li><b>Purpose:</b> Makes it easier to reuse and integrate components across different apps.</li>
                    <li><b>Key Components:</b>
                        <ul>
                            <li><b>View System:</b> Manages user interface elements and interactions.</li>
                            <li><b>Content Providers:</b> Allow apps to access and share data with other apps.</li>
                            <li><b>Resource Manager:</b> Manages app resources like strings, layouts, and images.</li>
                            <li><b>Managers:</b> Provide various system services such as activity management and
                                notifications.</li>
                        </ul>
                    </li>
                </ul>
            </div>
            <div class="in">
                <h3>Application Layer</h3>
                <p>The top layer includes both system apps and third-party apps. System apps are pre-installed and
                    provide basic functions for the device.</p>
                <img src="../../images/ap10.png" alt="">
                <ul>
                    <li><b>System Apps:</b> Core applications that come with the Android platform, written in Java.
                        Examples include:
                        <ul>
                            <li><b>Email Client:</b> Manages email communications.</li>
                            <li><b>SMS Program:</b> Handles text messaging.</li>
                            <li><b>Calendar:</b> Manages events and schedules.</li>
                            <li><b>Maps:</b> Provides navigation and location services.</li>
                            <li><b>Browser:</b> Allows web browsing.</li>
                            <li><b>Contacts:</b> Manages contact information.</li>
                            <li><b>And Others:</b> Additional apps that provide essential functions.</li>
                        </ul>
                    </li>
                    <li><b>Note:</b> Third-party applications operate at the same level as these system apps and can
                        utilize similar system services and resources.</li>
                </ul>
            </div>
            <div class="in">
                <h3>Step-by-step process of how all components work when you are running a music streaming app:</h3>
                <ul>
                    <li>
                        <p><strong>System Apps:</strong> Your app's icon is displayed in the launcher (part of system
                            apps). When you tap on it, the launcher triggers the app's start process.</p>
                        <p>At this point, your app is handled by the <strong>Java API Framework</strong>, but it’s still
                            working through higher-level services provided by the system apps like the phone’s
                            notification system and the background services that keep it alive.</p>
                    </li>

                    <li>
                        <p><strong>Java API Framework:</strong> Once the app is running, you see the app's interface,
                            created using components like buttons, lists, etc. (provided by the <strong>Java API
                                Framework</strong>).</p>
                        <p>When you press "Play" to start a song, this framework handles user interaction and
                            communicates the command (to play music) to the lower system layers.</p>
                    </li>

                    <li>
                        <p><strong>Android Runtime (ART):</strong> The code of your music app (written in Java or
                            Kotlin) is being executed by the <strong>Android Runtime (ART)</strong>. This translates
                            your app’s high-level code (like playing music) into machine code, so your phone can
                            understand and run it efficiently.</p>
                        <p>ART also manages memory for your app, ensuring it doesn’t consume too much, especially if you
                            are multitasking.</p>
                    </li>

                    <li>
                        <p><strong>Native Libraries:</strong> Native libraries like <strong>OpenGL</strong> or
                            <strong>Media Framework</strong> handle tasks like processing the music stream, controlling
                            audio playback, or even rendering album art in the app.</p>
                        <p>For example, once you hit "Play," the app uses native libraries to decode the music file and
                            output sound through the speakers.</p>
                    </li>

                    <li>
                        <p><strong>Hardware Abstraction Layer (HAL):</strong> Now, your app needs to interact with the
                            device's audio hardware (like speakers or headphones). It does this through the
                            <strong>Hardware Abstraction Layer (HAL)</strong>, which acts as a bridge between the app
                            and the hardware.</p>
                        <p>The <strong>Audio HAL</strong> sends signals to the hardware, ensuring your music is played
                            correctly through your headphones or speakers without your app needing to directly handle
                            hardware instructions.</p>
                    </li>

                    <li>
                        <p><strong>Linux Kernel:</strong> At the lowest level, the <strong>Linux Kernel</strong> manages
                            communication between hardware and software. For example, it makes sure the audio hardware
                            is powered on, controls CPU and memory allocation, and handles network data (if you're
                            streaming online music).</p>
                        <p>If your app needs to download a song or stream from the internet, the kernel communicates
                            with the network hardware (Wi-Fi or mobile data) to make that connection happen.</p>
                    </li>
                </ul>
            </div>
        </div>

        <div class="wh">
            <h2>Android Studio</h2>

            <p>Android Studio is the official Integrated Development Environment (IDE) for Android development. It
                provides a comprehensive set of tools for building Android applications. In this topic, we will use Java
                as the programming language for our projects, not Kotlin. Below is an overview of the typical folder
                structure in an Android project and the files contained within each folder.</p>

            <div class="in">
                <h3>Android Folder Structure</h3>
                <ul id="lessSpace">
                    <li><b>app 📁</b>
                        <ul>
                            <li><b>manifests 📁</b>
                                <ul>
                                    <li>AndroidManifest.xml 📄</li>
                                </ul>
                            </li>
                            <li><b>java 📁</b>
                                <ul>
                                    <li>com.example.appname 📁
                                        <ul>
                                            <li>MainActivity.java 📄</li>
                                        </ul>
                                    </li>
                                </ul>
                            </li>
                            <li><b>res 📁</b>
                                <ul>
                                    <li><b>drawable 📁</b>
                                        <ul>
                                            <li>Icons, images, and other drawable resources 📄</li>
                                        </ul>
                                    </li>
                                    <li><b>layout 📁</b>
                                        <ul>
                                            <li>activity_main.xml 📄</li>
                                        </ul>
                                    </li>
                                    <li><b>mipmap 📁</b>
                                        <ul>
                                            <li>Launcher icons of different sizes 📄</li>
                                        </ul>
                                    </li>
                                    <li><b>values 📁</b>
                                        <ul>
                                            <li>strings.xml 📄</li>
                                            <li>colors.xml 📄</li>
                                            <li>styles.xml 📄</li>
                                        </ul>
                                    </li>
                                </ul>
                            </li>
                            <li><b>res (generated) 📁</b>
                                <ul>
                                    <li>R.java 📄 (generated resource IDs)</li>
                                </ul>
                            </li>
                            <li><b>gradle scripts 📁</b>
                                <ul>
                                    <li>build.gradle (Project-level) 📄</li>
                                    <li>build.gradle (Module-level) 📄</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                </ul>
            </div>

            <p>In an Android project, the folder structure plays a crucial role in organizing the various components and
                resources needed for development. Understanding this structure helps in navigating the project and
                managing the different elements effectively. Below is a detailed explanation of the key folders in an
                Android project.</p>

            <div class="in">
                <h3>1: Android Manifest Folder</h3>
                <p>The <b>manifests 📁</b> folder contains important configuration files for the Android app.</p>
                <ul>
                    <li><b>AndroidManifest.xml 📄</b>
                        <p>This is the main configuration file for the Android application. It defines essential
                            information about the app, including:</p>
                        <ul>
                            <li>Application components (activities, services, broadcast receivers, and content
                                providers).</li>
                            <li>Permissions required by the app.</li>
                            <li>Application metadata and features.</li>
                            <li>Application theme and settings.</li>
                        </ul>
                        <p><i>Note:</i> The manifest file outlines the structure and metadata of the app, specifying its
                            components and requirements.</p>
                    </li>
                </ul>
            </div>

            <div class="in">
                <h3>2: Android Java Folder</h3>
                <p>The <b>java 📁</b> folder contains Java source code files for the application.</p>
                <ul>
                    <li><b>com.example.appname 📁</b>
                        <p>This package directory holds Java classes and source code for the app. It typically includes:
                        </p>
                        <ul>
                            <li><b>MainActivity.java 📄</b>
                                <p>This is the main activity file where the primary code for the application’s main
                                    screen is written. It contains the logic for the UI and interacts with other
                                    components of the app.</p>
                            </li>
                        </ul>
                        <p><i>Note:</i> This folder includes Java source code files, organized by package names, and
                            also contains test code.</p>
                    </li>
                </ul>
            </div>

            <div class="in">
                <h3>3: Res Folder</h3>
                <p>The <b>res 📁</b> folder contains all the resources for the application. These are non-code files
                    used in the app, such as:</p>
                <ul>
                    <li><b>drawable 📁</b>
                        <p>Holds drawable resources like icons and images used in the app.</p>
                    </li>
                    <li><b>layout 📁</b>
                        <p>Contains XML files that define the layout of the application's user interface. For example:
                        </p>
                        <ul>
                            <li><b>activity_main.xml 📄</b> - Defines the layout for the main activity.</li>
                        </ul>
                    </li>
                    <li><b>mipmap 📁</b>
                        <p>Stores launcher icons of different sizes to ensure the app icon displays correctly on various
                            devices.</p>
                    </li>
                    <li><b>values 📁</b>
                        <p>Contains XML files for defining values used throughout the app. These include:</p>
                        <ul>
                            <li><b>strings.xml 📄</b> - Stores string resources.</li>
                            <li><b>colors.xml 📄</b> - Defines color resources used in the app.</li>
                            <li><b>styles.xml 📄</b> - Contains style definitions for UI elements.</li>
                        </ul>
                    </li>
                </ul>
                <p><i>Note:</i> This folder contains all non-code resources such as XML layouts, UI strings, and bitmap
                    images, organized into corresponding sub-directories.</p>
            </div>

            <div class="in">
                <h3>4: Gradle Folder</h3>
                <p>The <b>gradle scripts 📁</b> folder contains Gradle build scripts used for managing the build process
                    of the application.</p>
                <ul>
                    <li><b>build.gradle (Project-level) 📄</b>
                        <p>This script configures settings that apply to the entire project, such as repositories and
                            dependencies shared across modules.</p>
                    </li>
                    <li><b>build.gradle (Module-level) 📄</b>
                        <p>This script is specific to each module and configures settings like compile SDK version,
                            dependencies for the module, and build types.</p>
                    </li>
                </ul>
                <p><i>Note:</i> Gradle is an open-source build system used to automate building, testing, and
                    deployment. It defines module-specific build configurations and allows you to add necessary
                    dependencies for your Android application.</p>
            </div>


        </div>
        <div class="wh">
            <h2>Understanding Android Runtime</h2>
            <p>The Android Runtime (ART) is a crucial part of the Android operating system responsible for executing
                applications. Initially, Android used the Dalvik Virtual Machine (DVM), but transitioned to ART to
                enhance performance and efficiency. This section explores the Android Runtime, compares it with the Java
                Virtual Machine (JVM), and explains the differences and reasons for these changes.</p>

            <div class="in">
                <h3>1. Overview of Android Runtime</h3>
                <p>Android Runtime enables the execution of Android applications by providing a runtime environment. ART
                    replaced DVM to improve overall performance and battery efficiency. This section provides an
                    overview of ART and its key features.</p>
            </div>

            <div class="in">
                <h3>2. Dalvik Virtual Machine (DVM)</h3>
                <p>The Dalvik Virtual Machine (DVM) was the initial runtime environment used by Android to execute
                    applications. It was designed specifically for mobile devices with limited resources.</p>
                <ul>
                    <li><b>Characteristics:</b>
                        <ol>
                            <li><b>Register-Based Model:</b> DVM uses a register-based architecture, which is more
                                memory-efficient compared to the stack-based model used by JVM.</li>
                            <li><b>Dalvik Bytecode:</b> Executes Dalvik Executable (.dex) files. Each Android
                                application runs in its own process with a dedicated instance of DVM.</li>
                            <li><b>Memory Efficiency:</b> Designed for low-memory devices, allowing multiple instances
                                of DVM to run efficiently.</li>
                            <li><b>JIT Compiler:</b> From Android 2.2, DVM included a Just-In-Time (JIT) compiler that
                                compiles bytecode into machine code at runtime to improve performance.</li>
                        </ol>
                    </li>
                </ul>
            </div>

            <div class="in">
                <h3>3. Android Runtime (ART)</h3>
                <p>ART replaced DVM starting from Android 4.4 (KitKat) to address performance and efficiency issues,
                    providing a more robust runtime environment.</p>
                <ul>
                    <li><b>Characteristics:</b>
                        <ol>
                            <li><b>AOT Compiler:</b> ART uses Ahead-Of-Time (AOT) compilation, converting bytecode into
                                machine code during the build process. This results in faster app startup times and
                                improved runtime performance.</li>
                            <li><b>Battery Performance:</b> ART enhances battery life by reducing the need for frequent
                                JIT compilation, which is resource-intensive.</li>
                            <li><b>Garbage Collection:</b> ART offers more efficient garbage collection compared to DVM,
                                leading to better memory management.</li>
                            <li><b>Storage & Boot Time:</b> ART requires more storage and results in longer boot times
                                as it builds a cache during the first boot.</li>
                        </ol>
                    </li>
                </ul>
            </div>
            <div class="in">
                <h3>4. JVM vs. DVM</h3>
                <p>Comparing the Java Virtual Machine (JVM) with the Dalvik Virtual Machine (DVM) helps understand why
                    Android switched from DVM to ART and the differences in their architectures.</p>
                <ul>
                    <li><b>JVM (Java Virtual Machine):</b>
                        <ol>
                            <li><b>Stack-Based Model:</b> JVM uses a stack-based architecture, which requires more
                                memory and is slower compared to DVM's register-based model.</li>
                            <li><b>Bytecode Execution:</b> Executes Java bytecode (.class files) and is
                                platform-independent, supporting multiple operating systems.</li>
                            <li><b>Single Instance:</b> Typically, a single JVM instance is shared among multiple
                                applications.</li>
                            <li><b>Process:</b> Java source code → Javac → Bytecode → JVM → Machine code</li>
                        </ol>
                    </li>
                    <li><b>DVM (Dalvik Virtual Machine):</b>
                        <ol>
                            <li><b>Register-Based Model:</b> More memory-efficient and faster for mobile devices with
                                limited resources.</li>
                            <li><b>Dalvik Bytecode:</b> Executes .dex files specific to Android, optimized for low-power
                                devices.</li>
                            <li><b>Multiple Instances:</b> Allows multiple instances of DVM to run efficiently, each
                                handling its own application.</li>
                            <li><b>Process:</b> Android source code → Javac → Bytecode → Dex compiler (dex tool) →
                                Dalvik Bytecode (.dex file) → DVM → Machine code</li>
                        </ol>
                    </li>
                </ul>
            </div>
            <div class="in">
                <h3>5. JIT vs. AOT Compilation</h3>
                <p>JIT and AOT compilation are methods used to improve application performance, operating at different
                    stages of the development process.</p>
                <ul>
                    <li><b>JIT (Just-In-Time) Compilation:</b>
                        <ol>
                            <li><b>Runtime Compilation:</b> JIT compiles bytecode into machine code at runtime,
                                enhancing performance but consuming more resources during execution.</li>
                        </ol>
                    </li>
                    <li><b>AOT (Ahead-Of-Time) Compilation:</b>
                        <ol>
                            <li><b>Build-Time Compilation:</b> AOT compiles code during the build process, leading to
                                faster app startup times and better runtime performance.</li>
                        </ol>
                    </li>
                </ul>
            </div>
            <div class="in">
                <h3>6. ART vs. DVM</h3>
                <p>ART and DVM have different impacts on performance and system resources. This section compares ART and
                    DVM based on several factors:</p>
                <ul>
                    <li><b>Battery Performance:</b> ART improves battery life compared to DVM by reducing the need for
                        frequent JIT compilation.</li>
                    <li><b>Storage:</b> DVM is more suitable for devices with low storage due to its less
                        resource-intensive nature.</li>
                    <li><b>Boot Time:</b> ART results in longer boot times as it builds a cache during the first boot,
                        which can be a trade-off for improved performance.</li>
                    <li><b>Application Launch Time:</b> DVM has a slower launch time for applications compared to ART,
                        which benefits from AOT compilation.</li>
                    <li><b>Garbage Collection:</b> ART has more efficient garbage collection, leading to better memory
                        management compared to DVM.</li>
                </ul>
            </div>
            <p>The transition from DVM to ART represents a significant enhancement in the Android runtime environment.
                ART's advanced features, including AOT compilation and improved garbage collection, address the
                limitations of DVM, resulting in better performance, efficiency, and battery life for Android devices.
            </p>
        </div>
        <div class="wh">
            <h2>Android Boot Process</h2>
            <img src="../../images/ap11.jpeg" alt="">

            <p>Android, like any operating system, goes through a series of steps to start up the device and make the
                system ready for user interaction. These steps are crucial to initialize hardware, system services, and
                load the core framework that supports Android applications. Below, we will explain each stage in detail:
            </p>

            <h3>1. Boot ROM</h3>
            <ul>
                <li>When you press the power button, the device hardware (like the CPU) receives power.</li>
                <li><strong>Boot ROM</strong> is the first component that runs, which is part of the hardware itself.
                </li>
                <li>Its job is to load the <strong>bootloader</strong> into RAM (the device’s main memory) from a fixed
                    location (often the internal storage).</li>
                <li>This step is critical as it kicks off the entire boot process by giving the system a way to start
                    executing the bootloader.</li>
            </ul>

            <h3>2. Bootloader</h3>
            <ul>
                <li>Once the <strong>bootloader</strong> is loaded into RAM, it starts executing.</li>
                <li>The bootloader works in two stages:</li>
                <ul>
                    <li><strong>Stage 1:</strong> It detects the external RAM (device memory) and ensures that the
                        system has enough memory to continue. It also prepares the system for the next steps.</li>
                    <li><strong>Stage 2:</strong> In this stage, the bootloader sets up important parts of the system,
                        such as network configurations and memory allocation.</li>
                </ul>
            </ul>

            <h3>3. Kernel</h3>
            <ul>
                <li>The bootloader then hands over control to the <strong>Linux Kernel</strong>, which is the core of
                    the Android operating system.</li>
                <li>The kernel is responsible for:</li>
                <ul>
                    <li>Setting up cache and protected memory areas.</li>
                    <li>Initializing input/output (I/O) systems, such as touchscreens, USB, and Wi-Fi.</li>
                    <li>Loading device drivers (for hardware like the camera, audio, etc.).</li>
                    <li>Starting essential system processes, called <em>daemons</em> (background services that keep the
                        system running).</li>
                </ul>
                <li>The kernel then searches for the first system process called <strong>init</strong>.</li>
            </ul>

            <h3>4. Init Process</h3>
            <ul>
                <li><strong>Init</strong> is the first process started by the kernel.</li>
                <li>Its role is to mount key system directories, such as:</li>
                <ul>
                    <li><code>/sys</code> - contains system configuration files.</li>
                    <li><code>/dev</code> - contains device files representing hardware components.</li>
                    <li><code>/proc</code> - contains process information.</li>
                </ul>
                <li>The init process also runs an <strong>init.rc</strong> script, which sets up system properties and
                    triggers the <strong>Zygote</strong> process (which handles app management).</li>
            </ul>

            <h3>5. Zygote</h3>
            <ul>
                <li><strong>Zygote</strong> is a critical process that helps Android manage applications more
                    efficiently.</li>
                <li>Its goal is to launch applications by:</li>
                <ul>
                    <li>Preloading core library classes that apps need to run (e.g., Java libraries).</li>
                    <li>Creating a shared memory space that allows multiple instances of the Dalvik Virtual Machine
                        (DVM) to use the same code, saving memory.</li>
                    <li>Starting applications quickly by copying the memory space instead of starting from scratch.</li>
                </ul>
            </ul>

            <h3>6. System Server and Services</h3>
            <ul>
                <li>Once Zygote is initialized, it starts the <strong>System Server</strong>, which is responsible for
                    launching important Android services like:</li>
                <ul>
                    <li>Power Manager</li>
                    <li>Activity Manager</li>
                    <li>Telephony Manager</li>
                    <li>Package Manager</li>
                    <li>Bluetooth and Sensor Services</li>
                    <li>Other core system services (e.g., Alarm Manager, Battery Manager, etc.)</li>
                </ul>
                <li>Once these services are up and running, the system broadcasts an
                    <strong>"ACTION_BOOT_COMPLETED"</strong> signal, indicating that the system is fully booted and
                    ready for use.
                </li>
            </ul>
            <p>The Android boot process is a layered sequence that starts from the hardware level (Boot ROM) and ends
                with launching core system services via Zygote. Each step ensures that the hardware and software are
                correctly initialized, allowing the Android operating system to function smoothly and efficiently.</p>

        </div>
        <div class="wh">
            <h2>Android Development Tools</h2>

            <p>Android development relies on a variety of tools that help developers create, test, and debug their
                applications. These tools ensure that Android apps function correctly across different devices and
                operating systems. Understanding these tools is essential for efficient Android development. In this
                section, we will cover key Android tools like the Dalvik Virtual Machine (DVM), Android Virtual Device
                (AVD) Manager, Android SDK Manager, Android Emulator, DDMS, and the resource folder, highlighting their
                roles and how they relate to each other in the development workflow.</p>

            <div class="in">
                <h3>Dalvik Virtual Machine (DVM)</h3>

                <p>The <strong>Dalvik Virtual Machine (DVM)</strong> is a core part of Android's runtime environment,
                    responsible for running applications. The DVM is designed specifically for mobile devices,
                    optimizing
                    memory usage, battery life, and performance. It allows multiple instances of applications to run
                    efficiently in a low-memory environment, which is crucial for mobile devices.</p>

                <p>When you write Android code in Java, the code is first compiled into bytecode by the Java compiler
                    (Javac). Then, it is further converted into Dalvik bytecode using the Dex compiler, generating a
                    ".dex"
                    file that runs on the DVM. Although Android has since moved to the ART runtime, understanding DVM is
                    still important for understanding the evolution of Android development.</p>

                <ul>
                    <li><strong>Role:</strong> Executes Android applications by interpreting ".dex" files.</li>
                    <li><strong>Relation to other tools:</strong> DVM works with the Android SDK and other development
                        tools
                        to run apps on actual devices or emulators.</li>
                </ul>
            </div>

            <div class="in">
                <h3>Android Virtual Device (AVD) Manager</h3>

                <p>The <strong>AVD Manager</strong> is an essential tool that allows developers to create and manage
                    virtual
                    devices for testing. These virtual devices, called Android Virtual Devices (AVDs), emulate the
                    hardware
                    and software environment of real Android devices, enabling developers to test their applications on
                    different device configurations, screen sizes, and API levels without needing physical devices.</p>

                <ul>
                    <li><strong>Role:</strong> Helps in creating and managing virtual devices to simulate various
                        Android
                        environments.</li>
                    <li><strong>Relation to other tools:</strong> Works in tandem with the Android Emulator to provide a
                        platform for running and testing apps in a simulated environment.</li>
                </ul>
            </div>

            <div class="in">
                <h3>Android SDK Manager</h3>

                <p>The <strong>Android SDK Manager</strong> is used to download, install, and manage different
                    components of
                    the Android SDK, such as tools, system images, platform versions, and libraries. The SDK (Software
                    Development Kit) provides the essential development tools required for building Android
                    applications.
                    The SDK Manager ensures that the development environment is up to date and includes all the
                    necessary
                    components.</p>

                <ul>
                    <li><strong>Role:</strong> Manages the Android SDK components, ensuring developers have the tools
                        needed
                        to build applications.</li>
                    <li><strong>Relation to other tools:</strong> Integrates with Android Studio and other IDEs to
                        provide
                        updates and configurations for building Android apps.</li>
                </ul>
            </div>

            <div class="in">
                <h3>Android Emulator</h3>

                <p>The <strong>Android Emulator</strong> is a powerful tool that mimics an Android device on your
                    computer,
                    allowing you to run and test Android applications without needing physical hardware. It simulates a
                    variety of configurations, such as different screen sizes, resolutions, and Android versions, making
                    it
                    a valuable tool for testing apps under different conditions.</p>

                <ul>
                    <li><strong>Role:</strong> Provides a virtual platform to test and run Android apps without physical
                        devices.</li>
                    <li><strong>Relation to other tools:</strong> Works closely with AVD Manager to run virtual devices
                        and
                        is a key part of the testing and debugging process.</li>
                </ul>
            </div>

            <div class="in">
                <h3>Dalvik Debug Monitor Service (DDMS)</h3>

                <p>The <strong>Dalvik Debug Monitor Service (DDMS)</strong> is a powerful debugging tool for Android
                    applications. It provides features like thread and heap information, logcat logs, file explorer, and
                    emulator control. DDMS helps developers track the performance of their apps, identify memory leaks,
                    and
                    debug crashes.</p>

                <ul>
                    <li><strong>Role:</strong> Offers extensive debugging capabilities, allowing developers to monitor
                        and
                        control app behavior in real-time.</li>
                    <li><strong>Relation to other tools:</strong> It interacts with the Android Emulator and AVD Manager
                        for
                        debugging apps running on virtual devices, as well as physical devices connected via USB.</li>
                </ul>
            </div>

            <div class="in">
                <h3>Resource Folder (Res)</h3>

                <p>The <strong>resource folder</strong> (<code>res/</code>) in Android projects stores non-code
                    resources
                    such as XML layouts, UI strings, images, and other drawable assets. These resources are organized
                    into
                    subdirectories, and Android automatically loads the correct resources based on the device
                    configuration
                    (e.g., screen size, orientation, or language).</p>

                <ul>
                    <li><strong>Role:</strong> Holds essential non-code assets such as layouts, images, and strings used
                        by
                        the application.</li>
                    <li><strong>Relation to other tools:</strong> Resources from the <code>res/</code> folder are linked
                        in
                        the app's code and used by tools like the AVD Manager and Android Emulator to render the app’s
                        UI
                        during testing.</li>
                </ul>
            </div>
            <p>In Android development, tools like the DVM, AVD Manager, SDK Manager, Emulator, DDMS, and the resource
                folder play a crucial role in ensuring that developers can efficiently build, test, and debug their
                applications. These tools work together in harmony, creating an environment that simplifies the
                development process while addressing the unique challenges of mobile app development. From managing
                resources to testing apps on virtual devices, these tools form the backbone of Android development.</p>

        </div>
        <div class="wh">
            <h2>First Android Program: Hello World</h2>

            <p>In Android, the simplest way to get started is by creating an application that displays the text "Hello
                World" on the screen. Below, we will discuss the classes and methods used in the basic 'Hello World'
                app.</p>

            <h3>1. Main Components of the "Hello World" Android Program</h3>

            <ul>
                <li><strong>MainActivity.java</strong>: This is the main entry point of the app. It's a Java file where
                    you define the behavior of the app's interface.</li>
                <li><strong>activity_main.xml</strong>: This is the layout file where the UI of the app is defined, like
                    buttons, text, etc. For the 'Hello World' program, it will simply contain a TextView that displays
                    "Hello World".</li>
            </ul>

            <h3>2. MainActivity.java</h3>

            <p>This class is the backbone of any Android app. In this case, we are using Java to code the app’s
                behavior. Here's a simplified version of the "Hello World" code and an explanation of its elements:</p>

            <pre>
                <code> 
public class MainActivity extends AppCompatActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
    }
}
                </code>
            </pre>

            <ul>
                <li><strong>MainActivity:</strong> This is the class that controls the main screen of the app. It
                    extends <i>AppCompatActivity</i>, which provides backward compatibility for older Android
                    versions.</li>
                <li><strong>onCreate(Bundle savedInstanceState):</strong> This is the method that runs when the activity
                    is created. It sets up the initial state of the app. The <i>Bundle</i> parameter holds the
                    saved state of the activity (if any), which allows restoring the state when the app is relaunched.
                </li>
                <li>Why do we pass Bundle savedInstanceState?
                    <ul>
                        <li>When your activity is temporarily destroyed (for example, when you rotate the phone or
                            switch to another app), Android might want to recreate it later. To do this, it saves
                            certain important data in the Bundle object.</li>
                        <li>If there's data in the Bundle, it means Android is trying to restore your activity to the
                            way it was before it was destroyed. If the Bundle is null, it means the activity is starting
                            fresh, with no previous saved state.</li>
                        <li>Example:

                            Imagine you're using an app, and you rotate your phone. The screen changes from portrait to
                            landscape. When this happens, Android destroys and recreates the activity. If you were
                            filling out a form, you wouldn’t want to lose all the data you had entered. That’s where the
                            Bundle comes in—it saves and restores that data for you.</li>
                    </ul>
                </li>
                <li>Why do we call super.onCreate(savedInstanceState)?
                    <ol>
                        <li>Ensures Proper Setup: When you call super.onCreate(savedInstanceState), you're allowing the
                            parent class (AppCompatActivity) to do its part in setting up the activity. Android's
                            internal systems rely on this to properly initialize things like the window, UI, and other
                            components before your specific code runs.</li>
                        <li>Maintains Lifecycle Consistency: Every time an activity goes through its lifecycle (e.g.,
                            being created, started, resumed), Android needs to ensure that the appropriate steps are
                            taken to transition the activity from one state to another. The parent class (through super)
                            knows how to handle these transitions. If you don't call super.onCreate(), you risk breaking
                            this lifecycle consistency, and your app might behave unpredictably.</li>
                        <li>Builds on Existing Functionality: By calling super, you're saying, "First, do everything the
                            system needs to do for this stage of the lifecycle. Then, I’ll add my own code." It's like
                            building on top of a solid foundation provided by Android.</li>
                        <li>Example Analogy:

                            Imagine you're a chef cooking in a kitchen. Before you start, you need the kitchen
                            setup—stoves turned on, ingredients placed in the right spots, etc. Android's
                            AppCompatActivity is like the kitchen staff who takes care of all this setup for you. When
                            you call super.onCreate(), you're letting them do their job first, so when you start cooking
                            (writing your own code), everything is ready to go!</li>
                    </ol>
                </li>
                <li><strong>setContentView(R.layout.activity_main):</strong> This method sets the layout of the
                    activity, defined in the <i>activity_main.xml</i> file. It links the XML layout to the Java
                    code.</li>
            </ul>

            <h3>3. activity_main.xml</h3>

            <p>This is the XML file where the app's user interface is designed. In our case, the interface is quite
                simple, with just a TextView displaying "Hello World".</p>

            <pre>
                <code>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"&gt;

    &lt;TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Hello World!"
        android:textSize="24sp"
        android:layout_gravity="center"/&gt;

&lt;/LinearLayout&gt;
                </code>
            </pre>

            <ul>
                <li><strong>LinearLayout:</strong> This is a container that arranges child elements in a single
                    direction, either vertically or horizontally. Here, it's set to vertical.</li>
                <li><strong>TextView:</strong> This widget displays the "Hello World!" message. We can set the text
                    size, gravity, and other attributes to customize its appearance.</li>
                <li><strong>android:text:</strong> The text attribute holds the message that will be displayed to the
                    user, which is "Hello World!" in this case.</li>
                <li><strong>android:layout_gravity:</strong> This property centers the TextView within the parent
                    layout.</li>
            </ul>
            <h3>4. Breakdown of Key Classes & Methods</h3>
            <ul>
                <li><strong>AppCompatActivity:</strong> This is a base class for activities that wish to use modern
                    features while providing backward compatibility with older Android versions. It provides important
                    functions like managing the activity lifecycle.</li>
                <li><strong>onCreate(Bundle):</strong> This method is called when the activity is first created. It is
                    used to initialize the activity's UI and logic. Here, we use it to link our layout (XML) file to the
                    Java file.</li>
                <li><strong>TextView:</strong> A user interface element that displays text to the user. It is part of
                    the <i>android.widget</i> package and is used in the layout file.</li>
            </ul>
            <h3>5. Running the Program</h3>
            <p>Once you create the "Hello World" program, you can run it on either an emulator or a physical Android
                device. The app will display a screen with "Hello World!" in the center.</p>
        </div>


    </div>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script src="../../../../public/main.js"></script>
</body>

</html>